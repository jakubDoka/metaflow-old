fun goo[T](x: T) -> T: x

fun ++[T](a, b: T) -> T: a + b

struct Fun:
  a: i32
  b: i32

fun init -> Fun:
  var fn
  
  fn.a = 1
  fn.b = 2
  
  fn

struct Complex:
  embed fn: Fun
  c: i32

fun init2 -> Complex:
  var cp
  
  cp.a = 1
  cp.b = 2
  cp.c = 3
  
  cp

struct Complex2:
  embed fn: &var Fun
  c: &i32

fun boo[T](x: &T) -> T: *x

fun deref -> i32:
  var x
  var y = &x
  *y

fun moo:
  var a
  let b = &a

  a = boo(b)

  let c: i64 = a

fun main -> int:
  var 
    val
    val2 = val

  val ++= 10

  var foo = goo(val)

  var foo = foo

  foo += if foo == 10: 1 else: 1

  if foo == 10:
    return foo
  else:
    foo += 1
  
  if foo <= 30:
    foo = 10
  else:
    return foo
    foo = 10
  
  if foo > 10:
    foo = 20
  else:
    foo = 30 | 6
  
  var i = 0
  loop:
    if i >= 10:
      break
    i += 1
  
  var i = 0
  loop:
    i += 1
    if i < 10:
      continue
    break

  loop: 
    loop: 
      break
    break

  return val

struct Vec:
  x, y: f32

fun +(a, b: Vec) -> Vec:
  var v
  v.x = a.x + b.x
  v.y = a.y + b.y
  v

struct Seq[T]:
  len, cap: i32
  data: &var T

struct Embedded[T]:
  embed vec: Seq[T]

fun push[T](seq: &var Seq[T], x: T): pass

fun something -> Embedded[i64]:
  var a, b: Vec
  
  a.x = 1f32
  a.y = 4f32
  
  b.x = 2f32
  b.y = 3f32
  
  a += b

  var s

  s.push(10)

  s.push(10)

  var v: Embedded[int]

  v.push(10)