Ok(Arguments { filename: "file", flags: ["flag", "flag"], field_flags: [("flag", "value")], args: ["arg", "arg"] })
Ok(Arguments { filename: "file", flags: [], field_flags: [], args: ["string value"] })
Dummy1
[(Dummy(1), 0)]
0
Dummy(1)
[]
[(Dummy(1), 0)]
|> 1:1:text_code.mf
| var something = [1, 2, 3]
| ^
|> 2:1:text_code.mf
| var something = [1, 2, 3]
| ^^^
|> 2:5:text_code.mf
| var something = [1, 2, 3]
|     ^^^^^^^^^
|> 2:15:text_code.mf
| var something = [1, 2, 3]
|               ^
|> 2:17:text_code.mf
| var something = [1, 2, 3]
|                 ^
|> 2:18:text_code.mf
| var something = [1, 2, 3]
|                  ^
|> 2:19:text_code.mf
| var something = [1, 2, 3]
|                   ^
|> 2:21:text_code.mf
| var something = [1, 2, 3]
|                     ^
|> 2:22:text_code.mf
| var something = [1, 2, 3]
|                      ^
|> 2:24:text_code.mf
| var something = [1, 2, 3]
|                        ^
|> 2:25:text_code.mf
| var something = [1, 2, 3]
|                         ^
|> 2:27:text_code.mf
| let hello = "hello"
| ^
|> 3:1:text_code.mf
| let hello = "hello"
| ^^^
|> 3:5:text_code.mf
| let hello = "hello"
|     ^^^^^
|> 3:11:text_code.mf
| let hello = "hello"
|           ^
|> 3:13:text_code.mf
| let hello = "hello"
|             ^^^^^^^
|> 3:21:text_code.mf
| 
| ^
|> 4:2:text_code.mf
| fun something -> fun(int, int) -> int:
| ^
|> 5:1:text_code.mf
| fun something -> fun(int, int) -> int:
| ^^^
|> 5:5:text_code.mf
| fun something -> fun(int, int) -> int:
|     ^^^^^^^^^
|> 5:15:text_code.mf
| fun something -> fun(int, int) -> int:
|               ^^
|> 5:18:text_code.mf
| fun something -> fun(int, int) -> int:
|                  ^^^
|> 5:21:text_code.mf
| fun something -> fun(int, int) -> int:
|                     ^
|> 5:22:text_code.mf
| fun something -> fun(int, int) -> int:
|                      ^^^
|> 5:25:text_code.mf
| fun something -> fun(int, int) -> int:
|                         ^
|> 5:27:text_code.mf
| fun something -> fun(int, int) -> int:
|                           ^^^
|> 5:30:text_code.mf
| fun something -> fun(int, int) -> int:
|                              ^
|> 5:32:text_code.mf
| fun something -> fun(int, int) -> int:
|                                ^^
|> 5:35:text_code.mf
| fun something -> fun(int, int) -> int:
|                                   ^^^
|> 5:38:text_code.mf
| fun something -> fun(int, int) -> int:
|                                      ^
|> 5:40:text_code.mf
|   return fun(a, b: int) -> int: a + b
| ^^
|> 6:3:text_code.mf
|   return fun(a, b: int) -> int: a + b
|   ^^^^^^
|> 6:10:text_code.mf
|   return fun(a, b: int) -> int: a + b
|          ^^^
|> 6:13:text_code.mf
|   return fun(a, b: int) -> int: a + b
|             ^
|> 6:14:text_code.mf
|   return fun(a, b: int) -> int: a + b
|              ^
|> 6:15:text_code.mf
|   return fun(a, b: int) -> int: a + b
|               ^
|> 6:17:text_code.mf
|   return fun(a, b: int) -> int: a + b
|                 ^
|> 6:18:text_code.mf
|   return fun(a, b: int) -> int: a + b
|                  ^
|> 6:20:text_code.mf
|   return fun(a, b: int) -> int: a + b
|                    ^^^
|> 6:23:text_code.mf
|   return fun(a, b: int) -> int: a + b
|                       ^
|> 6:25:text_code.mf
|   return fun(a, b: int) -> int: a + b
|                         ^^
|> 6:28:text_code.mf
|   return fun(a, b: int) -> int: a + b
|                            ^^^
|> 6:31:text_code.mf
|   return fun(a, b: int) -> int: a + b
|                               ^
|> 6:33:text_code.mf
|   return fun(a, b: int) -> int: a + b
|                                 ^
|> 6:35:text_code.mf
|   return fun(a, b: int) -> int: a + b
|                                   ^
|> 6:37:text_code.mf
|   return fun(a, b: int) -> int: a + b
|                                     ^
|> 6:39:text_code.mf
| 
| ^
|> 7:2:text_code.mf
| struct Scope
| ^
|> 8:1:text_code.mf
| struct Scope
| ^^^^^^
|> 8:8:text_code.mf
| struct Scope
|        ^^^^^
|> 8:14:text_code.mf
| 
| ^
|> 9:2:text_code.mf
| impl Scope:
| ^
|> 10:1:text_code.mf
| impl Scope:
| ^^^^
|> 10:6:text_code.mf
| impl Scope:
|      ^^^^^
|> 10:11:text_code.mf
| impl Scope:
|           ^
|> 10:13:text_code.mf
|   fun new -> Self:
| ^^
|> 11:3:text_code.mf
|   fun new -> Self:
|   ^^^
|> 11:7:text_code.mf
|   fun new -> Self:
|       ^^^
|> 11:11:text_code.mf
|   fun new -> Self:
|           ^^
|> 11:14:text_code.mf
|   fun new -> Self:
|              ^^^^
|> 11:18:text_code.mf
|   fun new -> Self:
|                  ^
|> 11:20:text_code.mf
|     return
| ^^^^
|> 12:5:text_code.mf
|     return
|     ^^^^^^
|> 12:12:text_code.mf
|   
| ^^^
|> 13:4:text_code.mf
|   fun do_nothing(s: Self):
| ^^
|> 14:3:text_code.mf
|   fun do_nothing(s: Self):
|   ^^^
|> 14:7:text_code.mf
|   fun do_nothing(s: Self):
|       ^^^^^^^^^^
|> 14:17:text_code.mf
|   fun do_nothing(s: Self):
|                 ^
|> 14:18:text_code.mf
|   fun do_nothing(s: Self):
|                  ^
|> 14:19:text_code.mf
|   fun do_nothing(s: Self):
|                   ^
|> 14:21:text_code.mf
|   fun do_nothing(s: Self):
|                     ^^^^
|> 14:25:text_code.mf
|   fun do_nothing(s: Self):
|                         ^
|> 14:26:text_code.mf
|   fun do_nothing(s: Self):
|                          ^
|> 14:28:text_code.mf
|     pass
| ^^^^
|> 15:5:text_code.mf
|     pass
|     ^^^^
|> 15:10:text_code.mf
| 
| ^
|> 16:2:text_code.mf
| struct Template[T]
| ^
|> 17:1:text_code.mf
| struct Template[T]
| ^^^^^^
|> 17:8:text_code.mf
| struct Template[T]
|        ^^^^^^^^
|> 17:16:text_code.mf
| struct Template[T]
|                ^
|> 17:17:text_code.mf
| struct Template[T]
|                 ^
|> 17:18:text_code.mf
| struct Template[T]
|                  ^
|> 17:20:text_code.mf
| 
| ^
|> 18:2:text_code.mf
| impl[T] Template[T]:
| ^
|> 19:1:text_code.mf
| impl[T] Template[T]:
| ^^^^
|> 19:5:text_code.mf
| impl[T] Template[T]:
|     ^
|> 19:6:text_code.mf
| impl[T] Template[T]:
|      ^
|> 19:7:text_code.mf
| impl[T] Template[T]:
|       ^
|> 19:9:text_code.mf
| impl[T] Template[T]:
|         ^^^^^^^^
|> 19:17:text_code.mf
| impl[T] Template[T]:
|                 ^
|> 19:18:text_code.mf
| impl[T] Template[T]:
|                  ^
|> 19:19:text_code.mf
| impl[T] Template[T]:
|                   ^
|> 19:20:text_code.mf
| impl[T] Template[T]:
|                    ^
|> 19:22:text_code.mf
|   fun new -> Self:
| ^^
|> 20:3:text_code.mf
|   fun new -> Self:
|   ^^^
|> 20:7:text_code.mf
|   fun new -> Self:
|       ^^^
|> 20:11:text_code.mf
|   fun new -> Self:
|           ^^
|> 20:14:text_code.mf
|   fun new -> Self:
|              ^^^^
|> 20:18:text_code.mf
|   fun new -> Self:
|                  ^
|> 20:20:text_code.mf
|     return
| ^^^^
|> 21:5:text_code.mf
|     return
|     ^^^^^^
|> 21:12:text_code.mf
|   
| ^^^
|> 22:4:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
| ^^
|> 23:3:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|   ^^^
|> 23:7:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|       ^^^^^^^^^^
|> 23:17:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                 ^
|> 23:18:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                  ^
|> 23:19:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                   ^
|> 23:21:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                     ^^^^
|> 23:25:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                         ^
|> 23:27:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                           ^^^^^
|> 23:32:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                                ^
|> 23:34:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                                  ^
|> 23:35:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                                   ^
|> 23:37:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                                     ^^
|> 23:40:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                                        ^
|> 23:41:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                                         ^
|> 23:43:text_code.mf
|     value
| ^^^^
|> 24:5:text_code.mf
|     value
|     ^^^^^
|> 24:11:text_code.mf
| 
| ^
|> 25:2:text_code.mf
| fun use_chain:
| ^
|> 26:1:text_code.mf
| fun use_chain:
| ^^^
|> 26:5:text_code.mf
| fun use_chain:
|     ^^^^^^^^^
|> 26:14:text_code.mf
| fun use_chain:
|              ^
|> 26:16:text_code.mf
|   module::Type::method::[param]()
| ^^
|> 27:3:text_code.mf
|   module::Type::method::[param]()
|   ^^^^^^
|> 27:9:text_code.mf
|   module::Type::method::[param]()
|         ^^
|> 27:11:text_code.mf
|   module::Type::method::[param]()
|           ^^^^
|> 27:15:text_code.mf
|   module::Type::method::[param]()
|               ^^
|> 27:17:text_code.mf
|   module::Type::method::[param]()
|                 ^^^^^^
|> 27:23:text_code.mf
|   module::Type::method::[param]()
|                       ^^
|> 27:25:text_code.mf
|   module::Type::method::[param]()
|                         ^
|> 27:26:text_code.mf
|   module::Type::method::[param]()
|                          ^^^^^
|> 27:31:text_code.mf
|   module::Type::method::[param]()
|                               ^
|> 27:32:text_code.mf
|   module::Type::method::[param]()
|                                ^
|> 27:33:text_code.mf
|   module::Type::method::[param]()
|                                 ^
|> 27:35:text_code.mf
| 
| ^
|> 28:2:text_code.mf
| fun flo: pass
| ^
|> 29:1:text_code.mf
| fun flo: pass
| ^^^
|> 29:5:text_code.mf
| fun flo: pass
|     ^^^
|> 29:8:text_code.mf
| fun flo: pass
|        ^
|> 29:10:text_code.mf
| fun flo: pass
|          ^^^^
|> 29:15:text_code.mf
| 
| ^
|> 30:2:text_code.mf
| fun foo(): pass
| ^
|> 31:1:text_code.mf
| fun foo(): pass
| ^^^
|> 31:5:text_code.mf
| fun foo(): pass
|     ^^^
|> 31:8:text_code.mf
| fun foo(): pass
|        ^
|> 31:9:text_code.mf
| fun foo(): pass
|         ^
|> 31:10:text_code.mf
| fun foo(): pass
|          ^
|> 31:12:text_code.mf
| fun foo(): pass
|            ^^^^
|> 31:17:text_code.mf
| 
| ^
|> 32:2:text_code.mf
| fun goo(a: i8, b: i8): pass
| ^
|> 33:1:text_code.mf
| fun goo(a: i8, b: i8): pass
| ^^^
|> 33:5:text_code.mf
| fun goo(a: i8, b: i8): pass
|     ^^^
|> 33:8:text_code.mf
| fun goo(a: i8, b: i8): pass
|        ^
|> 33:9:text_code.mf
| fun goo(a: i8, b: i8): pass
|         ^
|> 33:10:text_code.mf
| fun goo(a: i8, b: i8): pass
|          ^
|> 33:12:text_code.mf
| fun goo(a: i8, b: i8): pass
|            ^^
|> 33:14:text_code.mf
| fun goo(a: i8, b: i8): pass
|              ^
|> 33:16:text_code.mf
| fun goo(a: i8, b: i8): pass
|                ^
|> 33:17:text_code.mf
| fun goo(a: i8, b: i8): pass
|                 ^
|> 33:19:text_code.mf
| fun goo(a: i8, b: i8): pass
|                   ^^
|> 33:21:text_code.mf
| fun goo(a: i8, b: i8): pass
|                     ^
|> 33:22:text_code.mf
| fun goo(a: i8, b: i8): pass
|                      ^
|> 33:24:text_code.mf
| fun goo(a: i8, b: i8): pass
|                        ^^^^
|> 33:29:text_code.mf
| 
| ^
|> 34:2:text_code.mf
| fun loo:
| ^
|> 35:1:text_code.mf
| fun loo:
| ^^^
|> 35:5:text_code.mf
| fun loo:
|     ^^^
|> 35:8:text_code.mf
| fun loo:
|        ^
|> 35:10:text_code.mf
|   noo::loo::[i8]()
| ^^
|> 36:3:text_code.mf
|   noo::loo::[i8]()
|   ^^^
|> 36:6:text_code.mf
|   noo::loo::[i8]()
|      ^^
|> 36:8:text_code.mf
|   noo::loo::[i8]()
|        ^^^
|> 36:11:text_code.mf
|   noo::loo::[i8]()
|           ^^
|> 36:13:text_code.mf
|   noo::loo::[i8]()
|             ^
|> 36:14:text_code.mf
|   noo::loo::[i8]()
|              ^^
|> 36:16:text_code.mf
|   noo::loo::[i8]()
|                ^
|> 36:17:text_code.mf
|   noo::loo::[i8]()
|                 ^
|> 36:18:text_code.mf
|   noo::loo::[i8]()
|                  ^
|> 36:20:text_code.mf
| 
| ^
|> 37:2:text_code.mf
|   let array = [1, 2, 3]
| ^^
|> 38:3:text_code.mf
|   let array = [1, 2, 3]
|   ^^^
|> 38:7:text_code.mf
|   let array = [1, 2, 3]
|       ^^^^^
|> 38:13:text_code.mf
|   let array = [1, 2, 3]
|             ^
|> 38:15:text_code.mf
|   let array = [1, 2, 3]
|               ^
|> 38:16:text_code.mf
|   let array = [1, 2, 3]
|                ^
|> 38:17:text_code.mf
|   let array = [1, 2, 3]
|                 ^
|> 38:19:text_code.mf
|   let array = [1, 2, 3]
|                   ^
|> 38:20:text_code.mf
|   let array = [1, 2, 3]
|                    ^
|> 38:22:text_code.mf
|   let array = [1, 2, 3]
|                      ^
|> 38:23:text_code.mf
|   let array = [1, 2, 3]
|                       ^
|> 38:25:text_code.mf
|   array[0] = 3
| ^^
|> 39:3:text_code.mf
|   array[0] = 3
|   ^^^^^
|> 39:8:text_code.mf
|   array[0] = 3
|        ^
|> 39:9:text_code.mf
|   array[0] = 3
|         ^
|> 39:10:text_code.mf
|   array[0] = 3
|          ^
|> 39:12:text_code.mf
|   array[0] = 3
|            ^
|> 39:14:text_code.mf
|   array[0] = 3
|              ^
|> 39:16:text_code.mf
|   array[2] = always[1]
| ^^
|> 40:3:text_code.mf
|   array[2] = always[1]
|   ^^^^^
|> 40:8:text_code.mf
|   array[2] = always[1]
|        ^
|> 40:9:text_code.mf
|   array[2] = always[1]
|         ^
|> 40:10:text_code.mf
|   array[2] = always[1]
|          ^
|> 40:12:text_code.mf
|   array[2] = always[1]
|            ^
|> 40:14:text_code.mf
|   array[2] = always[1]
|              ^^^^^^
|> 40:20:text_code.mf
|   array[2] = always[1]
|                    ^
|> 40:21:text_code.mf
|   array[2] = always[1]
|                     ^
|> 40:22:text_code.mf
|   array[2] = always[1]
|                      ^
|> 40:24:text_code.mf
|   array[1] = 1
| ^^
|> 41:3:text_code.mf
|   array[1] = 1
|   ^^^^^
|> 41:8:text_code.mf
|   array[1] = 1
|        ^
|> 41:9:text_code.mf
|   array[1] = 1
|         ^
|> 41:10:text_code.mf
|   array[1] = 1
|          ^
|> 41:12:text_code.mf
|   array[1] = 1
|            ^
|> 41:14:text_code.mf
|   array[1] = 1
|              ^
|> 41:16:text_code.mf
| 
| ^
|> 42:2:text_code.mf
|   pass
| ^^
|> 43:3:text_code.mf
|   pass
|   ^^^^
|> 43:8:text_code.mf
| 
| ^
|> 44:2:text_code.mf
| fun main -> i64:
| ^
|> 45:1:text_code.mf
| fun main -> i64:
| ^^^
|> 45:5:text_code.mf
| fun main -> i64:
|     ^^^^
|> 45:10:text_code.mf
| fun main -> i64:
|          ^^
|> 45:13:text_code.mf
| fun main -> i64:
|             ^^^
|> 45:16:text_code.mf
| fun main -> i64:
|                ^
|> 45:18:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
| ^^
|> 46:3:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|   ^^^^^^
|> 46:10:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|          ^^
|> 46:13:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|             ^
|> 46:15:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|               ^
|> 46:17:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|                 ^
|> 46:19:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|                   ^
|> 46:21:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|                     ^
|> 46:23:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|                       ^
|> 46:25:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|                         ^
|> 46:27:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|                           ^
|> 46:29:text_code.mf
| 
| ^
|> 47:2:text_code.mf
| fun operator_stress_test -> i64:
| ^
|> 48:1:text_code.mf
| fun operator_stress_test -> i64:
| ^^^
|> 48:5:text_code.mf
| fun operator_stress_test -> i64:
|     ^^^^^^^^^^^^^^^^^^^^
|> 48:26:text_code.mf
| fun operator_stress_test -> i64:
|                          ^^
|> 48:29:text_code.mf
| fun operator_stress_test -> i64:
|                             ^^^
|> 48:32:text_code.mf
| fun operator_stress_test -> i64:
|                                ^
|> 48:34:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
| ^^
|> 49:3:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|   ^^^^^^
|> 49:10:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|          ^^
|> 49:13:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|             ^
|> 49:15:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|               ^
|> 49:17:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                 ^
|> 49:19:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                   ^
|> 49:21:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                     ^
|> 49:23:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                       ^
|> 49:25:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                         ^
|> 49:27:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                           ^
|> 49:29:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                             ^
|> 49:31:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                               ^
|> 49:33:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                 ^
|> 49:35:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                   ^
|> 49:37:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                     ^^
|> 49:40:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                        ^
|> 49:42:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                          ^^
|> 49:45:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                             ^
|> 49:47:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                               ^^^
|> 49:51:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                                   ^^
|> 49:54:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                                      ^^^
|> 49:58:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                                          ^^
|> 49:61:text_code.mf
| 
| ^
|> 50:2:text_code.mf
| fun conditional -> i64:
| ^
|> 51:1:text_code.mf
| fun conditional -> i64:
| ^^^
|> 51:5:text_code.mf
| fun conditional -> i64:
|     ^^^^^^^^^^^
|> 51:17:text_code.mf
| fun conditional -> i64:
|                 ^^
|> 51:20:text_code.mf
| fun conditional -> i64:
|                    ^^^
|> 51:23:text_code.mf
| fun conditional -> i64:
|                       ^
|> 51:25:text_code.mf
|   if false:
| ^^
|> 52:3:text_code.mf
|   if false:
|   ^^
|> 52:6:text_code.mf
|   if false:
|      ^^^^^
|> 52:11:text_code.mf
|   if false:
|           ^
|> 52:13:text_code.mf
|     return 10
| ^^^^
|> 53:5:text_code.mf
|     return 10
|     ^^^^^^
|> 53:12:text_code.mf
|     return 10
|            ^^
|> 53:15:text_code.mf
|   elif true:
| ^^
|> 54:3:text_code.mf
|   elif true:
|   ^^^^
|> 54:8:text_code.mf
|   elif true:
|        ^^^^
|> 54:12:text_code.mf
|   elif true:
|            ^
|> 54:14:text_code.mf
|     return if true: 10 else: 20
| ^^^^
|> 55:5:text_code.mf
|     return if true: 10 else: 20
|     ^^^^^^
|> 55:12:text_code.mf
|     return if true: 10 else: 20
|            ^^
|> 55:15:text_code.mf
|     return if true: 10 else: 20
|               ^^^^
|> 55:19:text_code.mf
|     return if true: 10 else: 20
|                   ^
|> 55:21:text_code.mf
|     return if true: 10 else: 20
|                     ^^
|> 55:24:text_code.mf
|     return if true: 10 else: 20
|                        ^^^^
|> 55:28:text_code.mf
|     return if true: 10 else: 20
|                            ^
|> 55:30:text_code.mf
|     return if true: 10 else: 20
|                              ^^
|> 55:33:text_code.mf
|   else:
| ^^
|> 56:3:text_code.mf
|   else:
|   ^^^^
|> 56:7:text_code.mf
|   else:
|       ^
|> 56:9:text_code.mf
|     return 0
| ^^^^
|> 57:5:text_code.mf
|     return 0
|     ^^^^^^
|> 57:12:text_code.mf
|     return 0
|            ^
|> 57:14:text_code.mf
| 
| ^
|> 58:2:text_code.mf
| attr inline = always, call_conv = cold
| ^
|> 59:1:text_code.mf
| attr inline = always, call_conv = cold
| ^^^^
|> 59:6:text_code.mf
| attr inline = always, call_conv = cold
|      ^^^^^^
|> 59:13:text_code.mf
| attr inline = always, call_conv = cold
|             ^
|> 59:15:text_code.mf
| attr inline = always, call_conv = cold
|               ^^^^^^
|> 59:21:text_code.mf
| attr inline = always, call_conv = cold
|                     ^
|> 59:23:text_code.mf
| attr inline = always, call_conv = cold
|                       ^^^^^^^^^
|> 59:33:text_code.mf
| attr inline = always, call_conv = cold
|                                 ^
|> 59:35:text_code.mf
| attr inline = always, call_conv = cold
|                                   ^^^^
|> 59:40:text_code.mf
| fun inline_fn -> u32:
| ^
|> 60:1:text_code.mf
| fun inline_fn -> u32:
| ^^^
|> 60:5:text_code.mf
| fun inline_fn -> u32:
|     ^^^^^^^^^
|> 60:15:text_code.mf
| fun inline_fn -> u32:
|               ^^
|> 60:18:text_code.mf
| fun inline_fn -> u32:
|                  ^^^
|> 60:21:text_code.mf
| fun inline_fn -> u32:
|                     ^
|> 60:23:text_code.mf
|   return 10
| ^^
|> 61:3:text_code.mf
|   return 10
|   ^^^^^^
|> 61:10:text_code.mf
|   return 10
|          ^^
|> 61:13:text_code.mf
| 
| ^
|> 62:2:text_code.mf
| fun fib(v: i64) -> i64:
| ^
|> 63:1:text_code.mf
| fun fib(v: i64) -> i64:
| ^^^
|> 63:5:text_code.mf
| fun fib(v: i64) -> i64:
|     ^^^
|> 63:8:text_code.mf
| fun fib(v: i64) -> i64:
|        ^
|> 63:9:text_code.mf
| fun fib(v: i64) -> i64:
|         ^
|> 63:10:text_code.mf
| fun fib(v: i64) -> i64:
|          ^
|> 63:12:text_code.mf
| fun fib(v: i64) -> i64:
|            ^^^
|> 63:15:text_code.mf
| fun fib(v: i64) -> i64:
|               ^
|> 63:17:text_code.mf
| fun fib(v: i64) -> i64:
|                 ^^
|> 63:20:text_code.mf
| fun fib(v: i64) -> i64:
|                    ^^^
|> 63:23:text_code.mf
| fun fib(v: i64) -> i64:
|                       ^
|> 63:25:text_code.mf
|   return if v == 0 | v == 1:
| ^^
|> 64:3:text_code.mf
|   return if v == 0 | v == 1:
|   ^^^^^^
|> 64:10:text_code.mf
|   return if v == 0 | v == 1:
|          ^^
|> 64:13:text_code.mf
|   return if v == 0 | v == 1:
|             ^
|> 64:15:text_code.mf
|   return if v == 0 | v == 1:
|               ^^
|> 64:18:text_code.mf
|   return if v == 0 | v == 1:
|                  ^
|> 64:20:text_code.mf
|   return if v == 0 | v == 1:
|                    ^
|> 64:22:text_code.mf
|   return if v == 0 | v == 1:
|                      ^
|> 64:24:text_code.mf
|   return if v == 0 | v == 1:
|                        ^^
|> 64:27:text_code.mf
|   return if v == 0 | v == 1:
|                           ^
|> 64:28:text_code.mf
|   return if v == 0 | v == 1:
|                            ^
|> 64:30:text_code.mf
|     1
| ^^^^
|> 65:5:text_code.mf
|     1
|     ^
|> 65:7:text_code.mf
|   else:
| ^^
|> 66:3:text_code.mf
|   else:
|   ^^^^
|> 66:7:text_code.mf
|   else:
|       ^
|> 66:9:text_code.mf
|     fib(v - 1) + fib(v - 2)
| ^^^^
|> 67:5:text_code.mf
|     fib(v - 1) + fib(v - 2)
|     ^^^
|> 67:8:text_code.mf
|     fib(v - 1) + fib(v - 2)
|        ^
|> 67:9:text_code.mf
|     fib(v - 1) + fib(v - 2)
|         ^
|> 67:11:text_code.mf
|     fib(v - 1) + fib(v - 2)
|           ^
|> 67:13:text_code.mf
|     fib(v - 1) + fib(v - 2)
|             ^
|> 67:14:text_code.mf
|     fib(v - 1) + fib(v - 2)
|              ^
|> 67:16:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                ^
|> 67:18:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                  ^^^
|> 67:21:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                     ^
|> 67:22:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                      ^
|> 67:24:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                        ^
|> 67:26:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                          ^
|> 67:27:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                           ^
|> 67:29:text_code.mf
| 
| ^
|> 68:2:text_code.mf
| fun fib_loop(v: i64) -> i64:
| ^
|> 69:1:text_code.mf
| fun fib_loop(v: i64) -> i64:
| ^^^
|> 69:5:text_code.mf
| fun fib_loop(v: i64) -> i64:
|     ^^^^^^^^
|> 69:13:text_code.mf
| fun fib_loop(v: i64) -> i64:
|             ^
|> 69:14:text_code.mf
| fun fib_loop(v: i64) -> i64:
|              ^
|> 69:15:text_code.mf
| fun fib_loop(v: i64) -> i64:
|               ^
|> 69:17:text_code.mf
| fun fib_loop(v: i64) -> i64:
|                 ^^^
|> 69:20:text_code.mf
| fun fib_loop(v: i64) -> i64:
|                    ^
|> 69:22:text_code.mf
| fun fib_loop(v: i64) -> i64:
|                      ^^
|> 69:25:text_code.mf
| fun fib_loop(v: i64) -> i64:
|                         ^^^
|> 69:28:text_code.mf
| fun fib_loop(v: i64) -> i64:
|                            ^
|> 69:30:text_code.mf
|   var a, b, c = 1
| ^^
|> 70:3:text_code.mf
|   var a, b, c = 1
|   ^^^
|> 70:7:text_code.mf
|   var a, b, c = 1
|       ^
|> 70:8:text_code.mf
|   var a, b, c = 1
|        ^
|> 70:10:text_code.mf
|   var a, b, c = 1
|          ^
|> 70:11:text_code.mf
|   var a, b, c = 1
|           ^
|> 70:13:text_code.mf
|   var a, b, c = 1
|             ^
|> 70:15:text_code.mf
|   var a, b, c = 1
|               ^
|> 70:17:text_code.mf
|   var a, b, c = 1
|                 ^
|> 70:19:text_code.mf
|   loop'a:
| ^^
|> 71:3:text_code.mf
|   loop'a:
|   ^^^^
|> 71:7:text_code.mf
|   loop'a:
|       ^^
|> 71:9:text_code.mf
|   loop'a:
|         ^
|> 71:11:text_code.mf
|     c = a + b
| ^^^^
|> 72:5:text_code.mf
|     c = a + b
|     ^
|> 72:7:text_code.mf
|     c = a + b
|       ^
|> 72:9:text_code.mf
|     c = a + b
|         ^
|> 72:11:text_code.mf
|     c = a + b
|           ^
|> 72:13:text_code.mf
|     c = a + b
|             ^
|> 72:15:text_code.mf
|     a = b
| ^^^^
|> 73:5:text_code.mf
|     a = b
|     ^
|> 73:7:text_code.mf
|     a = b
|       ^
|> 73:9:text_code.mf
|     a = b
|         ^
|> 73:11:text_code.mf
|     b = c
| ^^^^
|> 74:5:text_code.mf
|     b = c
|     ^
|> 74:7:text_code.mf
|     b = c
|       ^
|> 74:9:text_code.mf
|     b = c
|         ^
|> 74:11:text_code.mf
|     v = v - 1
| ^^^^
|> 75:5:text_code.mf
|     v = v - 1
|     ^
|> 75:7:text_code.mf
|     v = v - 1
|       ^
|> 75:9:text_code.mf
|     v = v - 1
|         ^
|> 75:11:text_code.mf
|     v = v - 1
|           ^
|> 75:13:text_code.mf
|     v = v - 1
|             ^
|> 75:15:text_code.mf
|     if v == 0:
| ^^^^
|> 76:5:text_code.mf
|     if v == 0:
|     ^^
|> 76:8:text_code.mf
|     if v == 0:
|        ^
|> 76:10:text_code.mf
|     if v == 0:
|          ^^
|> 76:13:text_code.mf
|     if v == 0:
|             ^
|> 76:14:text_code.mf
|     if v == 0:
|              ^
|> 76:16:text_code.mf
|       break'a
| ^^^^^^
|> 77:7:text_code.mf
|       break'a
|       ^^^^^
|> 77:12:text_code.mf
|       break'a
|            ^^
|> 77:15:text_code.mf
|   return c
| ^^
|> 78:3:text_code.mf
|   return c
|   ^^^^^^
|> 78:10:text_code.mf
|   return c
|          ^
|> 78:12:text_code.mf
| 
| ^
|> 79:2:text_code.mf
| fun unary_operators(a: i64) -> i64:
| ^
|> 80:1:text_code.mf
| fun unary_operators(a: i64) -> i64:
| ^^^
|> 80:5:text_code.mf
| fun unary_operators(a: i64) -> i64:
|     ^^^^^^^^^^^^^^^
|> 80:20:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                    ^
|> 80:21:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                     ^
|> 80:22:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                      ^
|> 80:24:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                        ^^^
|> 80:27:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                           ^
|> 80:29:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                             ^^
|> 80:32:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                                ^^^
|> 80:35:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                                   ^
|> 80:37:text_code.mf
|   return -a + ~a + !a + ++a + --a
| ^^
|> 81:3:text_code.mf
|   return -a + ~a + !a + ++a + --a
|   ^^^^^^
|> 81:10:text_code.mf
|   return -a + ~a + !a + ++a + --a
|          ^
|> 81:11:text_code.mf
|   return -a + ~a + !a + ++a + --a
|           ^
|> 81:13:text_code.mf
|   return -a + ~a + !a + ++a + --a
|             ^
|> 81:15:text_code.mf
|   return -a + ~a + !a + ++a + --a
|               ^
|> 81:16:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                ^
|> 81:18:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                  ^
|> 81:20:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                    ^
|> 81:21:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                     ^
|> 81:23:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                       ^
|> 81:25:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                         ^^
|> 81:27:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                           ^
|> 81:29:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                             ^
|> 81:31:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                               ^^
|> 81:33:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                                 ^
|> 81:35:text_code.mf
| 
| ^
|> 82:2:text_code.mf
| struct Foo:
| ^
|> 83:1:text_code.mf
| struct Foo:
| ^^^^^^
|> 83:8:text_code.mf
| struct Foo:
|        ^^^
|> 83:11:text_code.mf
| struct Foo:
|           ^
|> 83:13:text_code.mf
|   a, b, c: int
| ^^
|> 84:3:text_code.mf
|   a, b, c: int
|   ^
|> 84:4:text_code.mf
|   a, b, c: int
|    ^
|> 84:6:text_code.mf
|   a, b, c: int
|      ^
|> 84:7:text_code.mf
|   a, b, c: int
|       ^
|> 84:9:text_code.mf
|   a, b, c: int
|         ^
|> 84:10:text_code.mf
|   a, b, c: int
|          ^
|> 84:12:text_code.mf
|   a, b, c: int
|            ^^^
|> 84:16:text_code.mf
| 
| ^
|> 85:2:text_code.mf
| struct Goo:
| ^
|> 86:1:text_code.mf
| struct Goo:
| ^^^^^^
|> 86:8:text_code.mf
| struct Goo:
|        ^^^
|> 86:11:text_code.mf
| struct Goo:
|           ^
|> 86:13:text_code.mf
|   embed foo: Foo
| ^^
|> 87:3:text_code.mf
|   embed foo: Foo
|   ^^^^^
|> 87:9:text_code.mf
|   embed foo: Foo
|         ^^^
|> 87:12:text_code.mf
|   embed foo: Foo
|            ^
|> 87:14:text_code.mf
|   embed foo: Foo
|              ^^^
|> 87:18:text_code.mf
|   gva: int
| ^^
|> 88:3:text_code.mf
|   gva: int
|   ^^^
|> 88:6:text_code.mf
|   gva: int
|      ^
|> 88:8:text_code.mf
|   gva: int
|        ^^^
|> 88:12:text_code.mf
| 
| ^
|> 89:2:text_code.mf
| fun strings -> i64:
| ^
|> 90:1:text_code.mf
| fun strings -> i64:
| ^^^
|> 90:5:text_code.mf
| fun strings -> i64:
|     ^^^^^^^
|> 90:13:text_code.mf
| fun strings -> i64:
|             ^^
|> 90:16:text_code.mf
| fun strings -> i64:
|                ^^^
|> 90:19:text_code.mf
| fun strings -> i64:
|                   ^
|> 90:21:text_code.mf
|   var hello = "hello"
| ^^
|> 91:3:text_code.mf
|   var hello = "hello"
|   ^^^
|> 91:7:text_code.mf
|   var hello = "hello"
|       ^^^^^
|> 91:13:text_code.mf
|   var hello = "hello"
|             ^
|> 91:15:text_code.mf
|   var hello = "hello"
|               ^^^^^^^
|> 91:23:text_code.mf
|   return 0
| ^^
|> 92:3:text_code.mf
|   return 0
|   ^^^^^^
|> 92:10:text_code.mf
|   return 0
|          ^
|> 92:12:text_code.mf
| 
| ^
|> 93:2:text_code.mf
| fun mutable_ref(a: &Foo):
| ^
|> 94:1:text_code.mf
| fun mutable_ref(a: &Foo):
| ^^^
|> 94:5:text_code.mf
| fun mutable_ref(a: &Foo):
|     ^^^^^^^^^^^
|> 94:16:text_code.mf
| fun mutable_ref(a: &Foo):
|                ^
|> 94:17:text_code.mf
| fun mutable_ref(a: &Foo):
|                 ^
|> 94:18:text_code.mf
| fun mutable_ref(a: &Foo):
|                  ^
|> 94:20:text_code.mf
| fun mutable_ref(a: &Foo):
|                    ^
|> 94:21:text_code.mf
| fun mutable_ref(a: &Foo):
|                     ^^^
|> 94:24:text_code.mf
| fun mutable_ref(a: &Foo):
|                        ^
|> 94:25:text_code.mf
| fun mutable_ref(a: &Foo):
|                         ^
|> 94:27:text_code.mf
|   a.a = 10
| ^^
|> 95:3:text_code.mf
|   a.a = 10
|   ^
|> 95:4:text_code.mf
|   a.a = 10
|    ^
|> 95:5:text_code.mf
|   a.a = 10
|     ^
|> 95:7:text_code.mf
|   a.a = 10
|       ^
|> 95:9:text_code.mf
|   a.a = 10
|         ^^
|> 95:12:text_code.mf
|   a.b = 20
| ^^
|> 96:3:text_code.mf
|   a.b = 20
|   ^
|> 96:4:text_code.mf
|   a.b = 20
|    ^
|> 96:5:text_code.mf
|   a.b = 20
|     ^
|> 96:7:text_code.mf
|   a.b = 20
|       ^
|> 96:9:text_code.mf
|   a.b = 20
|         ^^
|> 96:12:text_code.mf
|   a.c = 30
| ^^
|> 97:3:text_code.mf
|   a.c = 30
|   ^
|> 97:4:text_code.mf
|   a.c = 30
|    ^
|> 97:5:text_code.mf
|   a.c = 30
|     ^
|> 97:7:text_code.mf
|   a.c = 30
|       ^
|> 97:9:text_code.mf
|   a.c = 30
|         ^^
|> 97:12:text_code.mf
| 
| ^
|> 98:2:text_code.mf
| fun some_string -> &u8:
| ^
|> 99:1:text_code.mf
| fun some_string -> &u8:
| ^^^
|> 99:5:text_code.mf
| fun some_string -> &u8:
|     ^^^^^^^^^^^
|> 99:17:text_code.mf
| fun some_string -> &u8:
|                 ^^
|> 99:20:text_code.mf
| fun some_string -> &u8:
|                    ^
|> 99:21:text_code.mf
| fun some_string -> &u8:
|                     ^^
|> 99:23:text_code.mf
| fun some_string -> &u8:
|                       ^
|> 99:25:text_code.mf
|   "
| ^^
|> 100:3:text_code.mf
|   "
| hello there
|   "
| ^^^^^^^^^^^
Group "\n":
 VarStatement(None, true) "var something = [1, 2, 3]":
  VarAssign "something = [1, 2, 3]":
   Group "something":
    Ident "something"
   None ""
   Group "=":
    Array "[":
     Lit "1"
     Lit "2"
     Lit "3"
 VarStatement(None, false) "let hello = \"hello\"":
  VarAssign "hello = \"hello\"":
   Group "hello":
    Ident "hello"
   None ""
   Group "=":
    Lit "\"hello\""
 Fun(None) "fun something -> fun(int, int) -> int:\r\n  return fun(a, b: int) -> int: a + b":
  FunHeader "fun something -> fun(int, int) -> int:\r\n  return fun(a, b: int) -> int: a + b":
   Ident "something"
   Fun(None) "fun(int, int) -> int:\r\n  return fun(a, b: int) -> int: a + b":
    FunHeader "fun(int, int) -> int":
     None ""
     Ident "int"
     Ident "int"
     Ident "int"
    Group ":":
     ReturnStatement "return fun(a, b: int) -> int: a + b":
      Fun(None) "fun(a, b: int) -> int: a + b":
       FunHeader "fun(a, b: int) -> int":
        None ""
        FunArgument(false) "a, b: int":
         Ident "a"
         Ident "b"
         Ident "int"
        Ident "int"
       Group ":":
        BinaryOp "a + b":
         Ident "+"
         Ident "a"
         Ident "b"
  None ""
 StructDeclaration(None) "struct":
  Ident "Scope"
  None ""
 Impl(None) "impl":
  None ""
  Ident "Scope"
  Group ":":
   Fun(None) "fun new -> Self:\r\n    return":
    FunHeader "fun new -> Self":
     Ident "new"
     Ident "Self"
    Group ":":
     ReturnStatement "return":
      None ""
   Fun(None) "fun do_nothing(s: Self):\r\n    pass":
    FunHeader "fun do_nothing(s: Self)":
     Ident "do_nothing"
     FunArgument(false) "s: Self":
      Ident "s"
      Ident "Self"
     None ""
    Group ":":
     Pass "pass"
 StructDeclaration(None) "struct":
  Instantiation "Template[T]":
   Ident "Template"
   Ident "T"
  None ""
 Impl(None) "impl":
  Group "[":
   Ident "T"
  Instantiation "Template[T]":
   Ident "Template"
   Ident "T"
  Group ":":
   Fun(None) "fun new -> Self:\r\n    return":
    FunHeader "fun new -> Self":
     Ident "new"
     Ident "Self"
    Group ":":
     ReturnStatement "return":
      None ""
   Fun(None) "fun do_nothing(s: Self, value: T) -> T:\r\n    value":
    FunHeader "fun do_nothing(s: Self, value: T) -> T":
     Ident "do_nothing"
     FunArgument(false) "s: Self":
      Ident "s"
      Ident "Self"
     FunArgument(false) "value: T":
      Ident "value"
      Ident "T"
     Ident "T"
    Group ":":
     Ident "value"
 Fun(None) "fun use_chain:\r\n  module::Type::method::[param]()":
  FunHeader "fun use_chain":
   Ident "use_chain"
   None ""
  Group ":":
   Call(false) "module::Type::method::[param]()":
    Instantiation "module::Type::method::[param]":
     Path "module::Type::method":
      Ident "module"
      Ident "Type"
      Ident "method"
     Ident "param"
 Fun(None) "fun flo: pass":
  FunHeader "fun flo":
   Ident "flo"
   None ""
  Group ":":
   Pass "pass"
 Fun(None) "fun foo(): pass":
  FunHeader "fun foo()":
   Ident "foo"
   None ""
  Group ":":
   Pass "pass"
 Fun(None) "fun goo(a: i8, b: i8): pass":
  FunHeader "fun goo(a: i8, b: i8)":
   Ident "goo"
   FunArgument(false) "a: i8":
    Ident "a"
    Ident "i8"
   FunArgument(false) "b: i8":
    Ident "b"
    Ident "i8"
   None ""
  Group ":":
   Pass "pass"
 Fun(None) "fun loo:\r\n  noo::loo::[i8]()\r\n\r\n  let array = [1, 2, 3]\r\n  array[0] = 3\r\n  array[2] = always[1]\r\n  array[1] = 1\r\n\r\n  pass":
  FunHeader "fun loo":
   Ident "loo"
   None ""
  Group ":":
   Call(false) "noo::loo::[i8]()":
    Instantiation "noo::loo::[i8]":
     Path "noo::loo":
      Ident "noo"
      Ident "loo"
     Ident "i8"
   VarStatement(None, false) "let array = [1, 2, 3]":
    VarAssign "array = [1, 2, 3]":
     Group "array":
      Ident "array"
     None ""
     Group "=":
      Array "[":
       Lit "1"
       Lit "2"
       Lit "3"
   BinaryOp "array[0] = 3":
    Ident "="
    Index "array[0]":
     Ident "array"
     Lit "0"
    Lit "3"
   BinaryOp "array[2] = always[1]":
    Ident "="
    Index "array[2]":
     Ident "array"
     Lit "2"
    Index "always[1]":
     Ident "always"
     Lit "1"
   BinaryOp "array[1] = 1":
    Ident "="
    Index "array[1]":
     Ident "array"
     Lit "1"
    Lit "1"
   Pass "pass"
 Fun(None) "fun main -> i64:\r\n  return 10 + 4 - 2 * 1 + 8":
  FunHeader "fun main -> i64":
   Ident "main"
   Ident "i64"
  Group ":":
   ReturnStatement "return 10 + 4 - 2 * 1 + 8":
    BinaryOp "10 + 4 - 2 * 1 + 8":
     Ident "-"
     BinaryOp "10 + 4":
      Ident "+"
      Lit "10"
      Lit "4"
     BinaryOp "2 * 1 + 8":
      Ident "+"
      BinaryOp "2 * 1":
       Ident "*"
       Lit "2"
       Lit "1"
      Lit "8"
 Fun(None) "fun operator_stress_test -> i64:\r\n  return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10":
  FunHeader "fun operator_stress_test -> i64":
   Ident "operator_stress_test"
   Ident "i64"
  Group ":":
   ReturnStatement "return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10":
    BinaryOp "10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10":
     Ident "+"
     Lit "10"
     BinaryOp "2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10":
      Ident "|"
      BinaryOp "2 * 1 - 9":
       Ident "-"
       BinaryOp "2 * 1":
        Ident "*"
        Lit "2"
        Lit "1"
       Lit "9"
      BinaryOp "4 & 1 ^ 2 >> 1 << 7 min 20 max 10":
       Ident "^"
       BinaryOp "4 & 1":
        Ident "&"
        Lit "4"
        Lit "1"
       BinaryOp "2 >> 1 << 7 min 20 max 10":
        Ident "max"
        BinaryOp "2 >> 1 << 7 min 20":
         Ident "min"
         BinaryOp "2 >> 1 << 7":
          Ident "<<"
          BinaryOp "2 >> 1":
           Ident ">>"
           Lit "2"
           Lit "1"
          Lit "7"
         Lit "20"
        Lit "10"
 Fun(None) "fun conditional -> i64:\r\n  if false:\r\n    return 10\r\n  elif true:\r\n    return if true: 10 else: 20\r\n  else:\r\n    return 0":
  FunHeader "fun conditional -> i64":
   Ident "conditional"
   Ident "i64"
  Group ":":
   IfExpr "if false:\r\n    return 10\r\n  elif true:\r\n    return if true: 10 else: 20\r\n  else:\r\n    return 0":
    Lit "false"
    Group ":":
     ReturnStatement "return 10":
      Lit "10"
    Group "elif":
     IfExpr "elif true:\r\n    return if true: 10 else: 20\r\n  else:\r\n    return 0":
      Lit "true"
      Group ":":
       ReturnStatement "return if true: 10 else: 20":
        IfExpr "if true: 10 else: 20":
         Lit "true"
         Group ":":
          Lit "10"
         Group ":":
          Lit "20"
      Group ":":
       ReturnStatement "return 0":
        Lit "0"
 Attribute "attr inline = always, call_conv = cold":
  AttributeAssign "inline = always":
   Ident "inline"
   Ident "always"
  AttributeAssign "call_conv = cold":
   Ident "call_conv"
   Ident "cold"
 Fun(None) "fun inline_fn -> u32:\r\n  return 10":
  FunHeader "fun inline_fn -> u32":
   Ident "inline_fn"
   Ident "u32"
  Group ":":
   ReturnStatement "return 10":
    Lit "10"
 Fun(None) "fun fib(v: i64) -> i64:\r\n  return if v == 0 | v == 1:\r\n    1\r\n  else:\r\n    fib(v - 1) + fib(v - 2)":
  FunHeader "fun fib(v: i64) -> i64":
   Ident "fib"
   FunArgument(false) "v: i64":
    Ident "v"
    Ident "i64"
   Ident "i64"
  Group ":":
   ReturnStatement "return if v == 0 | v == 1:\r\n    1\r\n  else:\r\n    fib(v - 1) + fib(v - 2)":
    IfExpr "if v == 0 | v == 1:\r\n    1\r\n  else:\r\n    fib(v - 1) + fib(v - 2)":
     BinaryOp "v == 0 | v == 1":
      Ident "|"
      BinaryOp "v == 0":
       Ident "=="
       Ident "v"
       Lit "0"
      BinaryOp "v == 1":
       Ident "=="
       Ident "v"
       Lit "1"
     Group ":":
      Lit "1"
     Group ":":
      BinaryOp "fib(v - 1) + fib(v - 2)":
       Ident "+"
       Call(false) "fib(v - 1)":
        Ident "fib"
        BinaryOp "v - 1":
         Ident "-"
         Ident "v"
         Lit "1"
       Call(false) "fib(v - 2)":
        Ident "fib"
        BinaryOp "v - 2":
         Ident "-"
         Ident "v"
         Lit "2"
 Fun(None) "fun fib_loop(v: i64) -> i64:\r\n  var a, b, c = 1\r\n  loop'a:\r\n    c = a + b\r\n    a = b\r\n    b = c\r\n    v = v - 1\r\n    if v == 0:\r\n      break'a\r\n  return c":
  FunHeader "fun fib_loop(v: i64) -> i64":
   Ident "fib_loop"
   FunArgument(false) "v: i64":
    Ident "v"
    Ident "i64"
   Ident "i64"
  Group ":":
   VarStatement(None, true) "var a, b, c = 1":
    VarAssign "a, b, c = 1":
     Group "a":
      Ident "a"
      Ident "b"
      Ident "c"
     None ""
     Group "=":
      Lit "1"
      Ident "a"
      Ident "a"
   Loop "loop'a:\r\n    c = a + b\r\n    a = b\r\n    b = c\r\n    v = v - 1\r\n    if v == 0:\r\n      break'a":
    Ident "'a"
    Group ":":
     BinaryOp "c = a + b":
      Ident "="
      Ident "c"
      BinaryOp "a + b":
       Ident "+"
       Ident "a"
       Ident "b"
     BinaryOp "a = b":
      Ident "="
      Ident "a"
      Ident "b"
     BinaryOp "b = c":
      Ident "="
      Ident "b"
      Ident "c"
     BinaryOp "v = v - 1":
      Ident "="
      Ident "v"
      BinaryOp "v - 1":
       Ident "-"
       Ident "v"
       Lit "1"
     IfExpr "if v == 0:\r\n      break'a":
      BinaryOp "v == 0":
       Ident "=="
       Ident "v"
       Lit "0"
      Group ":":
       Break "break'a":
        Ident "'a"
        None ""
      None ""
   ReturnStatement "return c":
    Ident "c"
 Fun(None) "fun unary_operators(a: i64) -> i64:\r\n  return -a + ~a + !a + ++a + --a":
  FunHeader "fun unary_operators(a: i64) -> i64":
   Ident "unary_operators"
   FunArgument(false) "a: i64":
    Ident "a"
    Ident "i64"
   Ident "i64"
  Group ":":
   ReturnStatement "return -a + ~a + !a + ++a + --a":
    BinaryOp "-a + ~a + !a + ++a + --a":
     Ident "+"
     BinaryOp "-a + ~a + !a + ++a":
      Ident "+"
      BinaryOp "-a + ~a + !a":
       Ident "+"
       BinaryOp "-a + ~a":
        Ident "+"
        UnaryOp "-a":
         Ident "-"
         Ident "a"
        UnaryOp "~a":
         Ident "~"
         Ident "a"
       UnaryOp "!a":
        Ident "!"
        Ident "a"
      UnaryOp "++a":
       Ident "++"
       Ident "a"
     UnaryOp "--a":
      Ident "--"
      Ident "a"
 StructDeclaration(None) "struct":
  Ident "Foo"
  Group ":":
   StructField(None, false) "a, b, c: int":
    Ident "a"
    Ident "b"
    Ident "c"
    Ident "int"
 StructDeclaration(None) "struct":
  Ident "Goo"
  Group ":":
   StructField(None, true) "foo: Foo":
    Ident "foo"
    Ident "Foo"
   StructField(None, false) "gva: int":
    Ident "gva"
    Ident "int"
 Fun(None) "fun strings -> i64:\r\n  var hello = \"hello\"\r\n  return 0":
  FunHeader "fun strings -> i64":
   Ident "strings"
   Ident "i64"
  Group ":":
   VarStatement(None, true) "var hello = \"hello\"":
    VarAssign "hello = \"hello\"":
     Group "hello":
      Ident "hello"
     None ""
     Group "=":
      Lit "\"hello\""
   ReturnStatement "return 0":
    Lit "0"
 Fun(None) "fun mutable_ref(a: &Foo):\r\n  a.a = 10\r\n  a.b = 20\r\n  a.c = 30":
  FunHeader "fun mutable_ref(a: &Foo)":
   Ident "mutable_ref"
   FunArgument(false) "a: &Foo":
    Ident "a"
    Ref "&Foo":
     Ident "Foo"
   None ""
  Group ":":
   BinaryOp "a.a = 10":
    Ident "="
    DotExpr "a.a":
     Ident "a"
     Ident "a"
    Lit "10"
   BinaryOp "a.b = 20":
    Ident "="
    DotExpr "a.b":
     Ident "a"
     Ident "b"
    Lit "20"
   BinaryOp "a.c = 30":
    Ident "="
    DotExpr "a.c":
     Ident "a"
     Ident "c"
    Lit "30"
 Fun(None) "fun some_string -> &u8:\r\n  \"\r\nhello there\r\n  \"":
  FunHeader "fun some_string -> &u8":
   Ident "some_string"
   Ref "&u8":
    Ident "u8"
  Group ":":
   Lit "\"\r\nhello there\r\n  \""

fun print(s: &Self, value: &u8)

  Inst1[Value(0), Value(1)]
    Value(2): int = Lit(Int(0, 0)) |0
    Value(3): int = VarDecl(Value(2)) |i = 0
    Jump(Inst(4), []) |loop:
      let value = *((value as int + i) as &u8)
      if value == 0u8:
        break
      i += 1

  Inst4[]
    Value(4): int = Cast(Value(1)) |value as int
    Value(5): int = Call(Fun(260), [Value(4), Value(3)]) |(value as int + i)
    Value(6): &u8 = Cast(Value(5)) |((value as int + i) as &u8)
    Value(7): u8 = Deref(Value(6), false) |*((value as int + i) as &u8)
    Value(8): u8 = VarDecl(Value(7)) |value = *((value as int + i) as &u8)
    Value(9): u8 = Lit(Uint(0, 8)) |0u8
    Value(10): bool = Call(Fun(306), [Value(8), Value(9)]) |value == 0u8
    JumpIfTrue(Value(10), Inst(15), []) |value == 0u8
    Jump(Inst(17), []) |

  Inst15[]
    Jump(Inst(5), []) |break

  Inst17[]
    Value(11): int = Lit(Int(1, 0)) |1
    Value(12): int = Call(Fun(260), [Value(3), Value(11)]) |i += 1
    Value(12): int = Assign(Value(3)) |i += 1
    Jump(Inst(4), []) |loop:
      let value = *((value as int + i) as &u8)
      if value == 0u8:
        break
      i += 1

  Inst5[]
    Call(Fun(473), [Value(0), Value(3)]) |s.reserve(i)
    Value(14): &Seq[u8] = Offset(Value(0)) |s.len
    Value(15): Seq[u8] = Deref(Value(14), false) |s.len
    Value(13): int = Offset(Value(15)) |s.len
    Value(16): &u8 = Call(Fun(474), [Value(0), Value(13)]) |s.get_unchecked(s.len)
    Call(Fun(442), [Value(16), Value(1), Value(3)]) |memcpy(s.get_unchecked(s.len), value, i)
    Value(18): &Seq[u8] = Offset(Value(0)) |s.len
    Value(19): Seq[u8] = Deref(Value(18), false) |s.len
    Value(17): int = Offset(Value(19)) |s.len
    Value(21): &Seq[u8] = Offset(Value(0)) |s.len
    Value(22): Seq[u8] = Deref(Value(21), false) |s.len
    Value(20): int = Offset(Value(22)) |s.len
    Value(23): int = Call(Fun(260), [Value(20), Value(3)]) |s.len += i
    Value(23): int = Assign(Value(17)) |s.len += i
    Return(None) |s.len += i


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 2460..2495 }, line_data: LineData { line: 128, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64) fast {
    sig0 = (i64, i64) -> i64 windows_fastcall
    sig1 = (i64, i64, i64) windows_fastcall
    fn0 = u0:26 sig0
    fn1 = u0:22 sig1

block0(v0: i64, v1: i64):
    v32 = iconst.i64 0
    v3 -> v32
    v2 = iconst.i64 0
    jump block1(v2)

block1(v4: i64):
    v10 -> v4
    v12 -> v4
    v29 -> v4
    v33 -> v4
    v5 = iadd.i64 v1, v4
    v6 = load.i8 v5
    v7 = iconst.i8 0
    v8 = icmp eq v6, v7
    brnz v8, block2
    jump block3

block2:
    jump block4

block3:
    v9 = iconst.i64 1
    v11 = iadd.i64 v10, v9
    jump block1(v11)

block4:
    jump block5(v0, v12)

block5(v13: i64, v14: i64):
    v15 = load.i64 v13+16
    v16 = icmp sgt v15, v14
    brnz v16, block6
    jump block7

block6:
    jump block8

block7:
    v17 = iconst.i64 1
    v18 = imul.i64 v14, v17
    v19 = load.i64 v13
    v20 = call fn0(v19, v18)
    store v20, v13
    store.i64 v14, v13+16
    jump block8

block8:
    v21 = load.i64 v0+8
    jump block9(v0, v21)

block9(v22: i64, v23: i64):
    v25 = iconst.i64 1
    v26 = imul v23, v25
    v27 = load.i64 v22
    v28 = iadd v27, v26
    jump block10(v28)

block10(v24: i64):
    call fn1(v24, v1, v29)
    v30 = load.i64 v0+8
    v31 = iadd v30, v29
    store v31, v0+8
    return
}

fun sizeof[T] -> int


fun print_int(s: &Self, value: int)

  Inst1[Value(0), Value(1)]
    Value(2): int = VarDecl(Value(1)) |value = value
    Jump(Inst(3), []) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())

  Inst3[]
    Value(3): int = Lit(Int(0, 0)) |0
    Value(4): bool = Call(Fun(310), [Value(2), Value(3)]) |value == 0
    JumpIfTrue(Value(4), Inst(9), []) |value == 0
    Jump(Inst(11), []) |

  Inst9[]
    Jump(Inst(4), []) |break

  Inst11[]
    Value(5): int = Lit(Int(10, 0)) |10
    Value(6): int = Call(Fun(300), [Value(2), Value(5)]) |value % 10
    Value(7): int = VarDecl(Value(6)) |digit = value % 10
    Value(8): int = Lit(Int(10, 0)) |10
    Value(9): int = Call(Fun(290), [Value(2), Value(8)]) |value / 10
    Value(9): int = Assign(Value(2)) |value = value / 10
    Value(10): u32 = Call(Fun(96), [Value(7)]) |digit.u32()
    Value(11): i32 = Lit(Char('0')) |'0'
    Value(12): u32 = Call(Fun(258), [Value(10), Value(11)]) |(
    Value(13): u8 = Call(Fun(63), [Value(12)]) |(digit.u32() + '0').u8()
    Call(Fun(476), [Value(0), Value(13)]) |s.push((digit.u32() + '0').u8())
    Jump(Inst(3), []) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())

  Inst4[]
    Return(None) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64) fast {
    gv0 = symbol colocated u1:1
    gv1 = symbol colocated u1:2
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 windows_fastcall
    sig2 = (i64) fast
    fn0 = colocated u0:19 sig0
    fn1 = u0:26 sig1
    fn2 = colocated u0:19 sig2

block0(v0: i64, v1: i64):
    v58 = iconst.i64 0
    v57 -> v58
    v54 = iconst.i64 0
    v2 -> v54
    jump block1(v1, v57)

block1(v4: i64, v56: i64):
    v7 -> v4
    v9 -> v56
    v3 = iconst.i64 0
    v5 = icmp eq v4, v3
    brnz v5, block2
    jump block3

block2:
    jump block4

block3:
    v6 = iconst.i64 10
    v8 = srem.i64 v7, v6
    v63 -> v8
    v66 -> v8
    v67 -> v8
    v61 -> v63
    v59 -> v61
    v10 = iconst.i64 10
    v11 = sdiv.i64 v7, v10
    v62 -> v11
    v64 -> v11
    v65 -> v11
    v60 -> v62
    v55 -> v60
    v12 = ireduce.i32 v8
    v13 = iconst.i32 48
    v14 = iadd v12, v13
    v15 = ireduce.i8 v14
    jump block5(v0, v15)

block5(v16: i64, v17: i8):
    v18 = global_value.i64 gv0
    call fn0(v18)
    v19 = iconst.i64 1
    v20 = load.i64 v16+8
    v21 = iadd v20, v19
    v22 = load.i64 v16+16
    v23 = icmp sgt v21, v22
    brnz v23, block6
    jump block7

block6:
    v24 = iconst.i64 2
    v25 = load.i64 v16+16
    v26 = imul v25, v24
    store v26, v16+16
    v27 = iconst.i64 1
    v28 = load.i64 v16+16
    v29 = imul v28, v27
    v30 = load.i64 v16
    v31 = call fn1(v30, v29)
    store v31, v16
    jump block7

block7:
    v32 = load.i64 v16+8
    jump block9(v16, v32)

block9(v33: i64, v34: i64):
    jump block11(v33, v34)

block11(v36: i64, v37: i64):
    jump block15(v36, v37)

block15(v38: i64, v39: i64):
    v41 = iconst.i64 0
    v42 = icmp sge v39, v41
    v43 = load.i64 v38+8
    v44 = icmp slt v39, v43
    v45 = band v42, v44
    jump block16(v45)

block16(v40: b1):
    brnz v40, block12
    jump block13

block12:
    v46 = global_value.i64 gv1
    call fn2(v46)
    jump block13

block13:
    jump block14

block14:
    jump block17(v33, v34)

block17(v47: i64, v48: i64):
    v50 = iconst.i64 1
    v51 = imul v48, v50
    v52 = load.i64 v47
    v53 = iadd v52, v51
    jump block18(v53)

block18(v49: i64):
    jump block10(v49)

block10(v35: i64):
    store.i8 v17, v35
    store.i64 v21, v16+8
    jump block8

block8:
    jump block1(v55, v59)

block4:
    return
}

fun pop_frame

  Inst1[]
    Value(0): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(2): &Seq[StackFrame] = Ref(Value(0)) |stacktrace.pop()
    Value(1): Option[StackFrame] = Call(Fun(480), [Value(2), Value(1)]) |stacktrace.pop()
    Return(None) |stacktrace.pop()


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3455..3485 }, line_data: LineData { line: 171, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4453..4479 }, line_data: LineData { line: 212, column: 3, source: Source(1) } }
function u0:0() fast {
    ss0 = explicit_slot 32
    ss1 = explicit_slot 24
    ss2 = explicit_slot 32
    ss3 = explicit_slot 32
    gv0 = symbol colocated u1:0

block0:
    v0 = global_value.i64 gv0
    v1 = stack_addr.i64 ss0
    jump block1(v0, v1)

block1(v2: i64, v3: i64):
    v5 = iconst.i64 0
    v6 = load.i64 v2+8
    v7 = icmp eq v6, v5
    brnz v7, block2
    jump block3

block2:
    v8 = iconst.i64 0
    store v8, v3
    store v8, v3+8
    store v8, v3+16
    store v8, v3+24
    jump block4(v3)

block3:
    v9 = iconst.i64 1
    v10 = load.i64 v2+8
    v11 = isub v10, v9
    jump block5(v2, v11)

block5(v12: i64, v13: i64):
    v15 = iconst.i64 24
    v16 = imul v13, v15
    v17 = load.i64 v12
    v18 = iadd v17, v16
    jump block6(v18)

block6(v14: i64):
    v19 = stack_addr.i64 ss1
    v20 = load.i64 v14
    store v20, v19
    v21 = load.i64 v14+8
    store v21, v19+8
    v22 = load.i64 v14+16
    store v22, v19+16
    v23 = iconst.i64 1
    v24 = load.i64 v2+8
    v25 = isub v24, v23
    store v25, v2+8
    v26 = stack_addr.i64 ss1
    v27 = stack_addr.i64 ss2
    jump block7(v26, v27)

block7(v28: i64, v29: i64):
    v31 = iconst.i64 0
    stack_store v31, ss3
    stack_store v31, ss3+8
    stack_store v31, ss3+16
    stack_store v31, ss3+24
    stack_store v28, ss3
    v32 = bconst.b1 true
    v33 = bint.i8 v32
    stack_store v33, ss3+24
    v34 = stack_addr.i64 ss3
    v35 = load.i64 v34
    store v35, v29
    v36 = load.i64 v34+8
    store v36, v29+8
    v37 = load.i64 v34+16
    store v37, v29+16
    v38 = load.i64 v34+24
    store v38, v29+24
    jump block8(v29)

block8(v30: i64):
    v39 = load.i64 v30
    store v39, v3
    v40 = load.i64 v30+8
    store v40, v3+8
    v41 = load.i64 v30+16
    store v41, v3+16
    v42 = load.i64 v30+24
    store v42, v3+24
    jump block4(v3)

block4(v4: i64):
    return
}

fun sizeof[T] -> int


fun push_frame(line, column: int, file: &u8)

  Inst1[Value(0), Value(1), Value(2)]
    Value(3): StackFrame = Zeroed |frame: StackFrame
    Value(4): StackFrame = VarDecl(Value(3)) |frame: StackFrame
    Value(5): int = Offset(Value(4)) |frame.line
    Value(0): int = Assign(Value(5)) |frame.line = line
    Value(6): int = Offset(Value(4)) |frame.column
    Value(1): int = Assign(Value(6)) |frame.column = column
    Value(7): &u8 = Offset(Value(4)) |frame.file
    Value(2): &u8 = Assign(Value(7)) |frame.file = file
    Value(8): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(9): &Seq[StackFrame] = Ref(Value(8)) |stacktrace.push(frame)
    Call(Fun(484), [Value(9), Value(4)]) |stacktrace.push(frame)
    Return(None) |stacktrace.push(frame)


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64, i64) fast {
    ss0 = explicit_slot 24
    gv0 = symbol colocated u1:0
    gv1 = symbol colocated u1:1
    gv2 = symbol colocated u1:2
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 windows_fastcall
    sig2 = (i64) fast
    fn0 = colocated u0:19 sig0
    fn1 = u0:26 sig1
    fn2 = colocated u0:19 sig2

block0(v0: i64, v1: i64, v2: i64):
    v3 = iconst.i64 0
    stack_store v3, ss0
    stack_store v3, ss0+8
    stack_store v3, ss0+16
    stack_store v0, ss0
    stack_store v1, ss0+8
    stack_store v2, ss0+16
    v4 = global_value.i64 gv0
    v5 = stack_addr.i64 ss0
    jump block1(v4, v5)

block1(v6: i64, v7: i64):
    v8 = global_value.i64 gv1
    call fn0(v8)
    v9 = iconst.i64 1
    v10 = load.i64 v6+8
    v11 = iadd v10, v9
    v12 = load.i64 v6+16
    v13 = icmp sgt v11, v12
    brnz v13, block2
    jump block3

block2:
    v14 = iconst.i64 2
    v15 = load.i64 v6+16
    v16 = imul v15, v14
    store v16, v6+16
    v17 = iconst.i64 24
    v18 = load.i64 v6+16
    v19 = imul v18, v17
    v20 = load.i64 v6
    v21 = call fn1(v20, v19)
    store v21, v6
    jump block3

block3:
    v22 = load.i64 v6+8
    jump block5(v6, v22)

block5(v23: i64, v24: i64):
    jump block7(v23, v24)

block7(v26: i64, v27: i64):
    jump block11(v26, v27)

block11(v28: i64, v29: i64):
    v31 = iconst.i64 0
    v32 = icmp sge v29, v31
    v33 = load.i64 v28+8
    v34 = icmp slt v29, v33
    v35 = band v32, v34
    jump block12(v35)

block12(v30: b1):
    brnz v30, block8
    jump block9

block8:
    v36 = global_value.i64 gv2
    call fn2(v36)
    jump block9

block9:
    jump block10

block10:
    jump block13(v23, v24)

block13(v37: i64, v38: i64):
    v40 = iconst.i64 24
    v41 = imul v38, v40
    v42 = load.i64 v37
    v43 = iadd v42, v41
    jump block14(v43)

block14(v39: i64):
    jump block6(v39)

block6(v25: i64):
    v44 = load.i64 v7
    store v44, v25
    v45 = load.i64 v7+8
    store v45, v25+8
    v46 = load.i64 v7+16
    store v46, v25+16
    store.i64 v11, v6+8
    jump block4

block4:
    return
}

fun panic(str: &u8)

  Inst1[Value(0)]
    Value(1): &u8 = Lit(String(Spam { source: Source(0), hash: ID(13499977805273881313), range: 135..159 })) |"panic: "
    Call(Fun(443), [Value(1)]) |print("panic: ")
    Call(Fun(443), [Value(0)]) |print(str)
    Value(2): &u8 = Lit(String(Spam { source: Source(0), hash: ID(10606491740656731085), range: 185..213 })) |"\n"
    Call(Fun(443), [Value(2)]) |print("\n")
    Value(3): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(4): int = Offset(Value(3)) |stacktrace.len
    Value(5): int = Lit(Int(0, 0)) |0
    Value(6): bool = Call(Fun(310), [Value(4), Value(5)]) |stacktrace.len == 0
    JumpIfTrue(Value(6), Inst(11), []) |stacktrace.len == 0
    Jump(Inst(13), []) |

  Inst11[]
    Value(7): &u8 = Lit(String(Spam { source: Source(0), hash: ID(9851784588597441741), range: 316..494 })) |"no stacktrace available, use '-trace' when building to generate stactrace\n"
    Call(Fun(443), [Value(7)]) |print("no stacktrace available, use '-trace' when building to generate stactrace\n")
    Value(8): int = Lit(Int(1, 0)) |1
    Call(Fun(444), [Value(8)]) |exit(1)
    Return(None) |return

  Inst13[]
    Value(9): Seq[u8] = Zeroed |buffer: Seq[u8]
    Value(10): Seq[u8] = VarDecl(Value(9)) |buffer: Seq[u8]
    Value(11): int = Zeroed |i: int
    Value(12): int = VarDecl(Value(11)) |i: int
    Jump(Inst(26), []) |loop:
    if i >= stacktrace.len:
      break
    
    var frame = stacktrace[i]
    
    buffer.print_int(frame.line)
    buffer.push(':'.u8())
    buffer.print_int(frame.column)
    buffer.push(' '.u8())
    buffer.print(frame.file)
    buffer.push('\n'.u8())

  Inst26[]
    Value(13): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(14): int = Offset(Value(13)) |stacktrace.len
    Value(15): bool = Call(Fun(330), [Value(12), Value(14)]) |i >= stacktrace.len
    JumpIfTrue(Value(15), Inst(33), []) |i >= stacktrace.len
    Jump(Inst(35), []) |

  Inst33[]
    Jump(Inst(27), []) |break

  Inst35[]
    Value(16): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(18): &Seq[StackFrame] = Ref(Value(16)) |stacktrace[i]
    Value(17): &StackFrame = Call(Fun(485), [Value(18), Value(12)]) |stacktrace[i]
    Value(19): StackFrame = Deref(Value(17), false) |stacktrace[i]
    Value(20): StackFrame = VarDecl(Value(19)) |frame = stacktrace[i]
    Value(21): int = Offset(Value(20)) |frame.line
    Value(22): &Seq[u8] = Ref(Value(10)) |buffer.print_int(frame.line)
    Call(Fun(452), [Value(22), Value(21)]) |buffer.print_int(frame.line)
    Value(23): i32 = Lit(Char(':')) |':'
    Value(24): u8 = Call(Fun(59), [Value(23)]) |':'.u8()
    Value(25): &Seq[u8] = Ref(Value(10)) |buffer.push(':'.u8())
    Call(Fun(476), [Value(25), Value(24)]) |buffer.push(':'.u8())
    Value(26): int = Offset(Value(20)) |frame.column
    Value(27): &Seq[u8] = Ref(Value(10)) |buffer.print_int(frame.column)
    Call(Fun(452), [Value(27), Value(26)]) |buffer.print_int(frame.column)
    Value(28): i32 = Lit(Char(' ')) |' '
    Value(29): u8 = Call(Fun(59), [Value(28)]) |' '.u8()
    Value(30): &Seq[u8] = Ref(Value(10)) |buffer.push(' '.u8())
    Call(Fun(476), [Value(30), Value(29)]) |buffer.push(' '.u8())
    Value(31): &u8 = Offset(Value(20)) |frame.file
    Value(32): &Seq[u8] = Ref(Value(10)) |buffer.print(frame.file)
    Call(Fun(453), [Value(32), Value(31)]) |buffer.print(frame.file)
    Value(33): i32 = Lit(Char('\n')) |'\n'
    Value(34): u8 = Call(Fun(59), [Value(33)]) |'\n'.u8()
    Value(35): &Seq[u8] = Ref(Value(10)) |buffer.push('\n'.u8())
    Call(Fun(476), [Value(35), Value(34)]) |buffer.push('\n'.u8())
    Jump(Inst(26), []) |loop:
    if i >= stacktrace.len:
      break
    
    var frame = stacktrace[i]
    
    buffer.print_int(frame.line)
    buffer.push(':'.u8())
    buffer.print_int(frame.column)
    buffer.push(' '.u8())
    buffer.print(frame.file)
    buffer.push('\n'.u8())

  Inst27[]
    Value(36): i32 = Lit(Char('\u{0}')) |'\x00'
    Value(37): u8 = Call(Fun(59), [Value(36)]) |'\x00'.u8()
    Value(38): &Seq[u8] = Ref(Value(10)) |buffer.push('\x00'.u8())
    Call(Fun(476), [Value(38), Value(37)]) |buffer.push('\x00'.u8())
    Value(39): &u8 = Offset(Value(10)) |buffer.data
    Call(Fun(443), [Value(39)]) |print(buffer.data)
    Value(40): int = Lit(Int(1, 0)) |1
    Call(Fun(444), [Value(40)]) |exit(1)
    Return(None) |exit(1)


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64) fast {
    ss0 = explicit_slot 24
    ss1 = explicit_slot 24
    gv0 = symbol colocated u1:3
    gv1 = symbol colocated u1:4
    gv2 = symbol colocated u1:0
    gv3 = symbol colocated u1:5
    gv4 = symbol colocated u1:0
    gv5 = symbol colocated u1:0
    gv6 = symbol colocated u1:2
    gv7 = symbol colocated u1:1
    gv8 = symbol colocated u1:2
    gv9 = symbol colocated u1:1
    gv10 = symbol colocated u1:2
    gv11 = symbol colocated u1:1
    gv12 = symbol colocated u1:2
    gv13 = symbol colocated u1:1
    gv14 = symbol colocated u1:2
    sig0 = (i64) windows_fastcall
    sig1 = (i64) windows_fastcall
    sig2 = (i64) windows_fastcall
    sig3 = (i64) windows_fastcall
    sig4 = (i64) windows_fastcall
    sig5 = (i64) fast
    sig6 = (i64, i64) fast
    sig7 = (i64) fast
    sig8 = (i64, i64) -> i64 windows_fastcall
    sig9 = (i64) fast
    sig10 = (i64, i64) fast
    sig11 = (i64) fast
    sig12 = (i64, i64) -> i64 windows_fastcall
    sig13 = (i64) fast
    sig14 = (i64, i64) fast
    sig15 = (i64) fast
    sig16 = (i64, i64) -> i64 windows_fastcall
    sig17 = (i64) fast
    sig18 = (i64) fast
    sig19 = (i64, i64) -> i64 windows_fastcall
    sig20 = (i64) fast
    sig21 = (i64) windows_fastcall
    sig22 = (i64) windows_fastcall
    fn0 = u0:21 sig0
    fn1 = u0:21 sig1
    fn2 = u0:21 sig2
    fn3 = u0:21 sig3
    fn4 = u0:20 sig4
    fn5 = colocated u0:19 sig5
    fn6 = colocated u0:4 sig6
    fn7 = colocated u0:19 sig7
    fn8 = u0:26 sig8
    fn9 = colocated u0:19 sig9
    fn10 = colocated u0:4 sig10
    fn11 = colocated u0:19 sig11
    fn12 = u0:26 sig12
    fn13 = colocated u0:19 sig13
    fn14 = colocated u0:0 sig14
    fn15 = colocated u0:19 sig15
    fn16 = u0:26 sig16
    fn17 = colocated u0:19 sig17
    fn18 = colocated u0:19 sig18
    fn19 = u0:26 sig19
    fn20 = colocated u0:19 sig20
    fn21 = u0:21 sig21
    fn22 = u0:20 sig22

block0(v0: i64):
    v216 = iconst.i64 0
    v11 -> v216
    v215 -> v216
    v1 = global_value.i64 gv0
    call fn0(v1)
    call fn1(v0)
    v2 = global_value.i64 gv1
    call fn2(v2)
    v3 = global_value.i64 gv2
    v4 = iconst.i64 0
    v5 = load.i64 v3+8
    v6 = icmp eq v5, v4
    brnz v6, block1
    jump block2

block1:
    v7 = global_value.i64 gv3
    call fn3(v7)
    v8 = iconst.i64 1
    call fn4(v8)
    return

block2:
    v9 = iconst.i64 0
    stack_store v9, ss0
    stack_store v9, ss0+8
    stack_store v9, ss0+16
    v10 = iconst.i64 0
    jump block3(v10)

block3(v13: i64):
    v17 -> v13
    v219 -> v13
    v220 -> v13
    v221 -> v13
    v222 -> v13
    v223 -> v13
    v224 -> v13
    v225 -> v13
    v226 -> v13
    v218 -> v219
    v217 -> v218
    v12 = global_value.i64 gv4
    v14 = load.i64 v12+8
    v15 = icmp sge v13, v14
    brnz v15, block4
    jump block5

block4:
    jump block6

block5:
    v16 = global_value.i64 gv5
    jump block7(v16, v17)

block7(v18: i64, v19: i64):
    jump block9(v18, v19)

block9(v21: i64, v22: i64):
    jump block13(v21, v22)

block13(v23: i64, v24: i64):
    v26 = iconst.i64 0
    v27 = icmp sge v24, v26
    v28 = load.i64 v23+8
    v29 = icmp slt v24, v28
    v30 = band v27, v29
    jump block14(v30)

block14(v25: b1):
    brnz v25, block10
    jump block11

block10:
    v31 = global_value.i64 gv6
    call fn5(v31)
    jump block11

block11:
    jump block12

block12:
    jump block15(v18, v19)

block15(v32: i64, v33: i64):
    v35 = iconst.i64 24
    v36 = imul v33, v35
    v37 = load.i64 v32
    v38 = iadd v37, v36
    jump block16(v38)

block16(v34: i64):
    jump block8(v34)

block8(v20: i64):
    v39 = stack_addr.i64 ss1
    v40 = load.i64 v20
    store v40, v39
    v41 = load.i64 v20+8
    store v41, v39+8
    v42 = load.i64 v20+16
    store v42, v39+16
    v43 = stack_addr.i64 ss0
    v44 = stack_load.i64 ss1
    call fn6(v43, v44)
    v45 = iconst.i32 58
    v46 = ireduce.i8 v45
    v47 = stack_addr.i64 ss0
    jump block17(v47, v46)

block17(v48: i64, v49: i8):
    v50 = global_value.i64 gv7
    call fn7(v50)
    v51 = iconst.i64 1
    v52 = load.i64 v48+8
    v53 = iadd v52, v51
    v54 = load.i64 v48+16
    v55 = icmp sgt v53, v54
    brnz v55, block18
    jump block19

block18:
    v56 = iconst.i64 2
    v57 = load.i64 v48+16
    v58 = imul v57, v56
    store v58, v48+16
    v59 = iconst.i64 1
    v60 = load.i64 v48+16
    v61 = imul v60, v59
    v62 = load.i64 v48
    v63 = call fn8(v62, v61)
    store v63, v48
    jump block19

block19:
    v64 = load.i64 v48+8
    jump block21(v48, v64)

block21(v65: i64, v66: i64):
    jump block23(v65, v66)

block23(v68: i64, v69: i64):
    jump block27(v68, v69)

block27(v70: i64, v71: i64):
    v73 = iconst.i64 0
    v74 = icmp sge v71, v73
    v75 = load.i64 v70+8
    v76 = icmp slt v71, v75
    v77 = band v74, v76
    jump block28(v77)

block28(v72: b1):
    brnz v72, block24
    jump block25

block24:
    v78 = global_value.i64 gv8
    call fn9(v78)
    jump block25

block25:
    jump block26

block26:
    jump block29(v65, v66)

block29(v79: i64, v80: i64):
    v82 = iconst.i64 1
    v83 = imul v80, v82
    v84 = load.i64 v79
    v85 = iadd v84, v83
    jump block30(v85)

block30(v81: i64):
    jump block22(v81)

block22(v67: i64):
    store.i8 v49, v67
    store.i64 v53, v48+8
    jump block20

block20:
    v86 = stack_addr.i64 ss0
    v87 = stack_load.i64 ss1+8
    call fn10(v86, v87)
    v88 = iconst.i32 32
    v89 = ireduce.i8 v88
    v90 = stack_addr.i64 ss0
    jump block31(v90, v89)

block31(v91: i64, v92: i8):
    v93 = global_value.i64 gv9
    call fn11(v93)
    v94 = iconst.i64 1
    v95 = load.i64 v91+8
    v96 = iadd v95, v94
    v97 = load.i64 v91+16
    v98 = icmp sgt v96, v97
    brnz v98, block32
    jump block33

block32:
    v99 = iconst.i64 2
    v100 = load.i64 v91+16
    v101 = imul v100, v99
    store v101, v91+16
    v102 = iconst.i64 1
    v103 = load.i64 v91+16
    v104 = imul v103, v102
    v105 = load.i64 v91
    v106 = call fn12(v105, v104)
    store v106, v91
    jump block33

block33:
    v107 = load.i64 v91+8
    jump block35(v91, v107)

block35(v108: i64, v109: i64):
    jump block37(v108, v109)

block37(v111: i64, v112: i64):
    jump block41(v111, v112)

block41(v113: i64, v114: i64):
    v116 = iconst.i64 0
    v117 = icmp sge v114, v116
    v118 = load.i64 v113+8
    v119 = icmp slt v114, v118
    v120 = band v117, v119
    jump block42(v120)

block42(v115: b1):
    brnz v115, block38
    jump block39

block38:
    v121 = global_value.i64 gv10
    call fn13(v121)
    jump block39

block39:
    jump block40

block40:
    jump block43(v108, v109)

block43(v122: i64, v123: i64):
    v125 = iconst.i64 1
    v126 = imul v123, v125
    v127 = load.i64 v122
    v128 = iadd v127, v126
    jump block44(v128)

block44(v124: i64):
    jump block36(v124)

block36(v110: i64):
    store.i8 v92, v110
    store.i64 v96, v91+8
    jump block34

block34:
    v129 = stack_addr.i64 ss0
    v130 = stack_load.i64 ss1+16
    call fn14(v129, v130)
    v131 = iconst.i32 10
    v132 = ireduce.i8 v131
    v133 = stack_addr.i64 ss0
    jump block45(v133, v132)

block45(v134: i64, v135: i8):
    v136 = global_value.i64 gv11
    call fn15(v136)
    v137 = iconst.i64 1
    v138 = load.i64 v134+8
    v139 = iadd v138, v137
    v140 = load.i64 v134+16
    v141 = icmp sgt v139, v140
    brnz v141, block46
    jump block47

block46:
    v142 = iconst.i64 2
    v143 = load.i64 v134+16
    v144 = imul v143, v142
    store v144, v134+16
    v145 = iconst.i64 1
    v146 = load.i64 v134+16
    v147 = imul v146, v145
    v148 = load.i64 v134
    v149 = call fn16(v148, v147)
    store v149, v134
    jump block47

block47:
    v150 = load.i64 v134+8
    jump block49(v134, v150)

block49(v151: i64, v152: i64):
    jump block51(v151, v152)

block51(v154: i64, v155: i64):
    jump block55(v154, v155)

block55(v156: i64, v157: i64):
    v159 = iconst.i64 0
    v160 = icmp sge v157, v159
    v161 = load.i64 v156+8
    v162 = icmp slt v157, v161
    v163 = band v160, v162
    jump block56(v163)

block56(v158: b1):
    brnz v158, block52
    jump block53

block52:
    v164 = global_value.i64 gv12
    call fn17(v164)
    jump block53

block53:
    jump block54

block54:
    jump block57(v151, v152)

block57(v165: i64, v166: i64):
    v168 = iconst.i64 1
    v169 = imul v166, v168
    v170 = load.i64 v165
    v171 = iadd v170, v169
    jump block58(v171)

block58(v167: i64):
    jump block50(v167)

block50(v153: i64):
    store.i8 v135, v153
    store.i64 v139, v134+8
    jump block48

block48:
    jump block3(v217)

block6:
    v172 = iconst.i32 0
    v173 = ireduce.i8 v172
    v174 = stack_addr.i64 ss0
    jump block59(v174, v173)

block59(v175: i64, v176: i8):
    v177 = global_value.i64 gv13
    call fn18(v177)
    v178 = iconst.i64 1
    v179 = load.i64 v175+8
    v180 = iadd v179, v178
    v181 = load.i64 v175+16
    v182 = icmp sgt v180, v181
    brnz v182, block60
    jump block61

block60:
    v183 = iconst.i64 2
    v184 = load.i64 v175+16
    v185 = imul v184, v183
    store v185, v175+16
    v186 = iconst.i64 1
    v187 = load.i64 v175+16
    v188 = imul v187, v186
    v189 = load.i64 v175
    v190 = call fn19(v189, v188)
    store v190, v175
    jump block61

block61:
    v191 = load.i64 v175+8
    jump block63(v175, v191)

block63(v192: i64, v193: i64):
    jump block65(v192, v193)

block65(v195: i64, v196: i64):
    jump block69(v195, v196)

block69(v197: i64, v198: i64):
    v200 = iconst.i64 0
    v201 = icmp sge v198, v200
    v202 = load.i64 v197+8
    v203 = icmp slt v198, v202
    v204 = band v201, v203
    jump block70(v204)

block70(v199: b1):
    brnz v199, block66
    jump block67

block66:
    v205 = global_value.i64 gv14
    call fn20(v205)
    jump block67

block67:
    jump block68

block68:
    jump block71(v192, v193)

block71(v206: i64, v207: i64):
    v209 = iconst.i64 1
    v210 = imul v207, v209
    v211 = load.i64 v206
    v212 = iadd v211, v210
    jump block72(v212)

block72(v208: i64):
    jump block64(v208)

block64(v194: i64):
    store.i8 v176, v194
    store.i64 v180, v175+8
    jump block62

block62:
    v213 = stack_load.i64 ss0
    call fn21(v213)
    v214 = iconst.i64 1
    call fn22(v214)
    return
}

fun exit(code: int)


fun print(str: &u8)


fun memcpy(dest: &u8, src: &u8, size: int)


fun memmove(dest: &u8, src: &u8, size: int)


fun memset(ptr: &u8, value: u8, size: int)


fun free(ptr: &u8)


fun realloc(ptr: &u8, size: int) -> &u8


fun alloc(size: int) -> &u8


fun main -> int

  Inst1[]
    Value(0): int = Lit(Int(0, 0)) |0
    Return(Some(Value(0))) |return 0


function u0:0() -> i64 fast {
block0:
    v0 = iconst.i64 0
    return v0
}



  Inst1[Value(0), Value(1)]
    Value(2): int = Zeroed |
    Value(3): int = VarDecl(Value(2)) |
    Value(4): int = Call(Fun(488), []) |entry
    Value(4): int = Assign(Value(3)) |entry
    Return(Some(Value(3))) |


function u0:0(i64, i64) -> i64 fast {
    sig0 = () -> i64 fast
    fn0 = colocated u0:28 sig0

block0(v0: i64, v1: i64):
    v5 = iconst.i64 0
    v3 -> v5
    v2 = iconst.i64 0
    v4 = call fn0()
    return v4
}


fun print(s: &Self, value: &u8)

  Inst1[Value(0), Value(1)]
    Value(2): int = Lit(Int(0, 0)) |0
    Value(3): int = VarDecl(Value(2)) |i = 0
    Jump(Inst(4), []) |loop:
      let value = *((value as int + i) as &u8)
      if value == 0u8:
        break
      i += 1

  Inst4[]
    Value(4): int = Cast(Value(1)) |value as int
    Value(5): int = Call(Fun(260), [Value(4), Value(3)]) |(value as int + i)
    Value(6): &u8 = Cast(Value(5)) |((value as int + i) as &u8)
    Value(7): u8 = Deref(Value(6), false) |*((value as int + i) as &u8)
    Value(8): u8 = VarDecl(Value(7)) |value = *((value as int + i) as &u8)
    Value(9): u8 = Lit(Uint(0, 8)) |0u8
    Value(10): bool = Call(Fun(306), [Value(8), Value(9)]) |value == 0u8
    JumpIfTrue(Value(10), Inst(15), []) |value == 0u8
    Jump(Inst(17), []) |

  Inst15[]
    Jump(Inst(5), []) |break

  Inst17[]
    Value(11): int = Lit(Int(1, 0)) |1
    Value(12): int = Call(Fun(260), [Value(3), Value(11)]) |i += 1
    Value(12): int = Assign(Value(3)) |i += 1
    Jump(Inst(4), []) |loop:
      let value = *((value as int + i) as &u8)
      if value == 0u8:
        break
      i += 1

  Inst5[]
    Call(Fun(473), [Value(0), Value(3)]) |s.reserve(i)
    Value(14): &Seq[u8] = Offset(Value(0)) |s.len
    Value(15): Seq[u8] = Deref(Value(14), false) |s.len
    Value(13): int = Offset(Value(15)) |s.len
    Value(16): &u8 = Call(Fun(474), [Value(0), Value(13)]) |s.get_unchecked(s.len)
    Call(Fun(442), [Value(16), Value(1), Value(3)]) |memcpy(s.get_unchecked(s.len), value, i)
    Value(18): &Seq[u8] = Offset(Value(0)) |s.len
    Value(19): Seq[u8] = Deref(Value(18), false) |s.len
    Value(17): int = Offset(Value(19)) |s.len
    Value(21): &Seq[u8] = Offset(Value(0)) |s.len
    Value(22): Seq[u8] = Deref(Value(21), false) |s.len
    Value(20): int = Offset(Value(22)) |s.len
    Value(23): int = Call(Fun(260), [Value(20), Value(3)]) |s.len += i
    Value(23): int = Assign(Value(17)) |s.len += i
    Return(None) |s.len += i


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 2460..2495 }, line_data: LineData { line: 128, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64) fast {
    sig0 = (i64, i64) -> i64 windows_fastcall
    sig1 = (i64, i64, i64) windows_fastcall
    fn0 = u0:26 sig0
    fn1 = u0:22 sig1

block0(v0: i64, v1: i64):
    v32 = iconst.i64 0
    v3 -> v32
    v2 = iconst.i64 0
    jump block1(v2)

block1(v4: i64):
    v10 -> v4
    v12 -> v4
    v29 -> v4
    v33 -> v4
    v5 = iadd.i64 v1, v4
    v6 = load.i8 v5
    v7 = iconst.i8 0
    v8 = icmp eq v6, v7
    brnz v8, block2
    jump block3

block2:
    jump block4

block3:
    v9 = iconst.i64 1
    v11 = iadd.i64 v10, v9
    jump block1(v11)

block4:
    jump block5(v0, v12)

block5(v13: i64, v14: i64):
    v15 = load.i64 v13+16
    v16 = icmp sgt v15, v14
    brnz v16, block6
    jump block7

block6:
    jump block8

block7:
    v17 = iconst.i64 1
    v18 = imul.i64 v14, v17
    v19 = load.i64 v13
    v20 = call fn0(v19, v18)
    store v20, v13
    store.i64 v14, v13+16
    jump block8

block8:
    v21 = load.i64 v0+8
    jump block9(v0, v21)

block9(v22: i64, v23: i64):
    v25 = iconst.i64 1
    v26 = imul v23, v25
    v27 = load.i64 v22
    v28 = iadd v27, v26
    jump block10(v28)

block10(v24: i64):
    call fn1(v24, v1, v29)
    v30 = load.i64 v0+8
    v31 = iadd v30, v29
    store v31, v0+8
    return
}

fun sizeof[T] -> int


fun print_int(s: &Self, value: int)

  Inst1[Value(0), Value(1)]
    Value(2): int = VarDecl(Value(1)) |value = value
    Jump(Inst(3), []) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())

  Inst3[]
    Value(3): int = Lit(Int(0, 0)) |0
    Value(4): bool = Call(Fun(310), [Value(2), Value(3)]) |value == 0
    JumpIfTrue(Value(4), Inst(9), []) |value == 0
    Jump(Inst(11), []) |

  Inst9[]
    Jump(Inst(4), []) |break

  Inst11[]
    Value(5): int = Lit(Int(10, 0)) |10
    Value(6): int = Call(Fun(300), [Value(2), Value(5)]) |value % 10
    Value(7): int = VarDecl(Value(6)) |digit = value % 10
    Value(8): int = Lit(Int(10, 0)) |10
    Value(9): int = Call(Fun(290), [Value(2), Value(8)]) |value / 10
    Value(9): int = Assign(Value(2)) |value = value / 10
    Value(10): u32 = Call(Fun(96), [Value(7)]) |digit.u32()
    Value(11): i32 = Lit(Char('0')) |'0'
    Value(12): u32 = Call(Fun(258), [Value(10), Value(11)]) |(
    Value(13): u8 = Call(Fun(63), [Value(12)]) |(digit.u32() + '0').u8()
    Call(Fun(476), [Value(0), Value(13)]) |s.push((digit.u32() + '0').u8())
    Jump(Inst(3), []) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())

  Inst4[]
    Return(None) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64) fast {
    gv0 = symbol colocated u1:1
    gv1 = symbol colocated u1:2
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 windows_fastcall
    sig2 = (i64) fast
    fn0 = colocated u0:19 sig0
    fn1 = u0:26 sig1
    fn2 = colocated u0:19 sig2

block0(v0: i64, v1: i64):
    v58 = iconst.i64 0
    v57 -> v58
    v54 = iconst.i64 0
    v2 -> v54
    jump block1(v1, v57)

block1(v4: i64, v56: i64):
    v7 -> v4
    v9 -> v56
    v3 = iconst.i64 0
    v5 = icmp eq v4, v3
    brnz v5, block2
    jump block3

block2:
    jump block4

block3:
    v6 = iconst.i64 10
    v8 = srem.i64 v7, v6
    v63 -> v8
    v66 -> v8
    v67 -> v8
    v61 -> v63
    v59 -> v61
    v10 = iconst.i64 10
    v11 = sdiv.i64 v7, v10
    v62 -> v11
    v64 -> v11
    v65 -> v11
    v60 -> v62
    v55 -> v60
    v12 = ireduce.i32 v8
    v13 = iconst.i32 48
    v14 = iadd v12, v13
    v15 = ireduce.i8 v14
    jump block5(v0, v15)

block5(v16: i64, v17: i8):
    v18 = global_value.i64 gv0
    call fn0(v18)
    v19 = iconst.i64 1
    v20 = load.i64 v16+8
    v21 = iadd v20, v19
    v22 = load.i64 v16+16
    v23 = icmp sgt v21, v22
    brnz v23, block6
    jump block7

block6:
    v24 = iconst.i64 2
    v25 = load.i64 v16+16
    v26 = imul v25, v24
    store v26, v16+16
    v27 = iconst.i64 1
    v28 = load.i64 v16+16
    v29 = imul v28, v27
    v30 = load.i64 v16
    v31 = call fn1(v30, v29)
    store v31, v16
    jump block7

block7:
    v32 = load.i64 v16+8
    jump block9(v16, v32)

block9(v33: i64, v34: i64):
    jump block11(v33, v34)

block11(v36: i64, v37: i64):
    jump block15(v36, v37)

block15(v38: i64, v39: i64):
    v41 = iconst.i64 0
    v42 = icmp sge v39, v41
    v43 = load.i64 v38+8
    v44 = icmp slt v39, v43
    v45 = band v42, v44
    jump block16(v45)

block16(v40: b1):
    brnz v40, block12
    jump block13

block12:
    v46 = global_value.i64 gv1
    call fn2(v46)
    jump block13

block13:
    jump block14

block14:
    jump block17(v33, v34)

block17(v47: i64, v48: i64):
    v50 = iconst.i64 1
    v51 = imul v48, v50
    v52 = load.i64 v47
    v53 = iadd v52, v51
    jump block18(v53)

block18(v49: i64):
    jump block10(v49)

block10(v35: i64):
    store.i8 v17, v35
    store.i64 v21, v16+8
    jump block8

block8:
    jump block1(v55, v59)

block4:
    return
}

fun pop_frame

  Inst1[]
    Value(0): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(2): &Seq[StackFrame] = Ref(Value(0)) |stacktrace.pop()
    Value(1): Option[StackFrame] = Call(Fun(480), [Value(2), Value(1)]) |stacktrace.pop()
    Return(None) |stacktrace.pop()


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3455..3485 }, line_data: LineData { line: 171, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4453..4479 }, line_data: LineData { line: 212, column: 3, source: Source(1) } }
function u0:0() fast {
    ss0 = explicit_slot 32
    ss1 = explicit_slot 24
    ss2 = explicit_slot 32
    ss3 = explicit_slot 32
    gv0 = symbol colocated u1:0

block0:
    v0 = global_value.i64 gv0
    v1 = stack_addr.i64 ss0
    jump block1(v0, v1)

block1(v2: i64, v3: i64):
    v5 = iconst.i64 0
    v6 = load.i64 v2+8
    v7 = icmp eq v6, v5
    brnz v7, block2
    jump block3

block2:
    v8 = iconst.i64 0
    store v8, v3
    store v8, v3+8
    store v8, v3+16
    store v8, v3+24
    jump block4(v3)

block3:
    v9 = iconst.i64 1
    v10 = load.i64 v2+8
    v11 = isub v10, v9
    jump block5(v2, v11)

block5(v12: i64, v13: i64):
    v15 = iconst.i64 24
    v16 = imul v13, v15
    v17 = load.i64 v12
    v18 = iadd v17, v16
    jump block6(v18)

block6(v14: i64):
    v19 = stack_addr.i64 ss1
    v20 = load.i64 v14
    store v20, v19
    v21 = load.i64 v14+8
    store v21, v19+8
    v22 = load.i64 v14+16
    store v22, v19+16
    v23 = iconst.i64 1
    v24 = load.i64 v2+8
    v25 = isub v24, v23
    store v25, v2+8
    v26 = stack_addr.i64 ss1
    v27 = stack_addr.i64 ss2
    jump block7(v26, v27)

block7(v28: i64, v29: i64):
    v31 = iconst.i64 0
    stack_store v31, ss3
    stack_store v31, ss3+8
    stack_store v31, ss3+16
    stack_store v31, ss3+24
    stack_store v28, ss3
    v32 = bconst.b1 true
    v33 = bint.i8 v32
    stack_store v33, ss3+24
    v34 = stack_addr.i64 ss3
    v35 = load.i64 v34
    store v35, v29
    v36 = load.i64 v34+8
    store v36, v29+8
    v37 = load.i64 v34+16
    store v37, v29+16
    v38 = load.i64 v34+24
    store v38, v29+24
    jump block8(v29)

block8(v30: i64):
    v39 = load.i64 v30
    store v39, v3
    v40 = load.i64 v30+8
    store v40, v3+8
    v41 = load.i64 v30+16
    store v41, v3+16
    v42 = load.i64 v30+24
    store v42, v3+24
    jump block4(v3)

block4(v4: i64):
    return
}

fun sizeof[T] -> int


fun push_frame(line, column: int, file: &u8)

  Inst1[Value(0), Value(1), Value(2)]
    Value(3): StackFrame = Zeroed |frame: StackFrame
    Value(4): StackFrame = VarDecl(Value(3)) |frame: StackFrame
    Value(5): int = Offset(Value(4)) |frame.line
    Value(0): int = Assign(Value(5)) |frame.line = line
    Value(6): int = Offset(Value(4)) |frame.column
    Value(1): int = Assign(Value(6)) |frame.column = column
    Value(7): &u8 = Offset(Value(4)) |frame.file
    Value(2): &u8 = Assign(Value(7)) |frame.file = file
    Value(8): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(9): &Seq[StackFrame] = Ref(Value(8)) |stacktrace.push(frame)
    Call(Fun(484), [Value(9), Value(4)]) |stacktrace.push(frame)
    Return(None) |stacktrace.push(frame)


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64, i64) fast {
    ss0 = explicit_slot 24
    gv0 = symbol colocated u1:0
    gv1 = symbol colocated u1:1
    gv2 = symbol colocated u1:2
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 windows_fastcall
    sig2 = (i64) fast
    fn0 = colocated u0:19 sig0
    fn1 = u0:26 sig1
    fn2 = colocated u0:19 sig2

block0(v0: i64, v1: i64, v2: i64):
    v3 = iconst.i64 0
    stack_store v3, ss0
    stack_store v3, ss0+8
    stack_store v3, ss0+16
    stack_store v0, ss0
    stack_store v1, ss0+8
    stack_store v2, ss0+16
    v4 = global_value.i64 gv0
    v5 = stack_addr.i64 ss0
    jump block1(v4, v5)

block1(v6: i64, v7: i64):
    v8 = global_value.i64 gv1
    call fn0(v8)
    v9 = iconst.i64 1
    v10 = load.i64 v6+8
    v11 = iadd v10, v9
    v12 = load.i64 v6+16
    v13 = icmp sgt v11, v12
    brnz v13, block2
    jump block3

block2:
    v14 = iconst.i64 2
    v15 = load.i64 v6+16
    v16 = imul v15, v14
    store v16, v6+16
    v17 = iconst.i64 24
    v18 = load.i64 v6+16
    v19 = imul v18, v17
    v20 = load.i64 v6
    v21 = call fn1(v20, v19)
    store v21, v6
    jump block3

block3:
    v22 = load.i64 v6+8
    jump block5(v6, v22)

block5(v23: i64, v24: i64):
    jump block7(v23, v24)

block7(v26: i64, v27: i64):
    jump block11(v26, v27)

block11(v28: i64, v29: i64):
    v31 = iconst.i64 0
    v32 = icmp sge v29, v31
    v33 = load.i64 v28+8
    v34 = icmp slt v29, v33
    v35 = band v32, v34
    jump block12(v35)

block12(v30: b1):
    brnz v30, block8
    jump block9

block8:
    v36 = global_value.i64 gv2
    call fn2(v36)
    jump block9

block9:
    jump block10

block10:
    jump block13(v23, v24)

block13(v37: i64, v38: i64):
    v40 = iconst.i64 24
    v41 = imul v38, v40
    v42 = load.i64 v37
    v43 = iadd v42, v41
    jump block14(v43)

block14(v39: i64):
    jump block6(v39)

block6(v25: i64):
    v44 = load.i64 v7
    store v44, v25
    v45 = load.i64 v7+8
    store v45, v25+8
    v46 = load.i64 v7+16
    store v46, v25+16
    store.i64 v11, v6+8
    jump block4

block4:
    return
}

fun panic(str: &u8)

  Inst1[Value(0)]
    Value(1): &u8 = Lit(String(Spam { source: Source(0), hash: ID(13499977805273881313), range: 135..159 })) |"panic: "
    Call(Fun(443), [Value(1)]) |print("panic: ")
    Call(Fun(443), [Value(0)]) |print(str)
    Value(2): &u8 = Lit(String(Spam { source: Source(0), hash: ID(10606491740656731085), range: 185..213 })) |"\n"
    Call(Fun(443), [Value(2)]) |print("\n")
    Value(3): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(4): int = Offset(Value(3)) |stacktrace.len
    Value(5): int = Lit(Int(0, 0)) |0
    Value(6): bool = Call(Fun(310), [Value(4), Value(5)]) |stacktrace.len == 0
    JumpIfTrue(Value(6), Inst(11), []) |stacktrace.len == 0
    Jump(Inst(13), []) |

  Inst11[]
    Value(7): &u8 = Lit(String(Spam { source: Source(0), hash: ID(9851784588597441741), range: 316..494 })) |"no stacktrace available, use '-trace' when building to generate stactrace\n"
    Call(Fun(443), [Value(7)]) |print("no stacktrace available, use '-trace' when building to generate stactrace\n")
    Value(8): int = Lit(Int(1, 0)) |1
    Call(Fun(444), [Value(8)]) |exit(1)
    Return(None) |return

  Inst13[]
    Value(9): Seq[u8] = Zeroed |buffer: Seq[u8]
    Value(10): Seq[u8] = VarDecl(Value(9)) |buffer: Seq[u8]
    Value(11): int = Zeroed |i: int
    Value(12): int = VarDecl(Value(11)) |i: int
    Jump(Inst(26), []) |loop:
    if i >= stacktrace.len:
      break
    
    var frame = stacktrace[i]
    
    buffer.print_int(frame.line)
    buffer.push(':'.u8())
    buffer.print_int(frame.column)
    buffer.push(' '.u8())
    buffer.print(frame.file)
    buffer.push('\n'.u8())

  Inst26[]
    Value(13): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(14): int = Offset(Value(13)) |stacktrace.len
    Value(15): bool = Call(Fun(330), [Value(12), Value(14)]) |i >= stacktrace.len
    JumpIfTrue(Value(15), Inst(33), []) |i >= stacktrace.len
    Jump(Inst(35), []) |

  Inst33[]
    Jump(Inst(27), []) |break

  Inst35[]
    Value(16): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(18): &Seq[StackFrame] = Ref(Value(16)) |stacktrace[i]
    Value(17): &StackFrame = Call(Fun(485), [Value(18), Value(12)]) |stacktrace[i]
    Value(19): StackFrame = Deref(Value(17), false) |stacktrace[i]
    Value(20): StackFrame = VarDecl(Value(19)) |frame = stacktrace[i]
    Value(21): int = Offset(Value(20)) |frame.line
    Value(22): &Seq[u8] = Ref(Value(10)) |buffer.print_int(frame.line)
    Call(Fun(452), [Value(22), Value(21)]) |buffer.print_int(frame.line)
    Value(23): i32 = Lit(Char(':')) |':'
    Value(24): u8 = Call(Fun(59), [Value(23)]) |':'.u8()
    Value(25): &Seq[u8] = Ref(Value(10)) |buffer.push(':'.u8())
    Call(Fun(476), [Value(25), Value(24)]) |buffer.push(':'.u8())
    Value(26): int = Offset(Value(20)) |frame.column
    Value(27): &Seq[u8] = Ref(Value(10)) |buffer.print_int(frame.column)
    Call(Fun(452), [Value(27), Value(26)]) |buffer.print_int(frame.column)
    Value(28): i32 = Lit(Char(' ')) |' '
    Value(29): u8 = Call(Fun(59), [Value(28)]) |' '.u8()
    Value(30): &Seq[u8] = Ref(Value(10)) |buffer.push(' '.u8())
    Call(Fun(476), [Value(30), Value(29)]) |buffer.push(' '.u8())
    Value(31): &u8 = Offset(Value(20)) |frame.file
    Value(32): &Seq[u8] = Ref(Value(10)) |buffer.print(frame.file)
    Call(Fun(453), [Value(32), Value(31)]) |buffer.print(frame.file)
    Value(33): i32 = Lit(Char('\n')) |'\n'
    Value(34): u8 = Call(Fun(59), [Value(33)]) |'\n'.u8()
    Value(35): &Seq[u8] = Ref(Value(10)) |buffer.push('\n'.u8())
    Call(Fun(476), [Value(35), Value(34)]) |buffer.push('\n'.u8())
    Jump(Inst(26), []) |loop:
    if i >= stacktrace.len:
      break
    
    var frame = stacktrace[i]
    
    buffer.print_int(frame.line)
    buffer.push(':'.u8())
    buffer.print_int(frame.column)
    buffer.push(' '.u8())
    buffer.print(frame.file)
    buffer.push('\n'.u8())

  Inst27[]
    Value(36): i32 = Lit(Char('\u{0}')) |'\x00'
    Value(37): u8 = Call(Fun(59), [Value(36)]) |'\x00'.u8()
    Value(38): &Seq[u8] = Ref(Value(10)) |buffer.push('\x00'.u8())
    Call(Fun(476), [Value(38), Value(37)]) |buffer.push('\x00'.u8())
    Value(39): &u8 = Offset(Value(10)) |buffer.data
    Call(Fun(443), [Value(39)]) |print(buffer.data)
    Value(40): int = Lit(Int(1, 0)) |1
    Call(Fun(444), [Value(40)]) |exit(1)
    Return(None) |exit(1)


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64) fast {
    ss0 = explicit_slot 24
    ss1 = explicit_slot 24
    gv0 = symbol colocated u1:3
    gv1 = symbol colocated u1:4
    gv2 = symbol colocated u1:0
    gv3 = symbol colocated u1:5
    gv4 = symbol colocated u1:0
    gv5 = symbol colocated u1:0
    gv6 = symbol colocated u1:2
    gv7 = symbol colocated u1:1
    gv8 = symbol colocated u1:2
    gv9 = symbol colocated u1:1
    gv10 = symbol colocated u1:2
    gv11 = symbol colocated u1:1
    gv12 = symbol colocated u1:2
    gv13 = symbol colocated u1:1
    gv14 = symbol colocated u1:2
    sig0 = (i64) windows_fastcall
    sig1 = (i64) windows_fastcall
    sig2 = (i64) windows_fastcall
    sig3 = (i64) windows_fastcall
    sig4 = (i64) windows_fastcall
    sig5 = (i64) fast
    sig6 = (i64, i64) fast
    sig7 = (i64) fast
    sig8 = (i64, i64) -> i64 windows_fastcall
    sig9 = (i64) fast
    sig10 = (i64, i64) fast
    sig11 = (i64) fast
    sig12 = (i64, i64) -> i64 windows_fastcall
    sig13 = (i64) fast
    sig14 = (i64, i64) fast
    sig15 = (i64) fast
    sig16 = (i64, i64) -> i64 windows_fastcall
    sig17 = (i64) fast
    sig18 = (i64) fast
    sig19 = (i64, i64) -> i64 windows_fastcall
    sig20 = (i64) fast
    sig21 = (i64) windows_fastcall
    sig22 = (i64) windows_fastcall
    fn0 = u0:21 sig0
    fn1 = u0:21 sig1
    fn2 = u0:21 sig2
    fn3 = u0:21 sig3
    fn4 = u0:20 sig4
    fn5 = colocated u0:19 sig5
    fn6 = colocated u0:4 sig6
    fn7 = colocated u0:19 sig7
    fn8 = u0:26 sig8
    fn9 = colocated u0:19 sig9
    fn10 = colocated u0:4 sig10
    fn11 = colocated u0:19 sig11
    fn12 = u0:26 sig12
    fn13 = colocated u0:19 sig13
    fn14 = colocated u0:0 sig14
    fn15 = colocated u0:19 sig15
    fn16 = u0:26 sig16
    fn17 = colocated u0:19 sig17
    fn18 = colocated u0:19 sig18
    fn19 = u0:26 sig19
    fn20 = colocated u0:19 sig20
    fn21 = u0:21 sig21
    fn22 = u0:20 sig22

block0(v0: i64):
    v216 = iconst.i64 0
    v11 -> v216
    v215 -> v216
    v1 = global_value.i64 gv0
    call fn0(v1)
    call fn1(v0)
    v2 = global_value.i64 gv1
    call fn2(v2)
    v3 = global_value.i64 gv2
    v4 = iconst.i64 0
    v5 = load.i64 v3+8
    v6 = icmp eq v5, v4
    brnz v6, block1
    jump block2

block1:
    v7 = global_value.i64 gv3
    call fn3(v7)
    v8 = iconst.i64 1
    call fn4(v8)
    return

block2:
    v9 = iconst.i64 0
    stack_store v9, ss0
    stack_store v9, ss0+8
    stack_store v9, ss0+16
    v10 = iconst.i64 0
    jump block3(v10)

block3(v13: i64):
    v17 -> v13
    v219 -> v13
    v220 -> v13
    v221 -> v13
    v222 -> v13
    v223 -> v13
    v224 -> v13
    v225 -> v13
    v226 -> v13
    v218 -> v219
    v217 -> v218
    v12 = global_value.i64 gv4
    v14 = load.i64 v12+8
    v15 = icmp sge v13, v14
    brnz v15, block4
    jump block5

block4:
    jump block6

block5:
    v16 = global_value.i64 gv5
    jump block7(v16, v17)

block7(v18: i64, v19: i64):
    jump block9(v18, v19)

block9(v21: i64, v22: i64):
    jump block13(v21, v22)

block13(v23: i64, v24: i64):
    v26 = iconst.i64 0
    v27 = icmp sge v24, v26
    v28 = load.i64 v23+8
    v29 = icmp slt v24, v28
    v30 = band v27, v29
    jump block14(v30)

block14(v25: b1):
    brnz v25, block10
    jump block11

block10:
    v31 = global_value.i64 gv6
    call fn5(v31)
    jump block11

block11:
    jump block12

block12:
    jump block15(v18, v19)

block15(v32: i64, v33: i64):
    v35 = iconst.i64 24
    v36 = imul v33, v35
    v37 = load.i64 v32
    v38 = iadd v37, v36
    jump block16(v38)

block16(v34: i64):
    jump block8(v34)

block8(v20: i64):
    v39 = stack_addr.i64 ss1
    v40 = load.i64 v20
    store v40, v39
    v41 = load.i64 v20+8
    store v41, v39+8
    v42 = load.i64 v20+16
    store v42, v39+16
    v43 = stack_addr.i64 ss0
    v44 = stack_load.i64 ss1
    call fn6(v43, v44)
    v45 = iconst.i32 58
    v46 = ireduce.i8 v45
    v47 = stack_addr.i64 ss0
    jump block17(v47, v46)

block17(v48: i64, v49: i8):
    v50 = global_value.i64 gv7
    call fn7(v50)
    v51 = iconst.i64 1
    v52 = load.i64 v48+8
    v53 = iadd v52, v51
    v54 = load.i64 v48+16
    v55 = icmp sgt v53, v54
    brnz v55, block18
    jump block19

block18:
    v56 = iconst.i64 2
    v57 = load.i64 v48+16
    v58 = imul v57, v56
    store v58, v48+16
    v59 = iconst.i64 1
    v60 = load.i64 v48+16
    v61 = imul v60, v59
    v62 = load.i64 v48
    v63 = call fn8(v62, v61)
    store v63, v48
    jump block19

block19:
    v64 = load.i64 v48+8
    jump block21(v48, v64)

block21(v65: i64, v66: i64):
    jump block23(v65, v66)

block23(v68: i64, v69: i64):
    jump block27(v68, v69)

block27(v70: i64, v71: i64):
    v73 = iconst.i64 0
    v74 = icmp sge v71, v73
    v75 = load.i64 v70+8
    v76 = icmp slt v71, v75
    v77 = band v74, v76
    jump block28(v77)

block28(v72: b1):
    brnz v72, block24
    jump block25

block24:
    v78 = global_value.i64 gv8
    call fn9(v78)
    jump block25

block25:
    jump block26

block26:
    jump block29(v65, v66)

block29(v79: i64, v80: i64):
    v82 = iconst.i64 1
    v83 = imul v80, v82
    v84 = load.i64 v79
    v85 = iadd v84, v83
    jump block30(v85)

block30(v81: i64):
    jump block22(v81)

block22(v67: i64):
    store.i8 v49, v67
    store.i64 v53, v48+8
    jump block20

block20:
    v86 = stack_addr.i64 ss0
    v87 = stack_load.i64 ss1+8
    call fn10(v86, v87)
    v88 = iconst.i32 32
    v89 = ireduce.i8 v88
    v90 = stack_addr.i64 ss0
    jump block31(v90, v89)

block31(v91: i64, v92: i8):
    v93 = global_value.i64 gv9
    call fn11(v93)
    v94 = iconst.i64 1
    v95 = load.i64 v91+8
    v96 = iadd v95, v94
    v97 = load.i64 v91+16
    v98 = icmp sgt v96, v97
    brnz v98, block32
    jump block33

block32:
    v99 = iconst.i64 2
    v100 = load.i64 v91+16
    v101 = imul v100, v99
    store v101, v91+16
    v102 = iconst.i64 1
    v103 = load.i64 v91+16
    v104 = imul v103, v102
    v105 = load.i64 v91
    v106 = call fn12(v105, v104)
    store v106, v91
    jump block33

block33:
    v107 = load.i64 v91+8
    jump block35(v91, v107)

block35(v108: i64, v109: i64):
    jump block37(v108, v109)

block37(v111: i64, v112: i64):
    jump block41(v111, v112)

block41(v113: i64, v114: i64):
    v116 = iconst.i64 0
    v117 = icmp sge v114, v116
    v118 = load.i64 v113+8
    v119 = icmp slt v114, v118
    v120 = band v117, v119
    jump block42(v120)

block42(v115: b1):
    brnz v115, block38
    jump block39

block38:
    v121 = global_value.i64 gv10
    call fn13(v121)
    jump block39

block39:
    jump block40

block40:
    jump block43(v108, v109)

block43(v122: i64, v123: i64):
    v125 = iconst.i64 1
    v126 = imul v123, v125
    v127 = load.i64 v122
    v128 = iadd v127, v126
    jump block44(v128)

block44(v124: i64):
    jump block36(v124)

block36(v110: i64):
    store.i8 v92, v110
    store.i64 v96, v91+8
    jump block34

block34:
    v129 = stack_addr.i64 ss0
    v130 = stack_load.i64 ss1+16
    call fn14(v129, v130)
    v131 = iconst.i32 10
    v132 = ireduce.i8 v131
    v133 = stack_addr.i64 ss0
    jump block45(v133, v132)

block45(v134: i64, v135: i8):
    v136 = global_value.i64 gv11
    call fn15(v136)
    v137 = iconst.i64 1
    v138 = load.i64 v134+8
    v139 = iadd v138, v137
    v140 = load.i64 v134+16
    v141 = icmp sgt v139, v140
    brnz v141, block46
    jump block47

block46:
    v142 = iconst.i64 2
    v143 = load.i64 v134+16
    v144 = imul v143, v142
    store v144, v134+16
    v145 = iconst.i64 1
    v146 = load.i64 v134+16
    v147 = imul v146, v145
    v148 = load.i64 v134
    v149 = call fn16(v148, v147)
    store v149, v134
    jump block47

block47:
    v150 = load.i64 v134+8
    jump block49(v134, v150)

block49(v151: i64, v152: i64):
    jump block51(v151, v152)

block51(v154: i64, v155: i64):
    jump block55(v154, v155)

block55(v156: i64, v157: i64):
    v159 = iconst.i64 0
    v160 = icmp sge v157, v159
    v161 = load.i64 v156+8
    v162 = icmp slt v157, v161
    v163 = band v160, v162
    jump block56(v163)

block56(v158: b1):
    brnz v158, block52
    jump block53

block52:
    v164 = global_value.i64 gv12
    call fn17(v164)
    jump block53

block53:
    jump block54

block54:
    jump block57(v151, v152)

block57(v165: i64, v166: i64):
    v168 = iconst.i64 1
    v169 = imul v166, v168
    v170 = load.i64 v165
    v171 = iadd v170, v169
    jump block58(v171)

block58(v167: i64):
    jump block50(v167)

block50(v153: i64):
    store.i8 v135, v153
    store.i64 v139, v134+8
    jump block48

block48:
    jump block3(v217)

block6:
    v172 = iconst.i32 0
    v173 = ireduce.i8 v172
    v174 = stack_addr.i64 ss0
    jump block59(v174, v173)

block59(v175: i64, v176: i8):
    v177 = global_value.i64 gv13
    call fn18(v177)
    v178 = iconst.i64 1
    v179 = load.i64 v175+8
    v180 = iadd v179, v178
    v181 = load.i64 v175+16
    v182 = icmp sgt v180, v181
    brnz v182, block60
    jump block61

block60:
    v183 = iconst.i64 2
    v184 = load.i64 v175+16
    v185 = imul v184, v183
    store v185, v175+16
    v186 = iconst.i64 1
    v187 = load.i64 v175+16
    v188 = imul v187, v186
    v189 = load.i64 v175
    v190 = call fn19(v189, v188)
    store v190, v175
    jump block61

block61:
    v191 = load.i64 v175+8
    jump block63(v175, v191)

block63(v192: i64, v193: i64):
    jump block65(v192, v193)

block65(v195: i64, v196: i64):
    jump block69(v195, v196)

block69(v197: i64, v198: i64):
    v200 = iconst.i64 0
    v201 = icmp sge v198, v200
    v202 = load.i64 v197+8
    v203 = icmp slt v198, v202
    v204 = band v201, v203
    jump block70(v204)

block70(v199: b1):
    brnz v199, block66
    jump block67

block66:
    v205 = global_value.i64 gv14
    call fn20(v205)
    jump block67

block67:
    jump block68

block68:
    jump block71(v192, v193)

block71(v206: i64, v207: i64):
    v209 = iconst.i64 1
    v210 = imul v207, v209
    v211 = load.i64 v206
    v212 = iadd v211, v210
    jump block72(v212)

block72(v208: i64):
    jump block64(v208)

block64(v194: i64):
    store.i8 v176, v194
    store.i64 v180, v175+8
    jump block62

block62:
    v213 = stack_load.i64 ss0
    call fn21(v213)
    v214 = iconst.i64 1
    call fn22(v214)
    return
}

fun exit(code: int)


fun print(str: &u8)


fun memcpy(dest: &u8, src: &u8, size: int)


fun memmove(dest: &u8, src: &u8, size: int)


fun memset(ptr: &u8, value: u8, size: int)


fun free(ptr: &u8)


fun realloc(ptr: &u8, size: int) -> &u8


fun alloc(size: int) -> &u8


fun main -> int

  Inst1[]
    Value(0): int = Lit(Int(1, 0)) |1
    Value(1): int = Lit(Int(1, 0)) |1
    Value(2): int = Call(Fun(270), [Value(0), Value(1)]) |1 - 1
    Return(Some(Value(2))) |return 1 - 1


function u0:0() -> i64 fast {
block0:
    v0 = iconst.i64 1
    v1 = iconst.i64 1
    v2 = isub v0, v1
    return v2
}



  Inst1[Value(0), Value(1)]
    Value(2): int = Zeroed |
    Value(3): int = VarDecl(Value(2)) |
    Value(4): int = Call(Fun(488), []) |entry
    Value(4): int = Assign(Value(3)) |entry
    Return(Some(Value(3))) |


function u0:0(i64, i64) -> i64 fast {
    sig0 = () -> i64 fast
    fn0 = colocated u0:28 sig0

block0(v0: i64, v1: i64):
    v5 = iconst.i64 0
    v3 -> v5
    v2 = iconst.i64 0
    v4 = call fn0()
    return v4
}


fun print(s: &Self, value: &u8)

  Inst1[Value(0), Value(1)]
    Value(2): int = Lit(Int(0, 0)) |0
    Value(3): int = VarDecl(Value(2)) |i = 0
    Jump(Inst(4), []) |loop:
      let value = *((value as int + i) as &u8)
      if value == 0u8:
        break
      i += 1

  Inst4[]
    Value(4): int = Cast(Value(1)) |value as int
    Value(5): int = Call(Fun(260), [Value(4), Value(3)]) |(value as int + i)
    Value(6): &u8 = Cast(Value(5)) |((value as int + i) as &u8)
    Value(7): u8 = Deref(Value(6), false) |*((value as int + i) as &u8)
    Value(8): u8 = VarDecl(Value(7)) |value = *((value as int + i) as &u8)
    Value(9): u8 = Lit(Uint(0, 8)) |0u8
    Value(10): bool = Call(Fun(306), [Value(8), Value(9)]) |value == 0u8
    JumpIfTrue(Value(10), Inst(15), []) |value == 0u8
    Jump(Inst(17), []) |

  Inst15[]
    Jump(Inst(5), []) |break

  Inst17[]
    Value(11): int = Lit(Int(1, 0)) |1
    Value(12): int = Call(Fun(260), [Value(3), Value(11)]) |i += 1
    Value(12): int = Assign(Value(3)) |i += 1
    Jump(Inst(4), []) |loop:
      let value = *((value as int + i) as &u8)
      if value == 0u8:
        break
      i += 1

  Inst5[]
    Call(Fun(473), [Value(0), Value(3)]) |s.reserve(i)
    Value(14): &Seq[u8] = Offset(Value(0)) |s.len
    Value(15): Seq[u8] = Deref(Value(14), false) |s.len
    Value(13): int = Offset(Value(15)) |s.len
    Value(16): &u8 = Call(Fun(474), [Value(0), Value(13)]) |s.get_unchecked(s.len)
    Call(Fun(442), [Value(16), Value(1), Value(3)]) |memcpy(s.get_unchecked(s.len), value, i)
    Value(18): &Seq[u8] = Offset(Value(0)) |s.len
    Value(19): Seq[u8] = Deref(Value(18), false) |s.len
    Value(17): int = Offset(Value(19)) |s.len
    Value(21): &Seq[u8] = Offset(Value(0)) |s.len
    Value(22): Seq[u8] = Deref(Value(21), false) |s.len
    Value(20): int = Offset(Value(22)) |s.len
    Value(23): int = Call(Fun(260), [Value(20), Value(3)]) |s.len += i
    Value(23): int = Assign(Value(17)) |s.len += i
    Return(None) |s.len += i


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 2460..2495 }, line_data: LineData { line: 128, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64) fast {
    sig0 = (i64, i64) -> i64 windows_fastcall
    sig1 = (i64, i64, i64) windows_fastcall
    fn0 = u0:26 sig0
    fn1 = u0:22 sig1

block0(v0: i64, v1: i64):
    v32 = iconst.i64 0
    v3 -> v32
    v2 = iconst.i64 0
    jump block1(v2)

block1(v4: i64):
    v10 -> v4
    v12 -> v4
    v29 -> v4
    v33 -> v4
    v5 = iadd.i64 v1, v4
    v6 = load.i8 v5
    v7 = iconst.i8 0
    v8 = icmp eq v6, v7
    brnz v8, block2
    jump block3

block2:
    jump block4

block3:
    v9 = iconst.i64 1
    v11 = iadd.i64 v10, v9
    jump block1(v11)

block4:
    jump block5(v0, v12)

block5(v13: i64, v14: i64):
    v15 = load.i64 v13+16
    v16 = icmp sgt v15, v14
    brnz v16, block6
    jump block7

block6:
    jump block8

block7:
    v17 = iconst.i64 1
    v18 = imul.i64 v14, v17
    v19 = load.i64 v13
    v20 = call fn0(v19, v18)
    store v20, v13
    store.i64 v14, v13+16
    jump block8

block8:
    v21 = load.i64 v0+8
    jump block9(v0, v21)

block9(v22: i64, v23: i64):
    v25 = iconst.i64 1
    v26 = imul v23, v25
    v27 = load.i64 v22
    v28 = iadd v27, v26
    jump block10(v28)

block10(v24: i64):
    call fn1(v24, v1, v29)
    v30 = load.i64 v0+8
    v31 = iadd v30, v29
    store v31, v0+8
    return
}

fun sizeof[T] -> int


fun print_int(s: &Self, value: int)

  Inst1[Value(0), Value(1)]
    Value(2): int = VarDecl(Value(1)) |value = value
    Jump(Inst(3), []) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())

  Inst3[]
    Value(3): int = Lit(Int(0, 0)) |0
    Value(4): bool = Call(Fun(310), [Value(2), Value(3)]) |value == 0
    JumpIfTrue(Value(4), Inst(9), []) |value == 0
    Jump(Inst(11), []) |

  Inst9[]
    Jump(Inst(4), []) |break

  Inst11[]
    Value(5): int = Lit(Int(10, 0)) |10
    Value(6): int = Call(Fun(300), [Value(2), Value(5)]) |value % 10
    Value(7): int = VarDecl(Value(6)) |digit = value % 10
    Value(8): int = Lit(Int(10, 0)) |10
    Value(9): int = Call(Fun(290), [Value(2), Value(8)]) |value / 10
    Value(9): int = Assign(Value(2)) |value = value / 10
    Value(10): u32 = Call(Fun(96), [Value(7)]) |digit.u32()
    Value(11): i32 = Lit(Char('0')) |'0'
    Value(12): u32 = Call(Fun(258), [Value(10), Value(11)]) |(
    Value(13): u8 = Call(Fun(63), [Value(12)]) |(digit.u32() + '0').u8()
    Call(Fun(476), [Value(0), Value(13)]) |s.push((digit.u32() + '0').u8())
    Jump(Inst(3), []) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())

  Inst4[]
    Return(None) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64) fast {
    gv0 = symbol colocated u1:1
    gv1 = symbol colocated u1:2
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 windows_fastcall
    sig2 = (i64) fast
    fn0 = colocated u0:19 sig0
    fn1 = u0:26 sig1
    fn2 = colocated u0:19 sig2

block0(v0: i64, v1: i64):
    v58 = iconst.i64 0
    v57 -> v58
    v54 = iconst.i64 0
    v2 -> v54
    jump block1(v1, v57)

block1(v4: i64, v56: i64):
    v7 -> v4
    v9 -> v56
    v3 = iconst.i64 0
    v5 = icmp eq v4, v3
    brnz v5, block2
    jump block3

block2:
    jump block4

block3:
    v6 = iconst.i64 10
    v8 = srem.i64 v7, v6
    v63 -> v8
    v66 -> v8
    v67 -> v8
    v61 -> v63
    v59 -> v61
    v10 = iconst.i64 10
    v11 = sdiv.i64 v7, v10
    v62 -> v11
    v64 -> v11
    v65 -> v11
    v60 -> v62
    v55 -> v60
    v12 = ireduce.i32 v8
    v13 = iconst.i32 48
    v14 = iadd v12, v13
    v15 = ireduce.i8 v14
    jump block5(v0, v15)

block5(v16: i64, v17: i8):
    v18 = global_value.i64 gv0
    call fn0(v18)
    v19 = iconst.i64 1
    v20 = load.i64 v16+8
    v21 = iadd v20, v19
    v22 = load.i64 v16+16
    v23 = icmp sgt v21, v22
    brnz v23, block6
    jump block7

block6:
    v24 = iconst.i64 2
    v25 = load.i64 v16+16
    v26 = imul v25, v24
    store v26, v16+16
    v27 = iconst.i64 1
    v28 = load.i64 v16+16
    v29 = imul v28, v27
    v30 = load.i64 v16
    v31 = call fn1(v30, v29)
    store v31, v16
    jump block7

block7:
    v32 = load.i64 v16+8
    jump block9(v16, v32)

block9(v33: i64, v34: i64):
    jump block11(v33, v34)

block11(v36: i64, v37: i64):
    jump block15(v36, v37)

block15(v38: i64, v39: i64):
    v41 = iconst.i64 0
    v42 = icmp sge v39, v41
    v43 = load.i64 v38+8
    v44 = icmp slt v39, v43
    v45 = band v42, v44
    jump block16(v45)

block16(v40: b1):
    brnz v40, block12
    jump block13

block12:
    v46 = global_value.i64 gv1
    call fn2(v46)
    jump block13

block13:
    jump block14

block14:
    jump block17(v33, v34)

block17(v47: i64, v48: i64):
    v50 = iconst.i64 1
    v51 = imul v48, v50
    v52 = load.i64 v47
    v53 = iadd v52, v51
    jump block18(v53)

block18(v49: i64):
    jump block10(v49)

block10(v35: i64):
    store.i8 v17, v35
    store.i64 v21, v16+8
    jump block8

block8:
    jump block1(v55, v59)

block4:
    return
}

fun pop_frame

  Inst1[]
    Value(0): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(2): &Seq[StackFrame] = Ref(Value(0)) |stacktrace.pop()
    Value(1): Option[StackFrame] = Call(Fun(480), [Value(2), Value(1)]) |stacktrace.pop()
    Return(None) |stacktrace.pop()


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3455..3485 }, line_data: LineData { line: 171, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4453..4479 }, line_data: LineData { line: 212, column: 3, source: Source(1) } }
function u0:0() fast {
    ss0 = explicit_slot 32
    ss1 = explicit_slot 24
    ss2 = explicit_slot 32
    ss3 = explicit_slot 32
    gv0 = symbol colocated u1:0

block0:
    v0 = global_value.i64 gv0
    v1 = stack_addr.i64 ss0
    jump block1(v0, v1)

block1(v2: i64, v3: i64):
    v5 = iconst.i64 0
    v6 = load.i64 v2+8
    v7 = icmp eq v6, v5
    brnz v7, block2
    jump block3

block2:
    v8 = iconst.i64 0
    store v8, v3
    store v8, v3+8
    store v8, v3+16
    store v8, v3+24
    jump block4(v3)

block3:
    v9 = iconst.i64 1
    v10 = load.i64 v2+8
    v11 = isub v10, v9
    jump block5(v2, v11)

block5(v12: i64, v13: i64):
    v15 = iconst.i64 24
    v16 = imul v13, v15
    v17 = load.i64 v12
    v18 = iadd v17, v16
    jump block6(v18)

block6(v14: i64):
    v19 = stack_addr.i64 ss1
    v20 = load.i64 v14
    store v20, v19
    v21 = load.i64 v14+8
    store v21, v19+8
    v22 = load.i64 v14+16
    store v22, v19+16
    v23 = iconst.i64 1
    v24 = load.i64 v2+8
    v25 = isub v24, v23
    store v25, v2+8
    v26 = stack_addr.i64 ss1
    v27 = stack_addr.i64 ss2
    jump block7(v26, v27)

block7(v28: i64, v29: i64):
    v31 = iconst.i64 0
    stack_store v31, ss3
    stack_store v31, ss3+8
    stack_store v31, ss3+16
    stack_store v31, ss3+24
    stack_store v28, ss3
    v32 = bconst.b1 true
    v33 = bint.i8 v32
    stack_store v33, ss3+24
    v34 = stack_addr.i64 ss3
    v35 = load.i64 v34
    store v35, v29
    v36 = load.i64 v34+8
    store v36, v29+8
    v37 = load.i64 v34+16
    store v37, v29+16
    v38 = load.i64 v34+24
    store v38, v29+24
    jump block8(v29)

block8(v30: i64):
    v39 = load.i64 v30
    store v39, v3
    v40 = load.i64 v30+8
    store v40, v3+8
    v41 = load.i64 v30+16
    store v41, v3+16
    v42 = load.i64 v30+24
    store v42, v3+24
    jump block4(v3)

block4(v4: i64):
    return
}

fun sizeof[T] -> int


fun push_frame(line, column: int, file: &u8)

  Inst1[Value(0), Value(1), Value(2)]
    Value(3): StackFrame = Zeroed |frame: StackFrame
    Value(4): StackFrame = VarDecl(Value(3)) |frame: StackFrame
    Value(5): int = Offset(Value(4)) |frame.line
    Value(0): int = Assign(Value(5)) |frame.line = line
    Value(6): int = Offset(Value(4)) |frame.column
    Value(1): int = Assign(Value(6)) |frame.column = column
    Value(7): &u8 = Offset(Value(4)) |frame.file
    Value(2): &u8 = Assign(Value(7)) |frame.file = file
    Value(8): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(9): &Seq[StackFrame] = Ref(Value(8)) |stacktrace.push(frame)
    Call(Fun(484), [Value(9), Value(4)]) |stacktrace.push(frame)
    Return(None) |stacktrace.push(frame)


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64, i64) fast {
    ss0 = explicit_slot 24
    gv0 = symbol colocated u1:0
    gv1 = symbol colocated u1:1
    gv2 = symbol colocated u1:2
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 windows_fastcall
    sig2 = (i64) fast
    fn0 = colocated u0:19 sig0
    fn1 = u0:26 sig1
    fn2 = colocated u0:19 sig2

block0(v0: i64, v1: i64, v2: i64):
    v3 = iconst.i64 0
    stack_store v3, ss0
    stack_store v3, ss0+8
    stack_store v3, ss0+16
    stack_store v0, ss0
    stack_store v1, ss0+8
    stack_store v2, ss0+16
    v4 = global_value.i64 gv0
    v5 = stack_addr.i64 ss0
    jump block1(v4, v5)

block1(v6: i64, v7: i64):
    v8 = global_value.i64 gv1
    call fn0(v8)
    v9 = iconst.i64 1
    v10 = load.i64 v6+8
    v11 = iadd v10, v9
    v12 = load.i64 v6+16
    v13 = icmp sgt v11, v12
    brnz v13, block2
    jump block3

block2:
    v14 = iconst.i64 2
    v15 = load.i64 v6+16
    v16 = imul v15, v14
    store v16, v6+16
    v17 = iconst.i64 24
    v18 = load.i64 v6+16
    v19 = imul v18, v17
    v20 = load.i64 v6
    v21 = call fn1(v20, v19)
    store v21, v6
    jump block3

block3:
    v22 = load.i64 v6+8
    jump block5(v6, v22)

block5(v23: i64, v24: i64):
    jump block7(v23, v24)

block7(v26: i64, v27: i64):
    jump block11(v26, v27)

block11(v28: i64, v29: i64):
    v31 = iconst.i64 0
    v32 = icmp sge v29, v31
    v33 = load.i64 v28+8
    v34 = icmp slt v29, v33
    v35 = band v32, v34
    jump block12(v35)

block12(v30: b1):
    brnz v30, block8
    jump block9

block8:
    v36 = global_value.i64 gv2
    call fn2(v36)
    jump block9

block9:
    jump block10

block10:
    jump block13(v23, v24)

block13(v37: i64, v38: i64):
    v40 = iconst.i64 24
    v41 = imul v38, v40
    v42 = load.i64 v37
    v43 = iadd v42, v41
    jump block14(v43)

block14(v39: i64):
    jump block6(v39)

block6(v25: i64):
    v44 = load.i64 v7
    store v44, v25
    v45 = load.i64 v7+8
    store v45, v25+8
    v46 = load.i64 v7+16
    store v46, v25+16
    store.i64 v11, v6+8
    jump block4

block4:
    return
}

fun panic(str: &u8)

  Inst1[Value(0)]
    Value(1): &u8 = Lit(String(Spam { source: Source(0), hash: ID(13499977805273881313), range: 135..159 })) |"panic: "
    Call(Fun(443), [Value(1)]) |print("panic: ")
    Call(Fun(443), [Value(0)]) |print(str)
    Value(2): &u8 = Lit(String(Spam { source: Source(0), hash: ID(10606491740656731085), range: 185..213 })) |"\n"
    Call(Fun(443), [Value(2)]) |print("\n")
    Value(3): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(4): int = Offset(Value(3)) |stacktrace.len
    Value(5): int = Lit(Int(0, 0)) |0
    Value(6): bool = Call(Fun(310), [Value(4), Value(5)]) |stacktrace.len == 0
    JumpIfTrue(Value(6), Inst(11), []) |stacktrace.len == 0
    Jump(Inst(13), []) |

  Inst11[]
    Value(7): &u8 = Lit(String(Spam { source: Source(0), hash: ID(9851784588597441741), range: 316..494 })) |"no stacktrace available, use '-trace' when building to generate stactrace\n"
    Call(Fun(443), [Value(7)]) |print("no stacktrace available, use '-trace' when building to generate stactrace\n")
    Value(8): int = Lit(Int(1, 0)) |1
    Call(Fun(444), [Value(8)]) |exit(1)
    Return(None) |return

  Inst13[]
    Value(9): Seq[u8] = Zeroed |buffer: Seq[u8]
    Value(10): Seq[u8] = VarDecl(Value(9)) |buffer: Seq[u8]
    Value(11): int = Zeroed |i: int
    Value(12): int = VarDecl(Value(11)) |i: int
    Jump(Inst(26), []) |loop:
    if i >= stacktrace.len:
      break
    
    var frame = stacktrace[i]
    
    buffer.print_int(frame.line)
    buffer.push(':'.u8())
    buffer.print_int(frame.column)
    buffer.push(' '.u8())
    buffer.print(frame.file)
    buffer.push('\n'.u8())

  Inst26[]
    Value(13): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(14): int = Offset(Value(13)) |stacktrace.len
    Value(15): bool = Call(Fun(330), [Value(12), Value(14)]) |i >= stacktrace.len
    JumpIfTrue(Value(15), Inst(33), []) |i >= stacktrace.len
    Jump(Inst(35), []) |

  Inst33[]
    Jump(Inst(27), []) |break

  Inst35[]
    Value(16): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(18): &Seq[StackFrame] = Ref(Value(16)) |stacktrace[i]
    Value(17): &StackFrame = Call(Fun(485), [Value(18), Value(12)]) |stacktrace[i]
    Value(19): StackFrame = Deref(Value(17), false) |stacktrace[i]
    Value(20): StackFrame = VarDecl(Value(19)) |frame = stacktrace[i]
    Value(21): int = Offset(Value(20)) |frame.line
    Value(22): &Seq[u8] = Ref(Value(10)) |buffer.print_int(frame.line)
    Call(Fun(452), [Value(22), Value(21)]) |buffer.print_int(frame.line)
    Value(23): i32 = Lit(Char(':')) |':'
    Value(24): u8 = Call(Fun(59), [Value(23)]) |':'.u8()
    Value(25): &Seq[u8] = Ref(Value(10)) |buffer.push(':'.u8())
    Call(Fun(476), [Value(25), Value(24)]) |buffer.push(':'.u8())
    Value(26): int = Offset(Value(20)) |frame.column
    Value(27): &Seq[u8] = Ref(Value(10)) |buffer.print_int(frame.column)
    Call(Fun(452), [Value(27), Value(26)]) |buffer.print_int(frame.column)
    Value(28): i32 = Lit(Char(' ')) |' '
    Value(29): u8 = Call(Fun(59), [Value(28)]) |' '.u8()
    Value(30): &Seq[u8] = Ref(Value(10)) |buffer.push(' '.u8())
    Call(Fun(476), [Value(30), Value(29)]) |buffer.push(' '.u8())
    Value(31): &u8 = Offset(Value(20)) |frame.file
    Value(32): &Seq[u8] = Ref(Value(10)) |buffer.print(frame.file)
    Call(Fun(453), [Value(32), Value(31)]) |buffer.print(frame.file)
    Value(33): i32 = Lit(Char('\n')) |'\n'
    Value(34): u8 = Call(Fun(59), [Value(33)]) |'\n'.u8()
    Value(35): &Seq[u8] = Ref(Value(10)) |buffer.push('\n'.u8())
    Call(Fun(476), [Value(35), Value(34)]) |buffer.push('\n'.u8())
    Jump(Inst(26), []) |loop:
    if i >= stacktrace.len:
      break
    
    var frame = stacktrace[i]
    
    buffer.print_int(frame.line)
    buffer.push(':'.u8())
    buffer.print_int(frame.column)
    buffer.push(' '.u8())
    buffer.print(frame.file)
    buffer.push('\n'.u8())

  Inst27[]
    Value(36): i32 = Lit(Char('\u{0}')) |'\x00'
    Value(37): u8 = Call(Fun(59), [Value(36)]) |'\x00'.u8()
    Value(38): &Seq[u8] = Ref(Value(10)) |buffer.push('\x00'.u8())
    Call(Fun(476), [Value(38), Value(37)]) |buffer.push('\x00'.u8())
    Value(39): &u8 = Offset(Value(10)) |buffer.data
    Call(Fun(443), [Value(39)]) |print(buffer.data)
    Value(40): int = Lit(Int(1, 0)) |1
    Call(Fun(444), [Value(40)]) |exit(1)
    Return(None) |exit(1)


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64) fast {
    ss0 = explicit_slot 24
    ss1 = explicit_slot 24
    gv0 = symbol colocated u1:3
    gv1 = symbol colocated u1:4
    gv2 = symbol colocated u1:0
    gv3 = symbol colocated u1:5
    gv4 = symbol colocated u1:0
    gv5 = symbol colocated u1:0
    gv6 = symbol colocated u1:2
    gv7 = symbol colocated u1:1
    gv8 = symbol colocated u1:2
    gv9 = symbol colocated u1:1
    gv10 = symbol colocated u1:2
    gv11 = symbol colocated u1:1
    gv12 = symbol colocated u1:2
    gv13 = symbol colocated u1:1
    gv14 = symbol colocated u1:2
    sig0 = (i64) windows_fastcall
    sig1 = (i64) windows_fastcall
    sig2 = (i64) windows_fastcall
    sig3 = (i64) windows_fastcall
    sig4 = (i64) windows_fastcall
    sig5 = (i64) fast
    sig6 = (i64, i64) fast
    sig7 = (i64) fast
    sig8 = (i64, i64) -> i64 windows_fastcall
    sig9 = (i64) fast
    sig10 = (i64, i64) fast
    sig11 = (i64) fast
    sig12 = (i64, i64) -> i64 windows_fastcall
    sig13 = (i64) fast
    sig14 = (i64, i64) fast
    sig15 = (i64) fast
    sig16 = (i64, i64) -> i64 windows_fastcall
    sig17 = (i64) fast
    sig18 = (i64) fast
    sig19 = (i64, i64) -> i64 windows_fastcall
    sig20 = (i64) fast
    sig21 = (i64) windows_fastcall
    sig22 = (i64) windows_fastcall
    fn0 = u0:21 sig0
    fn1 = u0:21 sig1
    fn2 = u0:21 sig2
    fn3 = u0:21 sig3
    fn4 = u0:20 sig4
    fn5 = colocated u0:19 sig5
    fn6 = colocated u0:4 sig6
    fn7 = colocated u0:19 sig7
    fn8 = u0:26 sig8
    fn9 = colocated u0:19 sig9
    fn10 = colocated u0:4 sig10
    fn11 = colocated u0:19 sig11
    fn12 = u0:26 sig12
    fn13 = colocated u0:19 sig13
    fn14 = colocated u0:0 sig14
    fn15 = colocated u0:19 sig15
    fn16 = u0:26 sig16
    fn17 = colocated u0:19 sig17
    fn18 = colocated u0:19 sig18
    fn19 = u0:26 sig19
    fn20 = colocated u0:19 sig20
    fn21 = u0:21 sig21
    fn22 = u0:20 sig22

block0(v0: i64):
    v216 = iconst.i64 0
    v11 -> v216
    v215 -> v216
    v1 = global_value.i64 gv0
    call fn0(v1)
    call fn1(v0)
    v2 = global_value.i64 gv1
    call fn2(v2)
    v3 = global_value.i64 gv2
    v4 = iconst.i64 0
    v5 = load.i64 v3+8
    v6 = icmp eq v5, v4
    brnz v6, block1
    jump block2

block1:
    v7 = global_value.i64 gv3
    call fn3(v7)
    v8 = iconst.i64 1
    call fn4(v8)
    return

block2:
    v9 = iconst.i64 0
    stack_store v9, ss0
    stack_store v9, ss0+8
    stack_store v9, ss0+16
    v10 = iconst.i64 0
    jump block3(v10)

block3(v13: i64):
    v17 -> v13
    v219 -> v13
    v220 -> v13
    v221 -> v13
    v222 -> v13
    v223 -> v13
    v224 -> v13
    v225 -> v13
    v226 -> v13
    v218 -> v219
    v217 -> v218
    v12 = global_value.i64 gv4
    v14 = load.i64 v12+8
    v15 = icmp sge v13, v14
    brnz v15, block4
    jump block5

block4:
    jump block6

block5:
    v16 = global_value.i64 gv5
    jump block7(v16, v17)

block7(v18: i64, v19: i64):
    jump block9(v18, v19)

block9(v21: i64, v22: i64):
    jump block13(v21, v22)

block13(v23: i64, v24: i64):
    v26 = iconst.i64 0
    v27 = icmp sge v24, v26
    v28 = load.i64 v23+8
    v29 = icmp slt v24, v28
    v30 = band v27, v29
    jump block14(v30)

block14(v25: b1):
    brnz v25, block10
    jump block11

block10:
    v31 = global_value.i64 gv6
    call fn5(v31)
    jump block11

block11:
    jump block12

block12:
    jump block15(v18, v19)

block15(v32: i64, v33: i64):
    v35 = iconst.i64 24
    v36 = imul v33, v35
    v37 = load.i64 v32
    v38 = iadd v37, v36
    jump block16(v38)

block16(v34: i64):
    jump block8(v34)

block8(v20: i64):
    v39 = stack_addr.i64 ss1
    v40 = load.i64 v20
    store v40, v39
    v41 = load.i64 v20+8
    store v41, v39+8
    v42 = load.i64 v20+16
    store v42, v39+16
    v43 = stack_addr.i64 ss0
    v44 = stack_load.i64 ss1
    call fn6(v43, v44)
    v45 = iconst.i32 58
    v46 = ireduce.i8 v45
    v47 = stack_addr.i64 ss0
    jump block17(v47, v46)

block17(v48: i64, v49: i8):
    v50 = global_value.i64 gv7
    call fn7(v50)
    v51 = iconst.i64 1
    v52 = load.i64 v48+8
    v53 = iadd v52, v51
    v54 = load.i64 v48+16
    v55 = icmp sgt v53, v54
    brnz v55, block18
    jump block19

block18:
    v56 = iconst.i64 2
    v57 = load.i64 v48+16
    v58 = imul v57, v56
    store v58, v48+16
    v59 = iconst.i64 1
    v60 = load.i64 v48+16
    v61 = imul v60, v59
    v62 = load.i64 v48
    v63 = call fn8(v62, v61)
    store v63, v48
    jump block19

block19:
    v64 = load.i64 v48+8
    jump block21(v48, v64)

block21(v65: i64, v66: i64):
    jump block23(v65, v66)

block23(v68: i64, v69: i64):
    jump block27(v68, v69)

block27(v70: i64, v71: i64):
    v73 = iconst.i64 0
    v74 = icmp sge v71, v73
    v75 = load.i64 v70+8
    v76 = icmp slt v71, v75
    v77 = band v74, v76
    jump block28(v77)

block28(v72: b1):
    brnz v72, block24
    jump block25

block24:
    v78 = global_value.i64 gv8
    call fn9(v78)
    jump block25

block25:
    jump block26

block26:
    jump block29(v65, v66)

block29(v79: i64, v80: i64):
    v82 = iconst.i64 1
    v83 = imul v80, v82
    v84 = load.i64 v79
    v85 = iadd v84, v83
    jump block30(v85)

block30(v81: i64):
    jump block22(v81)

block22(v67: i64):
    store.i8 v49, v67
    store.i64 v53, v48+8
    jump block20

block20:
    v86 = stack_addr.i64 ss0
    v87 = stack_load.i64 ss1+8
    call fn10(v86, v87)
    v88 = iconst.i32 32
    v89 = ireduce.i8 v88
    v90 = stack_addr.i64 ss0
    jump block31(v90, v89)

block31(v91: i64, v92: i8):
    v93 = global_value.i64 gv9
    call fn11(v93)
    v94 = iconst.i64 1
    v95 = load.i64 v91+8
    v96 = iadd v95, v94
    v97 = load.i64 v91+16
    v98 = icmp sgt v96, v97
    brnz v98, block32
    jump block33

block32:
    v99 = iconst.i64 2
    v100 = load.i64 v91+16
    v101 = imul v100, v99
    store v101, v91+16
    v102 = iconst.i64 1
    v103 = load.i64 v91+16
    v104 = imul v103, v102
    v105 = load.i64 v91
    v106 = call fn12(v105, v104)
    store v106, v91
    jump block33

block33:
    v107 = load.i64 v91+8
    jump block35(v91, v107)

block35(v108: i64, v109: i64):
    jump block37(v108, v109)

block37(v111: i64, v112: i64):
    jump block41(v111, v112)

block41(v113: i64, v114: i64):
    v116 = iconst.i64 0
    v117 = icmp sge v114, v116
    v118 = load.i64 v113+8
    v119 = icmp slt v114, v118
    v120 = band v117, v119
    jump block42(v120)

block42(v115: b1):
    brnz v115, block38
    jump block39

block38:
    v121 = global_value.i64 gv10
    call fn13(v121)
    jump block39

block39:
    jump block40

block40:
    jump block43(v108, v109)

block43(v122: i64, v123: i64):
    v125 = iconst.i64 1
    v126 = imul v123, v125
    v127 = load.i64 v122
    v128 = iadd v127, v126
    jump block44(v128)

block44(v124: i64):
    jump block36(v124)

block36(v110: i64):
    store.i8 v92, v110
    store.i64 v96, v91+8
    jump block34

block34:
    v129 = stack_addr.i64 ss0
    v130 = stack_load.i64 ss1+16
    call fn14(v129, v130)
    v131 = iconst.i32 10
    v132 = ireduce.i8 v131
    v133 = stack_addr.i64 ss0
    jump block45(v133, v132)

block45(v134: i64, v135: i8):
    v136 = global_value.i64 gv11
    call fn15(v136)
    v137 = iconst.i64 1
    v138 = load.i64 v134+8
    v139 = iadd v138, v137
    v140 = load.i64 v134+16
    v141 = icmp sgt v139, v140
    brnz v141, block46
    jump block47

block46:
    v142 = iconst.i64 2
    v143 = load.i64 v134+16
    v144 = imul v143, v142
    store v144, v134+16
    v145 = iconst.i64 1
    v146 = load.i64 v134+16
    v147 = imul v146, v145
    v148 = load.i64 v134
    v149 = call fn16(v148, v147)
    store v149, v134
    jump block47

block47:
    v150 = load.i64 v134+8
    jump block49(v134, v150)

block49(v151: i64, v152: i64):
    jump block51(v151, v152)

block51(v154: i64, v155: i64):
    jump block55(v154, v155)

block55(v156: i64, v157: i64):
    v159 = iconst.i64 0
    v160 = icmp sge v157, v159
    v161 = load.i64 v156+8
    v162 = icmp slt v157, v161
    v163 = band v160, v162
    jump block56(v163)

block56(v158: b1):
    brnz v158, block52
    jump block53

block52:
    v164 = global_value.i64 gv12
    call fn17(v164)
    jump block53

block53:
    jump block54

block54:
    jump block57(v151, v152)

block57(v165: i64, v166: i64):
    v168 = iconst.i64 1
    v169 = imul v166, v168
    v170 = load.i64 v165
    v171 = iadd v170, v169
    jump block58(v171)

block58(v167: i64):
    jump block50(v167)

block50(v153: i64):
    store.i8 v135, v153
    store.i64 v139, v134+8
    jump block48

block48:
    jump block3(v217)

block6:
    v172 = iconst.i32 0
    v173 = ireduce.i8 v172
    v174 = stack_addr.i64 ss0
    jump block59(v174, v173)

block59(v175: i64, v176: i8):
    v177 = global_value.i64 gv13
    call fn18(v177)
    v178 = iconst.i64 1
    v179 = load.i64 v175+8
    v180 = iadd v179, v178
    v181 = load.i64 v175+16
    v182 = icmp sgt v180, v181
    brnz v182, block60
    jump block61

block60:
    v183 = iconst.i64 2
    v184 = load.i64 v175+16
    v185 = imul v184, v183
    store v185, v175+16
    v186 = iconst.i64 1
    v187 = load.i64 v175+16
    v188 = imul v187, v186
    v189 = load.i64 v175
    v190 = call fn19(v189, v188)
    store v190, v175
    jump block61

block61:
    v191 = load.i64 v175+8
    jump block63(v175, v191)

block63(v192: i64, v193: i64):
    jump block65(v192, v193)

block65(v195: i64, v196: i64):
    jump block69(v195, v196)

block69(v197: i64, v198: i64):
    v200 = iconst.i64 0
    v201 = icmp sge v198, v200
    v202 = load.i64 v197+8
    v203 = icmp slt v198, v202
    v204 = band v201, v203
    jump block70(v204)

block70(v199: b1):
    brnz v199, block66
    jump block67

block66:
    v205 = global_value.i64 gv14
    call fn20(v205)
    jump block67

block67:
    jump block68

block68:
    jump block71(v192, v193)

block71(v206: i64, v207: i64):
    v209 = iconst.i64 1
    v210 = imul v207, v209
    v211 = load.i64 v206
    v212 = iadd v211, v210
    jump block72(v212)

block72(v208: i64):
    jump block64(v208)

block64(v194: i64):
    store.i8 v176, v194
    store.i64 v180, v175+8
    jump block62

block62:
    v213 = stack_load.i64 ss0
    call fn21(v213)
    v214 = iconst.i64 1
    call fn22(v214)
    return
}

fun exit(code: int)


fun print(str: &u8)


fun memcpy(dest: &u8, src: &u8, size: int)


fun memmove(dest: &u8, src: &u8, size: int)


fun memset(ptr: &u8, value: u8, size: int)


fun free(ptr: &u8)


fun realloc(ptr: &u8, size: int) -> &u8


fun alloc(size: int) -> &u8


fun main -> int

  Inst1[]
    Value(0): int = Lit(Int(1, 0)) |1
    Value(1): int = Lit(Int(1, 0)) |1
    Value(2): int = Call(Fun(260), [Value(0), Value(1)]) |1 + 1
    Return(Some(Value(2))) |return 1 + 1


function u0:0() -> i64 fast {
block0:
    v0 = iconst.i64 1
    v1 = iconst.i64 1
    v2 = iadd v0, v1
    return v2
}



  Inst1[Value(0), Value(1)]
    Value(2): int = Zeroed |
    Value(3): int = VarDecl(Value(2)) |
    Value(4): int = Call(Fun(488), []) |entry
    Value(4): int = Assign(Value(3)) |entry
    Return(Some(Value(3))) |


function u0:0(i64, i64) -> i64 fast {
    sig0 = () -> i64 fast
    fn0 = colocated u0:28 sig0

block0(v0: i64, v1: i64):
    v5 = iconst.i64 0
    v3 -> v5
    v2 = iconst.i64 0
    v4 = call fn0()
    return v4
}


fun print(s: &Self, value: &u8)

  Inst1[Value(0), Value(1)]
    Value(2): int = Lit(Int(0, 0)) |0
    Value(3): int = VarDecl(Value(2)) |i = 0
    Jump(Inst(4), []) |loop:
      let value = *((value as int + i) as &u8)
      if value == 0u8:
        break
      i += 1

  Inst4[]
    Value(4): int = Cast(Value(1)) |value as int
    Value(5): int = Call(Fun(260), [Value(4), Value(3)]) |(value as int + i)
    Value(6): &u8 = Cast(Value(5)) |((value as int + i) as &u8)
    Value(7): u8 = Deref(Value(6), false) |*((value as int + i) as &u8)
    Value(8): u8 = VarDecl(Value(7)) |value = *((value as int + i) as &u8)
    Value(9): u8 = Lit(Uint(0, 8)) |0u8
    Value(10): bool = Call(Fun(306), [Value(8), Value(9)]) |value == 0u8
    JumpIfTrue(Value(10), Inst(15), []) |value == 0u8
    Jump(Inst(17), []) |

  Inst15[]
    Jump(Inst(5), []) |break

  Inst17[]
    Value(11): int = Lit(Int(1, 0)) |1
    Value(12): int = Call(Fun(260), [Value(3), Value(11)]) |i += 1
    Value(12): int = Assign(Value(3)) |i += 1
    Jump(Inst(4), []) |loop:
      let value = *((value as int + i) as &u8)
      if value == 0u8:
        break
      i += 1

  Inst5[]
    Call(Fun(473), [Value(0), Value(3)]) |s.reserve(i)
    Value(14): &Seq[u8] = Offset(Value(0)) |s.len
    Value(15): Seq[u8] = Deref(Value(14), false) |s.len
    Value(13): int = Offset(Value(15)) |s.len
    Value(16): &u8 = Call(Fun(474), [Value(0), Value(13)]) |s.get_unchecked(s.len)
    Call(Fun(442), [Value(16), Value(1), Value(3)]) |memcpy(s.get_unchecked(s.len), value, i)
    Value(18): &Seq[u8] = Offset(Value(0)) |s.len
    Value(19): Seq[u8] = Deref(Value(18), false) |s.len
    Value(17): int = Offset(Value(19)) |s.len
    Value(21): &Seq[u8] = Offset(Value(0)) |s.len
    Value(22): Seq[u8] = Deref(Value(21), false) |s.len
    Value(20): int = Offset(Value(22)) |s.len
    Value(23): int = Call(Fun(260), [Value(20), Value(3)]) |s.len += i
    Value(23): int = Assign(Value(17)) |s.len += i
    Return(None) |s.len += i


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 2460..2495 }, line_data: LineData { line: 128, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64) fast {
    sig0 = (i64, i64) -> i64 windows_fastcall
    sig1 = (i64, i64, i64) windows_fastcall
    fn0 = u0:26 sig0
    fn1 = u0:22 sig1

block0(v0: i64, v1: i64):
    v32 = iconst.i64 0
    v3 -> v32
    v2 = iconst.i64 0
    jump block1(v2)

block1(v4: i64):
    v10 -> v4
    v12 -> v4
    v29 -> v4
    v33 -> v4
    v5 = iadd.i64 v1, v4
    v6 = load.i8 v5
    v7 = iconst.i8 0
    v8 = icmp eq v6, v7
    brnz v8, block2
    jump block3

block2:
    jump block4

block3:
    v9 = iconst.i64 1
    v11 = iadd.i64 v10, v9
    jump block1(v11)

block4:
    jump block5(v0, v12)

block5(v13: i64, v14: i64):
    v15 = load.i64 v13+16
    v16 = icmp sgt v15, v14
    brnz v16, block6
    jump block7

block6:
    jump block8

block7:
    v17 = iconst.i64 1
    v18 = imul.i64 v14, v17
    v19 = load.i64 v13
    v20 = call fn0(v19, v18)
    store v20, v13
    store.i64 v14, v13+16
    jump block8

block8:
    v21 = load.i64 v0+8
    jump block9(v0, v21)

block9(v22: i64, v23: i64):
    v25 = iconst.i64 1
    v26 = imul v23, v25
    v27 = load.i64 v22
    v28 = iadd v27, v26
    jump block10(v28)

block10(v24: i64):
    call fn1(v24, v1, v29)
    v30 = load.i64 v0+8
    v31 = iadd v30, v29
    store v31, v0+8
    return
}

fun sizeof[T] -> int


fun print_int(s: &Self, value: int)

  Inst1[Value(0), Value(1)]
    Value(2): int = VarDecl(Value(1)) |value = value
    Jump(Inst(3), []) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())

  Inst3[]
    Value(3): int = Lit(Int(0, 0)) |0
    Value(4): bool = Call(Fun(310), [Value(2), Value(3)]) |value == 0
    JumpIfTrue(Value(4), Inst(9), []) |value == 0
    Jump(Inst(11), []) |

  Inst9[]
    Jump(Inst(4), []) |break

  Inst11[]
    Value(5): int = Lit(Int(10, 0)) |10
    Value(6): int = Call(Fun(300), [Value(2), Value(5)]) |value % 10
    Value(7): int = VarDecl(Value(6)) |digit = value % 10
    Value(8): int = Lit(Int(10, 0)) |10
    Value(9): int = Call(Fun(290), [Value(2), Value(8)]) |value / 10
    Value(9): int = Assign(Value(2)) |value = value / 10
    Value(10): u32 = Call(Fun(96), [Value(7)]) |digit.u32()
    Value(11): i32 = Lit(Char('0')) |'0'
    Value(12): u32 = Call(Fun(258), [Value(10), Value(11)]) |(
    Value(13): u8 = Call(Fun(63), [Value(12)]) |(digit.u32() + '0').u8()
    Call(Fun(476), [Value(0), Value(13)]) |s.push((digit.u32() + '0').u8())
    Jump(Inst(3), []) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())

  Inst4[]
    Return(None) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64) fast {
    gv0 = symbol colocated u1:1
    gv1 = symbol colocated u1:2
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 windows_fastcall
    sig2 = (i64) fast
    fn0 = colocated u0:19 sig0
    fn1 = u0:26 sig1
    fn2 = colocated u0:19 sig2

block0(v0: i64, v1: i64):
    v58 = iconst.i64 0
    v57 -> v58
    v54 = iconst.i64 0
    v2 -> v54
    jump block1(v1, v57)

block1(v4: i64, v56: i64):
    v7 -> v4
    v9 -> v56
    v3 = iconst.i64 0
    v5 = icmp eq v4, v3
    brnz v5, block2
    jump block3

block2:
    jump block4

block3:
    v6 = iconst.i64 10
    v8 = srem.i64 v7, v6
    v63 -> v8
    v66 -> v8
    v67 -> v8
    v61 -> v63
    v59 -> v61
    v10 = iconst.i64 10
    v11 = sdiv.i64 v7, v10
    v62 -> v11
    v64 -> v11
    v65 -> v11
    v60 -> v62
    v55 -> v60
    v12 = ireduce.i32 v8
    v13 = iconst.i32 48
    v14 = iadd v12, v13
    v15 = ireduce.i8 v14
    jump block5(v0, v15)

block5(v16: i64, v17: i8):
    v18 = global_value.i64 gv0
    call fn0(v18)
    v19 = iconst.i64 1
    v20 = load.i64 v16+8
    v21 = iadd v20, v19
    v22 = load.i64 v16+16
    v23 = icmp sgt v21, v22
    brnz v23, block6
    jump block7

block6:
    v24 = iconst.i64 2
    v25 = load.i64 v16+16
    v26 = imul v25, v24
    store v26, v16+16
    v27 = iconst.i64 1
    v28 = load.i64 v16+16
    v29 = imul v28, v27
    v30 = load.i64 v16
    v31 = call fn1(v30, v29)
    store v31, v16
    jump block7

block7:
    v32 = load.i64 v16+8
    jump block9(v16, v32)

block9(v33: i64, v34: i64):
    jump block11(v33, v34)

block11(v36: i64, v37: i64):
    jump block15(v36, v37)

block15(v38: i64, v39: i64):
    v41 = iconst.i64 0
    v42 = icmp sge v39, v41
    v43 = load.i64 v38+8
    v44 = icmp slt v39, v43
    v45 = band v42, v44
    jump block16(v45)

block16(v40: b1):
    brnz v40, block12
    jump block13

block12:
    v46 = global_value.i64 gv1
    call fn2(v46)
    jump block13

block13:
    jump block14

block14:
    jump block17(v33, v34)

block17(v47: i64, v48: i64):
    v50 = iconst.i64 1
    v51 = imul v48, v50
    v52 = load.i64 v47
    v53 = iadd v52, v51
    jump block18(v53)

block18(v49: i64):
    jump block10(v49)

block10(v35: i64):
    store.i8 v17, v35
    store.i64 v21, v16+8
    jump block8

block8:
    jump block1(v55, v59)

block4:
    return
}

fun pop_frame

  Inst1[]
    Value(0): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(2): &Seq[StackFrame] = Ref(Value(0)) |stacktrace.pop()
    Value(1): Option[StackFrame] = Call(Fun(480), [Value(2), Value(1)]) |stacktrace.pop()
    Return(None) |stacktrace.pop()


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3455..3485 }, line_data: LineData { line: 171, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4453..4479 }, line_data: LineData { line: 212, column: 3, source: Source(1) } }
function u0:0() fast {
    ss0 = explicit_slot 32
    ss1 = explicit_slot 24
    ss2 = explicit_slot 32
    ss3 = explicit_slot 32
    gv0 = symbol colocated u1:0

block0:
    v0 = global_value.i64 gv0
    v1 = stack_addr.i64 ss0
    jump block1(v0, v1)

block1(v2: i64, v3: i64):
    v5 = iconst.i64 0
    v6 = load.i64 v2+8
    v7 = icmp eq v6, v5
    brnz v7, block2
    jump block3

block2:
    v8 = iconst.i64 0
    store v8, v3
    store v8, v3+8
    store v8, v3+16
    store v8, v3+24
    jump block4(v3)

block3:
    v9 = iconst.i64 1
    v10 = load.i64 v2+8
    v11 = isub v10, v9
    jump block5(v2, v11)

block5(v12: i64, v13: i64):
    v15 = iconst.i64 24
    v16 = imul v13, v15
    v17 = load.i64 v12
    v18 = iadd v17, v16
    jump block6(v18)

block6(v14: i64):
    v19 = stack_addr.i64 ss1
    v20 = load.i64 v14
    store v20, v19
    v21 = load.i64 v14+8
    store v21, v19+8
    v22 = load.i64 v14+16
    store v22, v19+16
    v23 = iconst.i64 1
    v24 = load.i64 v2+8
    v25 = isub v24, v23
    store v25, v2+8
    v26 = stack_addr.i64 ss1
    v27 = stack_addr.i64 ss2
    jump block7(v26, v27)

block7(v28: i64, v29: i64):
    v31 = iconst.i64 0
    stack_store v31, ss3
    stack_store v31, ss3+8
    stack_store v31, ss3+16
    stack_store v31, ss3+24
    stack_store v28, ss3
    v32 = bconst.b1 true
    v33 = bint.i8 v32
    stack_store v33, ss3+24
    v34 = stack_addr.i64 ss3
    v35 = load.i64 v34
    store v35, v29
    v36 = load.i64 v34+8
    store v36, v29+8
    v37 = load.i64 v34+16
    store v37, v29+16
    v38 = load.i64 v34+24
    store v38, v29+24
    jump block8(v29)

block8(v30: i64):
    v39 = load.i64 v30
    store v39, v3
    v40 = load.i64 v30+8
    store v40, v3+8
    v41 = load.i64 v30+16
    store v41, v3+16
    v42 = load.i64 v30+24
    store v42, v3+24
    jump block4(v3)

block4(v4: i64):
    return
}

fun sizeof[T] -> int


fun push_frame(line, column: int, file: &u8)

  Inst1[Value(0), Value(1), Value(2)]
    Value(3): StackFrame = Zeroed |frame: StackFrame
    Value(4): StackFrame = VarDecl(Value(3)) |frame: StackFrame
    Value(5): int = Offset(Value(4)) |frame.line
    Value(0): int = Assign(Value(5)) |frame.line = line
    Value(6): int = Offset(Value(4)) |frame.column
    Value(1): int = Assign(Value(6)) |frame.column = column
    Value(7): &u8 = Offset(Value(4)) |frame.file
    Value(2): &u8 = Assign(Value(7)) |frame.file = file
    Value(8): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(9): &Seq[StackFrame] = Ref(Value(8)) |stacktrace.push(frame)
    Call(Fun(484), [Value(9), Value(4)]) |stacktrace.push(frame)
    Return(None) |stacktrace.push(frame)


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64, i64) fast {
    ss0 = explicit_slot 24
    gv0 = symbol colocated u1:0
    gv1 = symbol colocated u1:1
    gv2 = symbol colocated u1:2
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 windows_fastcall
    sig2 = (i64) fast
    fn0 = colocated u0:19 sig0
    fn1 = u0:26 sig1
    fn2 = colocated u0:19 sig2

block0(v0: i64, v1: i64, v2: i64):
    v3 = iconst.i64 0
    stack_store v3, ss0
    stack_store v3, ss0+8
    stack_store v3, ss0+16
    stack_store v0, ss0
    stack_store v1, ss0+8
    stack_store v2, ss0+16
    v4 = global_value.i64 gv0
    v5 = stack_addr.i64 ss0
    jump block1(v4, v5)

block1(v6: i64, v7: i64):
    v8 = global_value.i64 gv1
    call fn0(v8)
    v9 = iconst.i64 1
    v10 = load.i64 v6+8
    v11 = iadd v10, v9
    v12 = load.i64 v6+16
    v13 = icmp sgt v11, v12
    brnz v13, block2
    jump block3

block2:
    v14 = iconst.i64 2
    v15 = load.i64 v6+16
    v16 = imul v15, v14
    store v16, v6+16
    v17 = iconst.i64 24
    v18 = load.i64 v6+16
    v19 = imul v18, v17
    v20 = load.i64 v6
    v21 = call fn1(v20, v19)
    store v21, v6
    jump block3

block3:
    v22 = load.i64 v6+8
    jump block5(v6, v22)

block5(v23: i64, v24: i64):
    jump block7(v23, v24)

block7(v26: i64, v27: i64):
    jump block11(v26, v27)

block11(v28: i64, v29: i64):
    v31 = iconst.i64 0
    v32 = icmp sge v29, v31
    v33 = load.i64 v28+8
    v34 = icmp slt v29, v33
    v35 = band v32, v34
    jump block12(v35)

block12(v30: b1):
    brnz v30, block8
    jump block9

block8:
    v36 = global_value.i64 gv2
    call fn2(v36)
    jump block9

block9:
    jump block10

block10:
    jump block13(v23, v24)

block13(v37: i64, v38: i64):
    v40 = iconst.i64 24
    v41 = imul v38, v40
    v42 = load.i64 v37
    v43 = iadd v42, v41
    jump block14(v43)

block14(v39: i64):
    jump block6(v39)

block6(v25: i64):
    v44 = load.i64 v7
    store v44, v25
    v45 = load.i64 v7+8
    store v45, v25+8
    v46 = load.i64 v7+16
    store v46, v25+16
    store.i64 v11, v6+8
    jump block4

block4:
    return
}

fun panic(str: &u8)

  Inst1[Value(0)]
    Value(1): &u8 = Lit(String(Spam { source: Source(0), hash: ID(13499977805273881313), range: 135..159 })) |"panic: "
    Call(Fun(443), [Value(1)]) |print("panic: ")
    Call(Fun(443), [Value(0)]) |print(str)
    Value(2): &u8 = Lit(String(Spam { source: Source(0), hash: ID(10606491740656731085), range: 185..213 })) |"\n"
    Call(Fun(443), [Value(2)]) |print("\n")
    Value(3): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(4): int = Offset(Value(3)) |stacktrace.len
    Value(5): int = Lit(Int(0, 0)) |0
    Value(6): bool = Call(Fun(310), [Value(4), Value(5)]) |stacktrace.len == 0
    JumpIfTrue(Value(6), Inst(11), []) |stacktrace.len == 0
    Jump(Inst(13), []) |

  Inst11[]
    Value(7): &u8 = Lit(String(Spam { source: Source(0), hash: ID(9851784588597441741), range: 316..494 })) |"no stacktrace available, use '-trace' when building to generate stactrace\n"
    Call(Fun(443), [Value(7)]) |print("no stacktrace available, use '-trace' when building to generate stactrace\n")
    Value(8): int = Lit(Int(1, 0)) |1
    Call(Fun(444), [Value(8)]) |exit(1)
    Return(None) |return

  Inst13[]
    Value(9): Seq[u8] = Zeroed |buffer: Seq[u8]
    Value(10): Seq[u8] = VarDecl(Value(9)) |buffer: Seq[u8]
    Value(11): int = Zeroed |i: int
    Value(12): int = VarDecl(Value(11)) |i: int
    Jump(Inst(26), []) |loop:
    if i >= stacktrace.len:
      break
    
    var frame = stacktrace[i]
    
    buffer.print_int(frame.line)
    buffer.push(':'.u8())
    buffer.print_int(frame.column)
    buffer.push(' '.u8())
    buffer.print(frame.file)
    buffer.push('\n'.u8())

  Inst26[]
    Value(13): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(14): int = Offset(Value(13)) |stacktrace.len
    Value(15): bool = Call(Fun(330), [Value(12), Value(14)]) |i >= stacktrace.len
    JumpIfTrue(Value(15), Inst(33), []) |i >= stacktrace.len
    Jump(Inst(35), []) |

  Inst33[]
    Jump(Inst(27), []) |break

  Inst35[]
    Value(16): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(18): &Seq[StackFrame] = Ref(Value(16)) |stacktrace[i]
    Value(17): &StackFrame = Call(Fun(485), [Value(18), Value(12)]) |stacktrace[i]
    Value(19): StackFrame = Deref(Value(17), false) |stacktrace[i]
    Value(20): StackFrame = VarDecl(Value(19)) |frame = stacktrace[i]
    Value(21): int = Offset(Value(20)) |frame.line
    Value(22): &Seq[u8] = Ref(Value(10)) |buffer.print_int(frame.line)
    Call(Fun(452), [Value(22), Value(21)]) |buffer.print_int(frame.line)
    Value(23): i32 = Lit(Char(':')) |':'
    Value(24): u8 = Call(Fun(59), [Value(23)]) |':'.u8()
    Value(25): &Seq[u8] = Ref(Value(10)) |buffer.push(':'.u8())
    Call(Fun(476), [Value(25), Value(24)]) |buffer.push(':'.u8())
    Value(26): int = Offset(Value(20)) |frame.column
    Value(27): &Seq[u8] = Ref(Value(10)) |buffer.print_int(frame.column)
    Call(Fun(452), [Value(27), Value(26)]) |buffer.print_int(frame.column)
    Value(28): i32 = Lit(Char(' ')) |' '
    Value(29): u8 = Call(Fun(59), [Value(28)]) |' '.u8()
    Value(30): &Seq[u8] = Ref(Value(10)) |buffer.push(' '.u8())
    Call(Fun(476), [Value(30), Value(29)]) |buffer.push(' '.u8())
    Value(31): &u8 = Offset(Value(20)) |frame.file
    Value(32): &Seq[u8] = Ref(Value(10)) |buffer.print(frame.file)
    Call(Fun(453), [Value(32), Value(31)]) |buffer.print(frame.file)
    Value(33): i32 = Lit(Char('\n')) |'\n'
    Value(34): u8 = Call(Fun(59), [Value(33)]) |'\n'.u8()
    Value(35): &Seq[u8] = Ref(Value(10)) |buffer.push('\n'.u8())
    Call(Fun(476), [Value(35), Value(34)]) |buffer.push('\n'.u8())
    Jump(Inst(26), []) |loop:
    if i >= stacktrace.len:
      break
    
    var frame = stacktrace[i]
    
    buffer.print_int(frame.line)
    buffer.push(':'.u8())
    buffer.print_int(frame.column)
    buffer.push(' '.u8())
    buffer.print(frame.file)
    buffer.push('\n'.u8())

  Inst27[]
    Value(36): i32 = Lit(Char('\u{0}')) |'\x00'
    Value(37): u8 = Call(Fun(59), [Value(36)]) |'\x00'.u8()
    Value(38): &Seq[u8] = Ref(Value(10)) |buffer.push('\x00'.u8())
    Call(Fun(476), [Value(38), Value(37)]) |buffer.push('\x00'.u8())
    Value(39): &u8 = Offset(Value(10)) |buffer.data
    Call(Fun(443), [Value(39)]) |print(buffer.data)
    Value(40): int = Lit(Int(1, 0)) |1
    Call(Fun(444), [Value(40)]) |exit(1)
    Return(None) |exit(1)


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64) fast {
    ss0 = explicit_slot 24
    ss1 = explicit_slot 24
    gv0 = symbol colocated u1:3
    gv1 = symbol colocated u1:4
    gv2 = symbol colocated u1:0
    gv3 = symbol colocated u1:5
    gv4 = symbol colocated u1:0
    gv5 = symbol colocated u1:0
    gv6 = symbol colocated u1:2
    gv7 = symbol colocated u1:1
    gv8 = symbol colocated u1:2
    gv9 = symbol colocated u1:1
    gv10 = symbol colocated u1:2
    gv11 = symbol colocated u1:1
    gv12 = symbol colocated u1:2
    gv13 = symbol colocated u1:1
    gv14 = symbol colocated u1:2
    sig0 = (i64) windows_fastcall
    sig1 = (i64) windows_fastcall
    sig2 = (i64) windows_fastcall
    sig3 = (i64) windows_fastcall
    sig4 = (i64) windows_fastcall
    sig5 = (i64) fast
    sig6 = (i64, i64) fast
    sig7 = (i64) fast
    sig8 = (i64, i64) -> i64 windows_fastcall
    sig9 = (i64) fast
    sig10 = (i64, i64) fast
    sig11 = (i64) fast
    sig12 = (i64, i64) -> i64 windows_fastcall
    sig13 = (i64) fast
    sig14 = (i64, i64) fast
    sig15 = (i64) fast
    sig16 = (i64, i64) -> i64 windows_fastcall
    sig17 = (i64) fast
    sig18 = (i64) fast
    sig19 = (i64, i64) -> i64 windows_fastcall
    sig20 = (i64) fast
    sig21 = (i64) windows_fastcall
    sig22 = (i64) windows_fastcall
    fn0 = u0:21 sig0
    fn1 = u0:21 sig1
    fn2 = u0:21 sig2
    fn3 = u0:21 sig3
    fn4 = u0:20 sig4
    fn5 = colocated u0:19 sig5
    fn6 = colocated u0:4 sig6
    fn7 = colocated u0:19 sig7
    fn8 = u0:26 sig8
    fn9 = colocated u0:19 sig9
    fn10 = colocated u0:4 sig10
    fn11 = colocated u0:19 sig11
    fn12 = u0:26 sig12
    fn13 = colocated u0:19 sig13
    fn14 = colocated u0:0 sig14
    fn15 = colocated u0:19 sig15
    fn16 = u0:26 sig16
    fn17 = colocated u0:19 sig17
    fn18 = colocated u0:19 sig18
    fn19 = u0:26 sig19
    fn20 = colocated u0:19 sig20
    fn21 = u0:21 sig21
    fn22 = u0:20 sig22

block0(v0: i64):
    v216 = iconst.i64 0
    v11 -> v216
    v215 -> v216
    v1 = global_value.i64 gv0
    call fn0(v1)
    call fn1(v0)
    v2 = global_value.i64 gv1
    call fn2(v2)
    v3 = global_value.i64 gv2
    v4 = iconst.i64 0
    v5 = load.i64 v3+8
    v6 = icmp eq v5, v4
    brnz v6, block1
    jump block2

block1:
    v7 = global_value.i64 gv3
    call fn3(v7)
    v8 = iconst.i64 1
    call fn4(v8)
    return

block2:
    v9 = iconst.i64 0
    stack_store v9, ss0
    stack_store v9, ss0+8
    stack_store v9, ss0+16
    v10 = iconst.i64 0
    jump block3(v10)

block3(v13: i64):
    v17 -> v13
    v219 -> v13
    v220 -> v13
    v221 -> v13
    v222 -> v13
    v223 -> v13
    v224 -> v13
    v225 -> v13
    v226 -> v13
    v218 -> v219
    v217 -> v218
    v12 = global_value.i64 gv4
    v14 = load.i64 v12+8
    v15 = icmp sge v13, v14
    brnz v15, block4
    jump block5

block4:
    jump block6

block5:
    v16 = global_value.i64 gv5
    jump block7(v16, v17)

block7(v18: i64, v19: i64):
    jump block9(v18, v19)

block9(v21: i64, v22: i64):
    jump block13(v21, v22)

block13(v23: i64, v24: i64):
    v26 = iconst.i64 0
    v27 = icmp sge v24, v26
    v28 = load.i64 v23+8
    v29 = icmp slt v24, v28
    v30 = band v27, v29
    jump block14(v30)

block14(v25: b1):
    brnz v25, block10
    jump block11

block10:
    v31 = global_value.i64 gv6
    call fn5(v31)
    jump block11

block11:
    jump block12

block12:
    jump block15(v18, v19)

block15(v32: i64, v33: i64):
    v35 = iconst.i64 24
    v36 = imul v33, v35
    v37 = load.i64 v32
    v38 = iadd v37, v36
    jump block16(v38)

block16(v34: i64):
    jump block8(v34)

block8(v20: i64):
    v39 = stack_addr.i64 ss1
    v40 = load.i64 v20
    store v40, v39
    v41 = load.i64 v20+8
    store v41, v39+8
    v42 = load.i64 v20+16
    store v42, v39+16
    v43 = stack_addr.i64 ss0
    v44 = stack_load.i64 ss1
    call fn6(v43, v44)
    v45 = iconst.i32 58
    v46 = ireduce.i8 v45
    v47 = stack_addr.i64 ss0
    jump block17(v47, v46)

block17(v48: i64, v49: i8):
    v50 = global_value.i64 gv7
    call fn7(v50)
    v51 = iconst.i64 1
    v52 = load.i64 v48+8
    v53 = iadd v52, v51
    v54 = load.i64 v48+16
    v55 = icmp sgt v53, v54
    brnz v55, block18
    jump block19

block18:
    v56 = iconst.i64 2
    v57 = load.i64 v48+16
    v58 = imul v57, v56
    store v58, v48+16
    v59 = iconst.i64 1
    v60 = load.i64 v48+16
    v61 = imul v60, v59
    v62 = load.i64 v48
    v63 = call fn8(v62, v61)
    store v63, v48
    jump block19

block19:
    v64 = load.i64 v48+8
    jump block21(v48, v64)

block21(v65: i64, v66: i64):
    jump block23(v65, v66)

block23(v68: i64, v69: i64):
    jump block27(v68, v69)

block27(v70: i64, v71: i64):
    v73 = iconst.i64 0
    v74 = icmp sge v71, v73
    v75 = load.i64 v70+8
    v76 = icmp slt v71, v75
    v77 = band v74, v76
    jump block28(v77)

block28(v72: b1):
    brnz v72, block24
    jump block25

block24:
    v78 = global_value.i64 gv8
    call fn9(v78)
    jump block25

block25:
    jump block26

block26:
    jump block29(v65, v66)

block29(v79: i64, v80: i64):
    v82 = iconst.i64 1
    v83 = imul v80, v82
    v84 = load.i64 v79
    v85 = iadd v84, v83
    jump block30(v85)

block30(v81: i64):
    jump block22(v81)

block22(v67: i64):
    store.i8 v49, v67
    store.i64 v53, v48+8
    jump block20

block20:
    v86 = stack_addr.i64 ss0
    v87 = stack_load.i64 ss1+8
    call fn10(v86, v87)
    v88 = iconst.i32 32
    v89 = ireduce.i8 v88
    v90 = stack_addr.i64 ss0
    jump block31(v90, v89)

block31(v91: i64, v92: i8):
    v93 = global_value.i64 gv9
    call fn11(v93)
    v94 = iconst.i64 1
    v95 = load.i64 v91+8
    v96 = iadd v95, v94
    v97 = load.i64 v91+16
    v98 = icmp sgt v96, v97
    brnz v98, block32
    jump block33

block32:
    v99 = iconst.i64 2
    v100 = load.i64 v91+16
    v101 = imul v100, v99
    store v101, v91+16
    v102 = iconst.i64 1
    v103 = load.i64 v91+16
    v104 = imul v103, v102
    v105 = load.i64 v91
    v106 = call fn12(v105, v104)
    store v106, v91
    jump block33

block33:
    v107 = load.i64 v91+8
    jump block35(v91, v107)

block35(v108: i64, v109: i64):
    jump block37(v108, v109)

block37(v111: i64, v112: i64):
    jump block41(v111, v112)

block41(v113: i64, v114: i64):
    v116 = iconst.i64 0
    v117 = icmp sge v114, v116
    v118 = load.i64 v113+8
    v119 = icmp slt v114, v118
    v120 = band v117, v119
    jump block42(v120)

block42(v115: b1):
    brnz v115, block38
    jump block39

block38:
    v121 = global_value.i64 gv10
    call fn13(v121)
    jump block39

block39:
    jump block40

block40:
    jump block43(v108, v109)

block43(v122: i64, v123: i64):
    v125 = iconst.i64 1
    v126 = imul v123, v125
    v127 = load.i64 v122
    v128 = iadd v127, v126
    jump block44(v128)

block44(v124: i64):
    jump block36(v124)

block36(v110: i64):
    store.i8 v92, v110
    store.i64 v96, v91+8
    jump block34

block34:
    v129 = stack_addr.i64 ss0
    v130 = stack_load.i64 ss1+16
    call fn14(v129, v130)
    v131 = iconst.i32 10
    v132 = ireduce.i8 v131
    v133 = stack_addr.i64 ss0
    jump block45(v133, v132)

block45(v134: i64, v135: i8):
    v136 = global_value.i64 gv11
    call fn15(v136)
    v137 = iconst.i64 1
    v138 = load.i64 v134+8
    v139 = iadd v138, v137
    v140 = load.i64 v134+16
    v141 = icmp sgt v139, v140
    brnz v141, block46
    jump block47

block46:
    v142 = iconst.i64 2
    v143 = load.i64 v134+16
    v144 = imul v143, v142
    store v144, v134+16
    v145 = iconst.i64 1
    v146 = load.i64 v134+16
    v147 = imul v146, v145
    v148 = load.i64 v134
    v149 = call fn16(v148, v147)
    store v149, v134
    jump block47

block47:
    v150 = load.i64 v134+8
    jump block49(v134, v150)

block49(v151: i64, v152: i64):
    jump block51(v151, v152)

block51(v154: i64, v155: i64):
    jump block55(v154, v155)

block55(v156: i64, v157: i64):
    v159 = iconst.i64 0
    v160 = icmp sge v157, v159
    v161 = load.i64 v156+8
    v162 = icmp slt v157, v161
    v163 = band v160, v162
    jump block56(v163)

block56(v158: b1):
    brnz v158, block52
    jump block53

block52:
    v164 = global_value.i64 gv12
    call fn17(v164)
    jump block53

block53:
    jump block54

block54:
    jump block57(v151, v152)

block57(v165: i64, v166: i64):
    v168 = iconst.i64 1
    v169 = imul v166, v168
    v170 = load.i64 v165
    v171 = iadd v170, v169
    jump block58(v171)

block58(v167: i64):
    jump block50(v167)

block50(v153: i64):
    store.i8 v135, v153
    store.i64 v139, v134+8
    jump block48

block48:
    jump block3(v217)

block6:
    v172 = iconst.i32 0
    v173 = ireduce.i8 v172
    v174 = stack_addr.i64 ss0
    jump block59(v174, v173)

block59(v175: i64, v176: i8):
    v177 = global_value.i64 gv13
    call fn18(v177)
    v178 = iconst.i64 1
    v179 = load.i64 v175+8
    v180 = iadd v179, v178
    v181 = load.i64 v175+16
    v182 = icmp sgt v180, v181
    brnz v182, block60
    jump block61

block60:
    v183 = iconst.i64 2
    v184 = load.i64 v175+16
    v185 = imul v184, v183
    store v185, v175+16
    v186 = iconst.i64 1
    v187 = load.i64 v175+16
    v188 = imul v187, v186
    v189 = load.i64 v175
    v190 = call fn19(v189, v188)
    store v190, v175
    jump block61

block61:
    v191 = load.i64 v175+8
    jump block63(v175, v191)

block63(v192: i64, v193: i64):
    jump block65(v192, v193)

block65(v195: i64, v196: i64):
    jump block69(v195, v196)

block69(v197: i64, v198: i64):
    v200 = iconst.i64 0
    v201 = icmp sge v198, v200
    v202 = load.i64 v197+8
    v203 = icmp slt v198, v202
    v204 = band v201, v203
    jump block70(v204)

block70(v199: b1):
    brnz v199, block66
    jump block67

block66:
    v205 = global_value.i64 gv14
    call fn20(v205)
    jump block67

block67:
    jump block68

block68:
    jump block71(v192, v193)

block71(v206: i64, v207: i64):
    v209 = iconst.i64 1
    v210 = imul v207, v209
    v211 = load.i64 v206
    v212 = iadd v211, v210
    jump block72(v212)

block72(v208: i64):
    jump block64(v208)

block64(v194: i64):
    store.i8 v176, v194
    store.i64 v180, v175+8
    jump block62

block62:
    v213 = stack_load.i64 ss0
    call fn21(v213)
    v214 = iconst.i64 1
    call fn22(v214)
    return
}

fun exit(code: int)


fun print(str: &u8)


fun memcpy(dest: &u8, src: &u8, size: int)


fun memmove(dest: &u8, src: &u8, size: int)


fun memset(ptr: &u8, value: u8, size: int)


fun free(ptr: &u8)


fun realloc(ptr: &u8, size: int) -> &u8


fun alloc(size: int) -> &u8


fun main -> int

  Inst1[]
    Value(0): int = Lit(Int(1, 0)) |1
    Value(1): int = Lit(Int(1, 0)) |1
    Value(2): bool = Call(Fun(310), [Value(0), Value(1)]) |1 == 1
    JumpIfTrue(Value(2), Inst(5), []) |1 == 1
    Jump(Inst(8), []) |:

  Inst5[]
    Value(3): int = Lit(Int(0, 0)) |0
    Jump(Inst(7), [Value(3)]) |if 1 == 1: 0 else: 1

  Inst8[]
    Value(5): int = Lit(Int(1, 0)) |1
    Jump(Inst(7), [Value(5)]) |1

  Inst7[Value(4)]
    Return(Some(Value(4))) |return if 1 == 1: 0 else: 1


function u0:0() -> i64 fast {
block0:
    v1 = iconst.i64 1
    v2 = iconst.i64 1
    v3 = icmp eq v1, v2
    brnz v3, block1
    jump block2

block1:
    v4 = iconst.i64 0
    jump block3(v4)

block2:
    v5 = iconst.i64 1
    jump block3(v5)

block3(v0: i64):
    return v0
}



  Inst1[Value(0), Value(1)]
    Value(2): int = Zeroed |
    Value(3): int = VarDecl(Value(2)) |
    Value(4): int = Call(Fun(488), []) |entry
    Value(4): int = Assign(Value(3)) |entry
    Return(Some(Value(3))) |


function u0:0(i64, i64) -> i64 fast {
    sig0 = () -> i64 fast
    fn0 = colocated u0:28 sig0

block0(v0: i64, v1: i64):
    v5 = iconst.i64 0
    v3 -> v5
    v2 = iconst.i64 0
    v4 = call fn0()
    return v4
}


fun print(s: &Self, value: &u8)

  Inst1[Value(0), Value(1)]
    Value(2): int = Lit(Int(0, 0)) |0
    Value(3): int = VarDecl(Value(2)) |i = 0
    Jump(Inst(4), []) |loop:
      let value = *((value as int + i) as &u8)
      if value == 0u8:
        break
      i += 1

  Inst4[]
    Value(4): int = Cast(Value(1)) |value as int
    Value(5): int = Call(Fun(260), [Value(4), Value(3)]) |(value as int + i)
    Value(6): &u8 = Cast(Value(5)) |((value as int + i) as &u8)
    Value(7): u8 = Deref(Value(6), false) |*((value as int + i) as &u8)
    Value(8): u8 = VarDecl(Value(7)) |value = *((value as int + i) as &u8)
    Value(9): u8 = Lit(Uint(0, 8)) |0u8
    Value(10): bool = Call(Fun(306), [Value(8), Value(9)]) |value == 0u8
    JumpIfTrue(Value(10), Inst(15), []) |value == 0u8
    Jump(Inst(17), []) |

  Inst15[]
    Jump(Inst(5), []) |break

  Inst17[]
    Value(11): int = Lit(Int(1, 0)) |1
    Value(12): int = Call(Fun(260), [Value(3), Value(11)]) |i += 1
    Value(12): int = Assign(Value(3)) |i += 1
    Jump(Inst(4), []) |loop:
      let value = *((value as int + i) as &u8)
      if value == 0u8:
        break
      i += 1

  Inst5[]
    Call(Fun(473), [Value(0), Value(3)]) |s.reserve(i)
    Value(14): &Seq[u8] = Offset(Value(0)) |s.len
    Value(15): Seq[u8] = Deref(Value(14), false) |s.len
    Value(13): int = Offset(Value(15)) |s.len
    Value(16): &u8 = Call(Fun(474), [Value(0), Value(13)]) |s.get_unchecked(s.len)
    Call(Fun(442), [Value(16), Value(1), Value(3)]) |memcpy(s.get_unchecked(s.len), value, i)
    Value(18): &Seq[u8] = Offset(Value(0)) |s.len
    Value(19): Seq[u8] = Deref(Value(18), false) |s.len
    Value(17): int = Offset(Value(19)) |s.len
    Value(21): &Seq[u8] = Offset(Value(0)) |s.len
    Value(22): Seq[u8] = Deref(Value(21), false) |s.len
    Value(20): int = Offset(Value(22)) |s.len
    Value(23): int = Call(Fun(260), [Value(20), Value(3)]) |s.len += i
    Value(23): int = Assign(Value(17)) |s.len += i
    Return(None) |s.len += i


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 2460..2495 }, line_data: LineData { line: 128, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64) fast {
    sig0 = (i64, i64) -> i64 windows_fastcall
    sig1 = (i64, i64, i64) windows_fastcall
    fn0 = u0:26 sig0
    fn1 = u0:22 sig1

block0(v0: i64, v1: i64):
    v32 = iconst.i64 0
    v3 -> v32
    v2 = iconst.i64 0
    jump block1(v2)

block1(v4: i64):
    v10 -> v4
    v12 -> v4
    v29 -> v4
    v33 -> v4
    v5 = iadd.i64 v1, v4
    v6 = load.i8 v5
    v7 = iconst.i8 0
    v8 = icmp eq v6, v7
    brnz v8, block2
    jump block3

block2:
    jump block4

block3:
    v9 = iconst.i64 1
    v11 = iadd.i64 v10, v9
    jump block1(v11)

block4:
    jump block5(v0, v12)

block5(v13: i64, v14: i64):
    v15 = load.i64 v13+16
    v16 = icmp sgt v15, v14
    brnz v16, block6
    jump block7

block6:
    jump block8

block7:
    v17 = iconst.i64 1
    v18 = imul.i64 v14, v17
    v19 = load.i64 v13
    v20 = call fn0(v19, v18)
    store v20, v13
    store.i64 v14, v13+16
    jump block8

block8:
    v21 = load.i64 v0+8
    jump block9(v0, v21)

block9(v22: i64, v23: i64):
    v25 = iconst.i64 1
    v26 = imul v23, v25
    v27 = load.i64 v22
    v28 = iadd v27, v26
    jump block10(v28)

block10(v24: i64):
    call fn1(v24, v1, v29)
    v30 = load.i64 v0+8
    v31 = iadd v30, v29
    store v31, v0+8
    return
}

fun sizeof[T] -> int


fun print_int(s: &Self, value: int)

  Inst1[Value(0), Value(1)]
    Value(2): int = VarDecl(Value(1)) |value = value
    Jump(Inst(3), []) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())

  Inst3[]
    Value(3): int = Lit(Int(0, 0)) |0
    Value(4): bool = Call(Fun(310), [Value(2), Value(3)]) |value == 0
    JumpIfTrue(Value(4), Inst(9), []) |value == 0
    Jump(Inst(11), []) |

  Inst9[]
    Jump(Inst(4), []) |break

  Inst11[]
    Value(5): int = Lit(Int(10, 0)) |10
    Value(6): int = Call(Fun(300), [Value(2), Value(5)]) |value % 10
    Value(7): int = VarDecl(Value(6)) |digit = value % 10
    Value(8): int = Lit(Int(10, 0)) |10
    Value(9): int = Call(Fun(290), [Value(2), Value(8)]) |value / 10
    Value(9): int = Assign(Value(2)) |value = value / 10
    Value(10): u32 = Call(Fun(96), [Value(7)]) |digit.u32()
    Value(11): i32 = Lit(Char('0')) |'0'
    Value(12): u32 = Call(Fun(258), [Value(10), Value(11)]) |(
    Value(13): u8 = Call(Fun(63), [Value(12)]) |(digit.u32() + '0').u8()
    Call(Fun(476), [Value(0), Value(13)]) |s.push((digit.u32() + '0').u8())
    Jump(Inst(3), []) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())

  Inst4[]
    Return(None) |loop:
      if value == 0:
        break
      var digit = value % 10
      value = value / 10
      s.push((digit.u32() + '0').u8())


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64) fast {
    gv0 = symbol colocated u1:1
    gv1 = symbol colocated u1:2
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 windows_fastcall
    sig2 = (i64) fast
    fn0 = colocated u0:19 sig0
    fn1 = u0:26 sig1
    fn2 = colocated u0:19 sig2

block0(v0: i64, v1: i64):
    v58 = iconst.i64 0
    v57 -> v58
    v54 = iconst.i64 0
    v2 -> v54
    jump block1(v1, v57)

block1(v4: i64, v56: i64):
    v7 -> v4
    v9 -> v56
    v3 = iconst.i64 0
    v5 = icmp eq v4, v3
    brnz v5, block2
    jump block3

block2:
    jump block4

block3:
    v6 = iconst.i64 10
    v8 = srem.i64 v7, v6
    v63 -> v8
    v66 -> v8
    v67 -> v8
    v61 -> v63
    v59 -> v61
    v10 = iconst.i64 10
    v11 = sdiv.i64 v7, v10
    v62 -> v11
    v64 -> v11
    v65 -> v11
    v60 -> v62
    v55 -> v60
    v12 = ireduce.i32 v8
    v13 = iconst.i32 48
    v14 = iadd v12, v13
    v15 = ireduce.i8 v14
    jump block5(v0, v15)

block5(v16: i64, v17: i8):
    v18 = global_value.i64 gv0
    call fn0(v18)
    v19 = iconst.i64 1
    v20 = load.i64 v16+8
    v21 = iadd v20, v19
    v22 = load.i64 v16+16
    v23 = icmp sgt v21, v22
    brnz v23, block6
    jump block7

block6:
    v24 = iconst.i64 2
    v25 = load.i64 v16+16
    v26 = imul v25, v24
    store v26, v16+16
    v27 = iconst.i64 1
    v28 = load.i64 v16+16
    v29 = imul v28, v27
    v30 = load.i64 v16
    v31 = call fn1(v30, v29)
    store v31, v16
    jump block7

block7:
    v32 = load.i64 v16+8
    jump block9(v16, v32)

block9(v33: i64, v34: i64):
    jump block11(v33, v34)

block11(v36: i64, v37: i64):
    jump block15(v36, v37)

block15(v38: i64, v39: i64):
    v41 = iconst.i64 0
    v42 = icmp sge v39, v41
    v43 = load.i64 v38+8
    v44 = icmp slt v39, v43
    v45 = band v42, v44
    jump block16(v45)

block16(v40: b1):
    brnz v40, block12
    jump block13

block12:
    v46 = global_value.i64 gv1
    call fn2(v46)
    jump block13

block13:
    jump block14

block14:
    jump block17(v33, v34)

block17(v47: i64, v48: i64):
    v50 = iconst.i64 1
    v51 = imul v48, v50
    v52 = load.i64 v47
    v53 = iadd v52, v51
    jump block18(v53)

block18(v49: i64):
    jump block10(v49)

block10(v35: i64):
    store.i8 v17, v35
    store.i64 v21, v16+8
    jump block8

block8:
    jump block1(v55, v59)

block4:
    return
}

fun pop_frame

  Inst1[]
    Value(0): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(2): &Seq[StackFrame] = Ref(Value(0)) |stacktrace.pop()
    Value(1): Option[StackFrame] = Call(Fun(480), [Value(2), Value(1)]) |stacktrace.pop()
    Return(None) |stacktrace.pop()


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3455..3485 }, line_data: LineData { line: 171, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4453..4479 }, line_data: LineData { line: 212, column: 3, source: Source(1) } }
function u0:0() fast {
    ss0 = explicit_slot 32
    ss1 = explicit_slot 24
    ss2 = explicit_slot 32
    ss3 = explicit_slot 32
    gv0 = symbol colocated u1:0

block0:
    v0 = global_value.i64 gv0
    v1 = stack_addr.i64 ss0
    jump block1(v0, v1)

block1(v2: i64, v3: i64):
    v5 = iconst.i64 0
    v6 = load.i64 v2+8
    v7 = icmp eq v6, v5
    brnz v7, block2
    jump block3

block2:
    v8 = iconst.i64 0
    store v8, v3
    store v8, v3+8
    store v8, v3+16
    store v8, v3+24
    jump block4(v3)

block3:
    v9 = iconst.i64 1
    v10 = load.i64 v2+8
    v11 = isub v10, v9
    jump block5(v2, v11)

block5(v12: i64, v13: i64):
    v15 = iconst.i64 24
    v16 = imul v13, v15
    v17 = load.i64 v12
    v18 = iadd v17, v16
    jump block6(v18)

block6(v14: i64):
    v19 = stack_addr.i64 ss1
    v20 = load.i64 v14
    store v20, v19
    v21 = load.i64 v14+8
    store v21, v19+8
    v22 = load.i64 v14+16
    store v22, v19+16
    v23 = iconst.i64 1
    v24 = load.i64 v2+8
    v25 = isub v24, v23
    store v25, v2+8
    v26 = stack_addr.i64 ss1
    v27 = stack_addr.i64 ss2
    jump block7(v26, v27)

block7(v28: i64, v29: i64):
    v31 = iconst.i64 0
    stack_store v31, ss3
    stack_store v31, ss3+8
    stack_store v31, ss3+16
    stack_store v31, ss3+24
    stack_store v28, ss3
    v32 = bconst.b1 true
    v33 = bint.i8 v32
    stack_store v33, ss3+24
    v34 = stack_addr.i64 ss3
    v35 = load.i64 v34
    store v35, v29
    v36 = load.i64 v34+8
    store v36, v29+8
    v37 = load.i64 v34+16
    store v37, v29+16
    v38 = load.i64 v34+24
    store v38, v29+24
    jump block8(v29)

block8(v30: i64):
    v39 = load.i64 v30
    store v39, v3
    v40 = load.i64 v30+8
    store v40, v3+8
    v41 = load.i64 v30+16
    store v41, v3+16
    v42 = load.i64 v30+24
    store v42, v3+24
    jump block4(v3)

block4(v4: i64):
    return
}

fun sizeof[T] -> int


fun push_frame(line, column: int, file: &u8)

  Inst1[Value(0), Value(1), Value(2)]
    Value(3): StackFrame = Zeroed |frame: StackFrame
    Value(4): StackFrame = VarDecl(Value(3)) |frame: StackFrame
    Value(5): int = Offset(Value(4)) |frame.line
    Value(0): int = Assign(Value(5)) |frame.line = line
    Value(6): int = Offset(Value(4)) |frame.column
    Value(1): int = Assign(Value(6)) |frame.column = column
    Value(7): &u8 = Offset(Value(4)) |frame.file
    Value(2): &u8 = Assign(Value(7)) |frame.file = file
    Value(8): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(9): &Seq[StackFrame] = Ref(Value(8)) |stacktrace.push(frame)
    Call(Fun(484), [Value(9), Value(4)]) |stacktrace.push(frame)
    Return(None) |stacktrace.push(frame)


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64, i64, i64) fast {
    ss0 = explicit_slot 24
    gv0 = symbol colocated u1:0
    gv1 = symbol colocated u1:1
    gv2 = symbol colocated u1:2
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 windows_fastcall
    sig2 = (i64) fast
    fn0 = colocated u0:19 sig0
    fn1 = u0:26 sig1
    fn2 = colocated u0:19 sig2

block0(v0: i64, v1: i64, v2: i64):
    v3 = iconst.i64 0
    stack_store v3, ss0
    stack_store v3, ss0+8
    stack_store v3, ss0+16
    stack_store v0, ss0
    stack_store v1, ss0+8
    stack_store v2, ss0+16
    v4 = global_value.i64 gv0
    v5 = stack_addr.i64 ss0
    jump block1(v4, v5)

block1(v6: i64, v7: i64):
    v8 = global_value.i64 gv1
    call fn0(v8)
    v9 = iconst.i64 1
    v10 = load.i64 v6+8
    v11 = iadd v10, v9
    v12 = load.i64 v6+16
    v13 = icmp sgt v11, v12
    brnz v13, block2
    jump block3

block2:
    v14 = iconst.i64 2
    v15 = load.i64 v6+16
    v16 = imul v15, v14
    store v16, v6+16
    v17 = iconst.i64 24
    v18 = load.i64 v6+16
    v19 = imul v18, v17
    v20 = load.i64 v6
    v21 = call fn1(v20, v19)
    store v21, v6
    jump block3

block3:
    v22 = load.i64 v6+8
    jump block5(v6, v22)

block5(v23: i64, v24: i64):
    jump block7(v23, v24)

block7(v26: i64, v27: i64):
    jump block11(v26, v27)

block11(v28: i64, v29: i64):
    v31 = iconst.i64 0
    v32 = icmp sge v29, v31
    v33 = load.i64 v28+8
    v34 = icmp slt v29, v33
    v35 = band v32, v34
    jump block12(v35)

block12(v30: b1):
    brnz v30, block8
    jump block9

block8:
    v36 = global_value.i64 gv2
    call fn2(v36)
    jump block9

block9:
    jump block10

block10:
    jump block13(v23, v24)

block13(v37: i64, v38: i64):
    v40 = iconst.i64 24
    v41 = imul v38, v40
    v42 = load.i64 v37
    v43 = iadd v42, v41
    jump block14(v43)

block14(v39: i64):
    jump block6(v39)

block6(v25: i64):
    v44 = load.i64 v7
    store v44, v25
    v45 = load.i64 v7+8
    store v45, v25+8
    v46 = load.i64 v7+16
    store v46, v25+16
    store.i64 v11, v6+8
    jump block4

block4:
    return
}

fun panic(str: &u8)

  Inst1[Value(0)]
    Value(1): &u8 = Lit(String(Spam { source: Source(0), hash: ID(13499977805273881313), range: 135..159 })) |"panic: "
    Call(Fun(443), [Value(1)]) |print("panic: ")
    Call(Fun(443), [Value(0)]) |print(str)
    Value(2): &u8 = Lit(String(Spam { source: Source(0), hash: ID(10606491740656731085), range: 185..213 })) |"\n"
    Call(Fun(443), [Value(2)]) |print("\n")
    Value(3): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(4): int = Offset(Value(3)) |stacktrace.len
    Value(5): int = Lit(Int(0, 0)) |0
    Value(6): bool = Call(Fun(310), [Value(4), Value(5)]) |stacktrace.len == 0
    JumpIfTrue(Value(6), Inst(11), []) |stacktrace.len == 0
    Jump(Inst(13), []) |

  Inst11[]
    Value(7): &u8 = Lit(String(Spam { source: Source(0), hash: ID(9851784588597441741), range: 316..494 })) |"no stacktrace available, use '-trace' when building to generate stactrace\n"
    Call(Fun(443), [Value(7)]) |print("no stacktrace available, use '-trace' when building to generate stactrace\n")
    Value(8): int = Lit(Int(1, 0)) |1
    Call(Fun(444), [Value(8)]) |exit(1)
    Return(None) |return

  Inst13[]
    Value(9): Seq[u8] = Zeroed |buffer: Seq[u8]
    Value(10): Seq[u8] = VarDecl(Value(9)) |buffer: Seq[u8]
    Value(11): int = Zeroed |i: int
    Value(12): int = VarDecl(Value(11)) |i: int
    Jump(Inst(26), []) |loop:
    if i >= stacktrace.len:
      break
    
    var frame = stacktrace[i]
    
    buffer.print_int(frame.line)
    buffer.push(':'.u8())
    buffer.print_int(frame.column)
    buffer.push(' '.u8())
    buffer.print(frame.file)
    buffer.push('\n'.u8())

  Inst26[]
    Value(13): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(14): int = Offset(Value(13)) |stacktrace.len
    Value(15): bool = Call(Fun(330), [Value(12), Value(14)]) |i >= stacktrace.len
    JumpIfTrue(Value(15), Inst(33), []) |i >= stacktrace.len
    Jump(Inst(35), []) |

  Inst33[]
    Jump(Inst(27), []) |break

  Inst35[]
    Value(16): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(18): &Seq[StackFrame] = Ref(Value(16)) |stacktrace[i]
    Value(17): &StackFrame = Call(Fun(485), [Value(18), Value(12)]) |stacktrace[i]
    Value(19): StackFrame = Deref(Value(17), false) |stacktrace[i]
    Value(20): StackFrame = VarDecl(Value(19)) |frame = stacktrace[i]
    Value(21): int = Offset(Value(20)) |frame.line
    Value(22): &Seq[u8] = Ref(Value(10)) |buffer.print_int(frame.line)
    Call(Fun(452), [Value(22), Value(21)]) |buffer.print_int(frame.line)
    Value(23): i32 = Lit(Char(':')) |':'
    Value(24): u8 = Call(Fun(59), [Value(23)]) |':'.u8()
    Value(25): &Seq[u8] = Ref(Value(10)) |buffer.push(':'.u8())
    Call(Fun(476), [Value(25), Value(24)]) |buffer.push(':'.u8())
    Value(26): int = Offset(Value(20)) |frame.column
    Value(27): &Seq[u8] = Ref(Value(10)) |buffer.print_int(frame.column)
    Call(Fun(452), [Value(27), Value(26)]) |buffer.print_int(frame.column)
    Value(28): i32 = Lit(Char(' ')) |' '
    Value(29): u8 = Call(Fun(59), [Value(28)]) |' '.u8()
    Value(30): &Seq[u8] = Ref(Value(10)) |buffer.push(' '.u8())
    Call(Fun(476), [Value(30), Value(29)]) |buffer.push(' '.u8())
    Value(31): &u8 = Offset(Value(20)) |frame.file
    Value(32): &Seq[u8] = Ref(Value(10)) |buffer.print(frame.file)
    Call(Fun(453), [Value(32), Value(31)]) |buffer.print(frame.file)
    Value(33): i32 = Lit(Char('\n')) |'\n'
    Value(34): u8 = Call(Fun(59), [Value(33)]) |'\n'.u8()
    Value(35): &Seq[u8] = Ref(Value(10)) |buffer.push('\n'.u8())
    Call(Fun(476), [Value(35), Value(34)]) |buffer.push('\n'.u8())
    Jump(Inst(26), []) |loop:
    if i >= stacktrace.len:
      break
    
    var frame = stacktrace[i]
    
    buffer.print_int(frame.line)
    buffer.push(':'.u8())
    buffer.print_int(frame.column)
    buffer.push(' '.u8())
    buffer.print(frame.file)
    buffer.push('\n'.u8())

  Inst27[]
    Value(36): i32 = Lit(Char('\u{0}')) |'\x00'
    Value(37): u8 = Call(Fun(59), [Value(36)]) |'\x00'.u8()
    Value(38): &Seq[u8] = Ref(Value(10)) |buffer.push('\x00'.u8())
    Call(Fun(476), [Value(38), Value(37)]) |buffer.push('\x00'.u8())
    Value(39): &u8 = Offset(Value(10)) |buffer.data
    Call(Fun(443), [Value(39)]) |print(buffer.data)
    Value(40): int = Lit(Int(1, 0)) |1
    Call(Fun(444), [Value(40)]) |exit(1)
    Return(None) |exit(1)


Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3208..3236 }, line_data: LineData { line: 161, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 3735..3776 }, line_data: LineData { line: 183, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4133..4175 }, line_data: LineData { line: 195, column: 4, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4248..4291 }, line_data: LineData { line: 199, column: 3, source: Source(1) } }
Token { kind: Fun, spam: Spam { source: Source(1), hash: ID(438937012895), range: 4027..4072 }, line_data: LineData { line: 192, column: 3, source: Source(1) } }
function u0:0(i64) fast {
    ss0 = explicit_slot 24
    ss1 = explicit_slot 24
    gv0 = symbol colocated u1:3
    gv1 = symbol colocated u1:4
    gv2 = symbol colocated u1:0
    gv3 = symbol colocated u1:5
    gv4 = symbol colocated u1:0
    gv5 = symbol colocated u1:0
    gv6 = symbol colocated u1:2
    gv7 = symbol colocated u1:1
    gv8 = symbol colocated u1:2
    gv9 = symbol colocated u1:1
    gv10 = symbol colocated u1:2
    gv11 = symbol colocated u1:1
    gv12 = symbol colocated u1:2
    gv13 = symbol colocated u1:1
    gv14 = symbol colocated u1:2
    sig0 = (i64) windows_fastcall
    sig1 = (i64) windows_fastcall
    sig2 = (i64) windows_fastcall
    sig3 = (i64) windows_fastcall
    sig4 = (i64) windows_fastcall
    sig5 = (i64) fast
    sig6 = (i64, i64) fast
    sig7 = (i64) fast
    sig8 = (i64, i64) -> i64 windows_fastcall
    sig9 = (i64) fast
    sig10 = (i64, i64) fast
    sig11 = (i64) fast
    sig12 = (i64, i64) -> i64 windows_fastcall
    sig13 = (i64) fast
    sig14 = (i64, i64) fast
    sig15 = (i64) fast
    sig16 = (i64, i64) -> i64 windows_fastcall
    sig17 = (i64) fast
    sig18 = (i64) fast
    sig19 = (i64, i64) -> i64 windows_fastcall
    sig20 = (i64) fast
    sig21 = (i64) windows_fastcall
    sig22 = (i64) windows_fastcall
    fn0 = u0:21 sig0
    fn1 = u0:21 sig1
    fn2 = u0:21 sig2
    fn3 = u0:21 sig3
    fn4 = u0:20 sig4
    fn5 = colocated u0:19 sig5
    fn6 = colocated u0:4 sig6
    fn7 = colocated u0:19 sig7
    fn8 = u0:26 sig8
    fn9 = colocated u0:19 sig9
    fn10 = colocated u0:4 sig10
    fn11 = colocated u0:19 sig11
    fn12 = u0:26 sig12
    fn13 = colocated u0:19 sig13
    fn14 = colocated u0:0 sig14
    fn15 = colocated u0:19 sig15
    fn16 = u0:26 sig16
    fn17 = colocated u0:19 sig17
    fn18 = colocated u0:19 sig18
    fn19 = u0:26 sig19
    fn20 = colocated u0:19 sig20
    fn21 = u0:21 sig21
    fn22 = u0:20 sig22

block0(v0: i64):
    v216 = iconst.i64 0
    v11 -> v216
    v215 -> v216
    v1 = global_value.i64 gv0
    call fn0(v1)
    call fn1(v0)
    v2 = global_value.i64 gv1
    call fn2(v2)
    v3 = global_value.i64 gv2
    v4 = iconst.i64 0
    v5 = load.i64 v3+8
    v6 = icmp eq v5, v4
    brnz v6, block1
    jump block2

block1:
    v7 = global_value.i64 gv3
    call fn3(v7)
    v8 = iconst.i64 1
    call fn4(v8)
    return

block2:
    v9 = iconst.i64 0
    stack_store v9, ss0
    stack_store v9, ss0+8
    stack_store v9, ss0+16
    v10 = iconst.i64 0
    jump block3(v10)

block3(v13: i64):
    v17 -> v13
    v219 -> v13
    v220 -> v13
    v221 -> v13
    v222 -> v13
    v223 -> v13
    v224 -> v13
    v225 -> v13
    v226 -> v13
    v218 -> v219
    v217 -> v218
    v12 = global_value.i64 gv4
    v14 = load.i64 v12+8
    v15 = icmp sge v13, v14
    brnz v15, block4
    jump block5

block4:
    jump block6

block5:
    v16 = global_value.i64 gv5
    jump block7(v16, v17)

block7(v18: i64, v19: i64):
    jump block9(v18, v19)

block9(v21: i64, v22: i64):
    jump block13(v21, v22)

block13(v23: i64, v24: i64):
    v26 = iconst.i64 0
    v27 = icmp sge v24, v26
    v28 = load.i64 v23+8
    v29 = icmp slt v24, v28
    v30 = band v27, v29
    jump block14(v30)

block14(v25: b1):
    brnz v25, block10
    jump block11

block10:
    v31 = global_value.i64 gv6
    call fn5(v31)
    jump block11

block11:
    jump block12

block12:
    jump block15(v18, v19)

block15(v32: i64, v33: i64):
    v35 = iconst.i64 24
    v36 = imul v33, v35
    v37 = load.i64 v32
    v38 = iadd v37, v36
    jump block16(v38)

block16(v34: i64):
    jump block8(v34)

block8(v20: i64):
    v39 = stack_addr.i64 ss1
    v40 = load.i64 v20
    store v40, v39
    v41 = load.i64 v20+8
    store v41, v39+8
    v42 = load.i64 v20+16
    store v42, v39+16
    v43 = stack_addr.i64 ss0
    v44 = stack_load.i64 ss1
    call fn6(v43, v44)
    v45 = iconst.i32 58
    v46 = ireduce.i8 v45
    v47 = stack_addr.i64 ss0
    jump block17(v47, v46)

block17(v48: i64, v49: i8):
    v50 = global_value.i64 gv7
    call fn7(v50)
    v51 = iconst.i64 1
    v52 = load.i64 v48+8
    v53 = iadd v52, v51
    v54 = load.i64 v48+16
    v55 = icmp sgt v53, v54
    brnz v55, block18
    jump block19

block18:
    v56 = iconst.i64 2
    v57 = load.i64 v48+16
    v58 = imul v57, v56
    store v58, v48+16
    v59 = iconst.i64 1
    v60 = load.i64 v48+16
    v61 = imul v60, v59
    v62 = load.i64 v48
    v63 = call fn8(v62, v61)
    store v63, v48
    jump block19

block19:
    v64 = load.i64 v48+8
    jump block21(v48, v64)

block21(v65: i64, v66: i64):
    jump block23(v65, v66)

block23(v68: i64, v69: i64):
    jump block27(v68, v69)

block27(v70: i64, v71: i64):
    v73 = iconst.i64 0
    v74 = icmp sge v71, v73
    v75 = load.i64 v70+8
    v76 = icmp slt v71, v75
    v77 = band v74, v76
    jump block28(v77)

block28(v72: b1):
    brnz v72, block24
    jump block25

block24:
    v78 = global_value.i64 gv8
    call fn9(v78)
    jump block25

block25:
    jump block26

block26:
    jump block29(v65, v66)

block29(v79: i64, v80: i64):
    v82 = iconst.i64 1
    v83 = imul v80, v82
    v84 = load.i64 v79
    v85 = iadd v84, v83
    jump block30(v85)

block30(v81: i64):
    jump block22(v81)

block22(v67: i64):
    store.i8 v49, v67
    store.i64 v53, v48+8
    jump block20

block20:
    v86 = stack_addr.i64 ss0
    v87 = stack_load.i64 ss1+8
    call fn10(v86, v87)
    v88 = iconst.i32 32
    v89 = ireduce.i8 v88
    v90 = stack_addr.i64 ss0
    jump block31(v90, v89)

block31(v91: i64, v92: i8):
    v93 = global_value.i64 gv9
    call fn11(v93)
    v94 = iconst.i64 1
    v95 = load.i64 v91+8
    v96 = iadd v95, v94
    v97 = load.i64 v91+16
    v98 = icmp sgt v96, v97
    brnz v98, block32
    jump block33

block32:
    v99 = iconst.i64 2
    v100 = load.i64 v91+16
    v101 = imul v100, v99
    store v101, v91+16
    v102 = iconst.i64 1
    v103 = load.i64 v91+16
    v104 = imul v103, v102
    v105 = load.i64 v91
    v106 = call fn12(v105, v104)
    store v106, v91
    jump block33

block33:
    v107 = load.i64 v91+8
    jump block35(v91, v107)

block35(v108: i64, v109: i64):
    jump block37(v108, v109)

block37(v111: i64, v112: i64):
    jump block41(v111, v112)

block41(v113: i64, v114: i64):
    v116 = iconst.i64 0
    v117 = icmp sge v114, v116
    v118 = load.i64 v113+8
    v119 = icmp slt v114, v118
    v120 = band v117, v119
    jump block42(v120)

block42(v115: b1):
    brnz v115, block38
    jump block39

block38:
    v121 = global_value.i64 gv10
    call fn13(v121)
    jump block39

block39:
    jump block40

block40:
    jump block43(v108, v109)

block43(v122: i64, v123: i64):
    v125 = iconst.i64 1
    v126 = imul v123, v125
    v127 = load.i64 v122
    v128 = iadd v127, v126
    jump block44(v128)

block44(v124: i64):
    jump block36(v124)

block36(v110: i64):
    store.i8 v92, v110
    store.i64 v96, v91+8
    jump block34

block34:
    v129 = stack_addr.i64 ss0
    v130 = stack_load.i64 ss1+16
    call fn14(v129, v130)
    v131 = iconst.i32 10
    v132 = ireduce.i8 v131
    v133 = stack_addr.i64 ss0
    jump block45(v133, v132)

block45(v134: i64, v135: i8):
    v136 = global_value.i64 gv11
    call fn15(v136)
    v137 = iconst.i64 1
    v138 = load.i64 v134+8
    v139 = iadd v138, v137
    v140 = load.i64 v134+16
    v141 = icmp sgt v139, v140
    brnz v141, block46
    jump block47

block46:
    v142 = iconst.i64 2
    v143 = load.i64 v134+16
    v144 = imul v143, v142
    store v144, v134+16
    v145 = iconst.i64 1
    v146 = load.i64 v134+16
    v147 = imul v146, v145
    v148 = load.i64 v134
    v149 = call fn16(v148, v147)
    store v149, v134
    jump block47

block47:
    v150 = load.i64 v134+8
    jump block49(v134, v150)

block49(v151: i64, v152: i64):
    jump block51(v151, v152)

block51(v154: i64, v155: i64):
    jump block55(v154, v155)

block55(v156: i64, v157: i64):
    v159 = iconst.i64 0
    v160 = icmp sge v157, v159
    v161 = load.i64 v156+8
    v162 = icmp slt v157, v161
    v163 = band v160, v162
    jump block56(v163)

block56(v158: b1):
    brnz v158, block52
    jump block53

block52:
    v164 = global_value.i64 gv12
    call fn17(v164)
    jump block53

block53:
    jump block54

block54:
    jump block57(v151, v152)

block57(v165: i64, v166: i64):
    v168 = iconst.i64 1
    v169 = imul v166, v168
    v170 = load.i64 v165
    v171 = iadd v170, v169
    jump block58(v171)

block58(v167: i64):
    jump block50(v167)

block50(v153: i64):
    store.i8 v135, v153
    store.i64 v139, v134+8
    jump block48

block48:
    jump block3(v217)

block6:
    v172 = iconst.i32 0
    v173 = ireduce.i8 v172
    v174 = stack_addr.i64 ss0
    jump block59(v174, v173)

block59(v175: i64, v176: i8):
    v177 = global_value.i64 gv13
    call fn18(v177)
    v178 = iconst.i64 1
    v179 = load.i64 v175+8
    v180 = iadd v179, v178
    v181 = load.i64 v175+16
    v182 = icmp sgt v180, v181
    brnz v182, block60
    jump block61

block60:
    v183 = iconst.i64 2
    v184 = load.i64 v175+16
    v185 = imul v184, v183
    store v185, v175+16
    v186 = iconst.i64 1
    v187 = load.i64 v175+16
    v188 = imul v187, v186
    v189 = load.i64 v175
    v190 = call fn19(v189, v188)
    store v190, v175
    jump block61

block61:
    v191 = load.i64 v175+8
    jump block63(v175, v191)

block63(v192: i64, v193: i64):
    jump block65(v192, v193)

block65(v195: i64, v196: i64):
    jump block69(v195, v196)

block69(v197: i64, v198: i64):
    v200 = iconst.i64 0
    v201 = icmp sge v198, v200
    v202 = load.i64 v197+8
    v203 = icmp slt v198, v202
    v204 = band v201, v203
    jump block70(v204)

block70(v199: b1):
    brnz v199, block66
    jump block67

block66:
    v205 = global_value.i64 gv14
    call fn20(v205)
    jump block67

block67:
    jump block68

block68:
    jump block71(v192, v193)

block71(v206: i64, v207: i64):
    v209 = iconst.i64 1
    v210 = imul v207, v209
    v211 = load.i64 v206
    v212 = iadd v211, v210
    jump block72(v212)

block72(v208: i64):
    jump block64(v208)

block64(v194: i64):
    store.i8 v176, v194
    store.i64 v180, v175+8
    jump block62

block62:
    v213 = stack_load.i64 ss0
    call fn21(v213)
    v214 = iconst.i64 1
    call fn22(v214)
    return
}

fun exit(code: int)


fun print(str: &u8)


fun memcpy(dest: &u8, src: &u8, size: int)


fun memmove(dest: &u8, src: &u8, size: int)


fun memset(ptr: &u8, value: u8, size: int)


fun free(ptr: &u8)


fun realloc(ptr: &u8, size: int) -> &u8


fun alloc(size: int) -> &u8


fun main -> int

  Inst1[]
    Value(0): int = Lit(Int(10, 0)) |10
    Value(1): int = VarDecl(Value(0)) |v = 10
    Value(3): int = Lit(Int(24, 0)) |fib_loop(v)
    Value(4): int = Lit(Int(10, 0)) |fib_loop(v)
    Value(5): &u8 = Lit(String(Spam { source: Source(0), hash: ID(3362311186304783455), range: 4574..4602 })) |fib_loop(v)
    Call(Fun(446), [Value(3), Value(4), Value(5)]) |fib_loop(v)
    Value(2): int = Call(Fun(489), [Value(1)]) |fib_loop(v)
    Call(Fun(447), []) |fib_loop(v)
    Value(7): int = Lit(Int(24, 0)) |fib(v)
    Value(8): int = Lit(Int(24, 0)) |fib(v)
    Value(9): &u8 = Lit(String(Spam { source: Source(0), hash: ID(3362311186304783455), range: 4602..4630 })) |fib(v)
    Call(Fun(446), [Value(7), Value(8), Value(9)]) |fib(v)
    Value(6): int = Call(Fun(488), [Value(1)]) |fib(v)
    Call(Fun(447), []) |fib(v)
    Value(10): int = Call(Fun(270), [Value(2), Value(6)]) |fib_loop(v) - fib(v)
    Return(Some(Value(10))) |return fib_loop(v) - fib(v)


function u0:0() -> i64 fast {
    gv0 = symbol colocated u1:6
    gv1 = symbol colocated u1:6
    sig0 = (i64, i64, i64) fast
    sig1 = (i64) -> i64 fast
    sig2 = () fast
    sig3 = (i64, i64, i64) fast
    sig4 = (i64) -> i64 fast
    sig5 = () fast
    fn0 = colocated u0:14 sig0
    fn1 = colocated u0:29 sig1
    fn2 = colocated u0:9 sig2
    fn3 = colocated u0:14 sig3
    fn4 = colocated u0:30 sig4
    fn5 = colocated u0:9 sig5

block0:
    v0 = iconst.i64 10
    v1 = iconst.i64 24
    v2 = iconst.i64 10
    v3 = global_value.i64 gv0
    call fn0(v1, v2, v3)
    v4 = call fn1(v0)
    call fn2()
    v5 = iconst.i64 24
    v6 = iconst.i64 24
    v7 = global_value.i64 gv1
    call fn3(v5, v6, v7)
    v8 = call fn4(v0)
    call fn5()
    v9 = isub v4, v8
    return v9
}

fun fib_loop(v: int) -> int

  Inst1[Value(0)]
    Value(1): int = Lit(Int(1, 0)) |1
    Value(2): int = VarDecl(Value(1)) |a, b, c = 1
    Value(3): int = VarDecl(Value(2)) |a, b, c = 1
    Value(4): int = VarDecl(Value(2)) |a, b, c = 1
    Value(5): int = VarDecl(Value(0)) |v = v
    Jump(Inst(7), []) |loop'a:
    c = a + b
    a = b
    b = c
    v = v - 1
    if v == 1:
      break'a

  Inst7[]
    Value(6): int = Call(Fun(260), [Value(2), Value(3)]) |a + b
    Value(6): int = Assign(Value(4)) |c = a + b
    Value(3): int = Assign(Value(2)) |a = b
    Value(4): int = Assign(Value(3)) |b = c
    Value(7): int = Lit(Int(1, 0)) |1
    Value(8): int = Call(Fun(270), [Value(5), Value(7)]) |v - 1
    Value(8): int = Assign(Value(5)) |v = v - 1
    Value(9): int = Lit(Int(1, 0)) |1
    Value(10): bool = Call(Fun(310), [Value(5), Value(9)]) |v == 1
    JumpIfTrue(Value(10), Inst(20), []) |v == 1
    Jump(Inst(22), []) |

  Inst20[]
    Jump(Inst(8), []) |break'a

  Inst22[]
    Jump(Inst(7), []) |loop'a:
    c = a + b
    a = b
    b = c
    v = v - 1
    if v == 1:
      break'a

  Inst8[]
    Return(Some(Value(4))) |return c


function u0:0(i64) -> i64 fast {
block0(v0: i64):
    v19 = iconst.i64 0
    v5 -> v19
    v18 = iconst.i64 0
    v4 -> v18
    v17 = iconst.i64 0
    v3 -> v17
    v16 = iconst.i64 0
    v2 -> v16
    v1 = iconst.i64 1
    jump block1(v1, v1, v1, v0)

block1(v6: i64, v7: i64, v9: i64, v11: i64):
    v20 -> v7
    v8 = iadd v6, v7
    v15 -> v8
    v21 -> v8
    v22 -> v8
    v10 = iconst.i64 1
    v12 = isub v11, v10
    v23 -> v12
    v13 = iconst.i64 1
    v14 = icmp eq v12, v13
    brnz v14, block2
    jump block3

block2:
    jump block4

block3:
    jump block1(v20, v21, v22, v23)

block4:
    return v15
}

fun fib(v: int) -> int

  Inst1[Value(0)]
    Value(1): int = Lit(Int(2, 0)) |2
    Value(2): bool = Call(Fun(360), [Value(0), Value(1)]) |v < 2
    JumpIfTrue(Value(2), Inst(4), []) |v < 2
    Jump(Inst(7), []) |:

  Inst4[]
    Value(3): int = Lit(Int(1, 0)) |1
    Jump(Inst(6), [Value(3)]) |if v < 2:
    1
  else:
    fib(v - 1) + fib(v - 2)

  Inst7[]
    Value(5): int = Lit(Int(1, 0)) |1
    Value(6): int = Call(Fun(270), [Value(0), Value(5)]) |v - 1
    Value(8): int = Lit(Int(6, 0)) |fib(v - 1)
    Value(9): int = Lit(Int(5, 0)) |fib(v - 1)
    Value(10): &u8 = Lit(String(Spam { source: Source(0), hash: ID(3362311186304783455), range: 4630..4658 })) |fib(v - 1)
    Call(Fun(446), [Value(8), Value(9), Value(10)]) |fib(v - 1)
    Value(7): int = Call(Fun(488), [Value(6)]) |fib(v - 1)
    Call(Fun(447), []) |fib(v - 1)
    Value(11): int = Lit(Int(2, 0)) |2
    Value(12): int = Call(Fun(270), [Value(0), Value(11)]) |v - 2
    Value(14): int = Lit(Int(6, 0)) |fib(v - 2)
    Value(15): int = Lit(Int(18, 0)) |fib(v - 2)
    Value(16): &u8 = Lit(String(Spam { source: Source(0), hash: ID(3362311186304783455), range: 4658..4686 })) |fib(v - 2)
    Call(Fun(446), [Value(14), Value(15), Value(16)]) |fib(v - 2)
    Value(13): int = Call(Fun(488), [Value(12)]) |fib(v - 2)
    Call(Fun(447), []) |fib(v - 2)
    Value(17): int = Call(Fun(260), [Value(7), Value(13)]) |fib(v - 1) + fib(v - 2)
    Jump(Inst(6), [Value(17)]) |fib(v - 1) + fib(v - 2)

  Inst6[Value(4)]
    Return(Some(Value(4))) |return if v < 2:
    1
  else:
    fib(v - 1) + fib(v - 2)


function u0:0(i64) -> i64 fast {
    gv0 = symbol colocated u1:6
    gv1 = symbol colocated u1:6
    sig0 = (i64, i64, i64) fast
    sig1 = (i64) -> i64 fast
    sig2 = () fast
    sig3 = (i64, i64, i64) fast
    sig4 = (i64) -> i64 fast
    sig5 = () fast
    fn0 = colocated u0:14 sig0
    fn1 = colocated u0:30 sig1
    fn2 = colocated u0:9 sig2
    fn3 = colocated u0:14 sig3
    fn4 = colocated u0:30 sig4
    fn5 = colocated u0:9 sig5

block0(v0: i64):
    v2 = iconst.i64 2
    v3 = icmp slt v0, v2
    brnz v3, block1
    jump block2

block1:
    v4 = iconst.i64 1
    jump block3(v4)

block2:
    v5 = iconst.i64 1
    v6 = isub.i64 v0, v5
    v7 = iconst.i64 6
    v8 = iconst.i64 5
    v9 = global_value.i64 gv0
    call fn0(v7, v8, v9)
    v10 = call fn1(v6)
    call fn2()
    v11 = iconst.i64 2
    v12 = isub.i64 v0, v11
    v13 = iconst.i64 6
    v14 = iconst.i64 18
    v15 = global_value.i64 gv1
    call fn3(v13, v14, v15)
    v16 = call fn4(v12)
    call fn5()
    v17 = iadd v10, v16
    jump block3(v17)

block3(v1: i64):
    return v1
}



  Inst1[Value(0), Value(1)]
    Value(2): int = Zeroed |
    Value(3): int = VarDecl(Value(2)) |
    Value(4): int = Call(Fun(490), []) |entry
    Value(4): int = Assign(Value(3)) |entry
    Return(Some(Value(3))) |


function u0:0(i64, i64) -> i64 fast {
    sig0 = () -> i64 fast
    fn0 = colocated u0:28 sig0

block0(v0: i64, v1: i64):
    v5 = iconst.i64 0
    v3 -> v5
    v2 = iconst.i64 0
    v4 = call fn0()
    return v4
}

root.mfroot.mfroot.mfroot.mf
