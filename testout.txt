Dummy1
[(Dummy(1), 0)]
0
Dummy(1)
[]
[(Dummy(1), 0)]
Ok(Arguments { _filename: "file", _hash: ID(0), flags: ["flag", "flag"], field_flags: [("flag", "value")], args: ["arg", "arg"] })
Ok(Arguments { _filename: "file", _hash: ID(0), flags: [], field_flags: [], args: ["string value"] })
|> 2:1:text_code.mf
| var something = [1, 2, 3]
| ^
|> 2:4:text_code.mf
| var something = [1, 2, 3]
| ^^^
|> 2:14:text_code.mf
| var something = [1, 2, 3]
|     ^^^^^^^^^
|> 2:16:text_code.mf
| var something = [1, 2, 3]
|               ^
|> 2:18:text_code.mf
| var something = [1, 2, 3]
|                 ^
|> 2:19:text_code.mf
| var something = [1, 2, 3]
|                  ^
|> 2:20:text_code.mf
| var something = [1, 2, 3]
|                   ^
|> 2:22:text_code.mf
| var something = [1, 2, 3]
|                     ^
|> 2:23:text_code.mf
| var something = [1, 2, 3]
|                      ^
|> 2:25:text_code.mf
| var something = [1, 2, 3]
|                        ^
|> 2:26:text_code.mf
| var something = [1, 2, 3]
|                         ^
|> 3:1:text_code.mf
| let hello = "hello"
| ^
|> 3:4:text_code.mf
| let hello = "hello"
| ^^^
|> 3:10:text_code.mf
| let hello = "hello"
|     ^^^^^
|> 3:12:text_code.mf
| let hello = "hello"
|           ^
|> 3:20:text_code.mf
| let hello = "hello"
|             ^^^^^^^
|> 4:2:text_code.mf
| 
| ^
|> 5:1:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
| ^
|> 5:4:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
| ^^^
|> 5:21:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|     ^^^^^^^^^^^^^^^^
|> 5:22:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|                     ^
|> 5:23:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|                      ^
|> 5:24:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|                       ^
|> 5:28:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|                         ^^^
|> 5:29:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|                            ^
|> 5:31:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|                              ^
|> 5:32:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|                               ^
|> 5:36:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|                                 ^^^
|> 5:37:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|                                    ^
|> 5:40:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|                                      ^^
|> 5:44:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|                                         ^^^
|> 5:45:text_code.mf
| fun pointed_function(a: Int, b: Int) -> int:
|                                            ^
|> 6:3:text_code.mf
|   return a + b
| ^^
|> 6:9:text_code.mf
|   return a + b
|   ^^^^^^
|> 6:11:text_code.mf
|   return a + b
|          ^
|> 6:13:text_code.mf
|   return a + b
|            ^
|> 6:15:text_code.mf
|   return a + b
|              ^
|> 7:2:text_code.mf
| 
| ^
|> 8:1:text_code.mf
| ## doc comment
| ^
|> 8:16:text_code.mf
| ## doc comment
| ^^^^^^^^^^^^^^
|> 9:1:text_code.mf
| fun something -> fun(int, int) -> int:
| ^
|> 9:4:text_code.mf
| fun something -> fun(int, int) -> int:
| ^^^
|> 9:14:text_code.mf
| fun something -> fun(int, int) -> int:
|     ^^^^^^^^^
|> 9:17:text_code.mf
| fun something -> fun(int, int) -> int:
|               ^^
|> 9:21:text_code.mf
| fun something -> fun(int, int) -> int:
|                  ^^^
|> 9:22:text_code.mf
| fun something -> fun(int, int) -> int:
|                     ^
|> 9:25:text_code.mf
| fun something -> fun(int, int) -> int:
|                      ^^^
|> 9:26:text_code.mf
| fun something -> fun(int, int) -> int:
|                         ^
|> 9:30:text_code.mf
| fun something -> fun(int, int) -> int:
|                           ^^^
|> 9:31:text_code.mf
| fun something -> fun(int, int) -> int:
|                              ^
|> 9:34:text_code.mf
| fun something -> fun(int, int) -> int:
|                                ^^
|> 9:38:text_code.mf
| fun something -> fun(int, int) -> int:
|                                   ^^^
|> 9:39:text_code.mf
| fun something -> fun(int, int) -> int:
|                                      ^
|> 10:3:text_code.mf
|   # ignored comment
| ^^
|> 11:3:text_code.mf
|   return #[ even more ignored comment ]# pointed_function
| ^^
|> 11:9:text_code.mf
|   return #[ even more ignored comment ]# pointed_function
|   ^^^^^^
|> 11:58:text_code.mf
|   return #[ even more ignored comment ]# pointed_function
|                                          ^^^^^^^^^^^^^^^^
|> 12:2:text_code.mf
| 
| ^
|> 13:1:text_code.mf
| ##[
| ^
|> 15:3:text_code.mf
| ##[
|   multiline doc comment
| ]#
| ^^^^^^^^^^^^^^^^^^^^^^^
|> 16:1:text_code.mf
| struct Scope
| ^
|> 16:7:text_code.mf
| struct Scope
| ^^^^^^
|> 16:13:text_code.mf
| struct Scope
|        ^^^^^
|> 17:2:text_code.mf
| 
| ^
|> 18:1:text_code.mf
| impl Scope:
| ^
|> 18:5:text_code.mf
| impl Scope:
| ^^^^
|> 18:11:text_code.mf
| impl Scope:
|      ^^^^^
|> 18:12:text_code.mf
| impl Scope:
|           ^
|> 19:3:text_code.mf
|   fun new -> Self:
| ^^
|> 19:6:text_code.mf
|   fun new -> Self:
|   ^^^
|> 19:10:text_code.mf
|   fun new -> Self:
|       ^^^
|> 19:13:text_code.mf
|   fun new -> Self:
|           ^^
|> 19:18:text_code.mf
|   fun new -> Self:
|              ^^^^
|> 19:19:text_code.mf
|   fun new -> Self:
|                  ^
|> 20:5:text_code.mf
|     return
| ^^^^
|> 20:11:text_code.mf
|     return
|     ^^^^^^
|> 21:4:text_code.mf
|   
| ^^^
|> 22:3:text_code.mf
|   fun do_nothing(s: Self):
| ^^
|> 22:6:text_code.mf
|   fun do_nothing(s: Self):
|   ^^^
|> 22:17:text_code.mf
|   fun do_nothing(s: Self):
|       ^^^^^^^^^^
|> 22:18:text_code.mf
|   fun do_nothing(s: Self):
|                 ^
|> 22:19:text_code.mf
|   fun do_nothing(s: Self):
|                  ^
|> 22:20:text_code.mf
|   fun do_nothing(s: Self):
|                   ^
|> 22:25:text_code.mf
|   fun do_nothing(s: Self):
|                     ^^^^
|> 22:26:text_code.mf
|   fun do_nothing(s: Self):
|                         ^
|> 22:27:text_code.mf
|   fun do_nothing(s: Self):
|                          ^
|> 23:5:text_code.mf
|     pass
| ^^^^
|> 23:9:text_code.mf
|     pass
|     ^^^^
|> 24:2:text_code.mf
| 
| ^
|> 25:1:text_code.mf
| struct Template[T]
| ^
|> 25:7:text_code.mf
| struct Template[T]
| ^^^^^^
|> 25:16:text_code.mf
| struct Template[T]
|        ^^^^^^^^
|> 25:17:text_code.mf
| struct Template[T]
|                ^
|> 25:18:text_code.mf
| struct Template[T]
|                 ^
|> 25:19:text_code.mf
| struct Template[T]
|                  ^
|> 26:2:text_code.mf
| 
| ^
|> 27:1:text_code.mf
| impl[T] Template[T]:
| ^
|> 27:5:text_code.mf
| impl[T] Template[T]:
| ^^^^
|> 27:6:text_code.mf
| impl[T] Template[T]:
|     ^
|> 27:7:text_code.mf
| impl[T] Template[T]:
|      ^
|> 27:8:text_code.mf
| impl[T] Template[T]:
|       ^
|> 27:17:text_code.mf
| impl[T] Template[T]:
|         ^^^^^^^^
|> 27:18:text_code.mf
| impl[T] Template[T]:
|                 ^
|> 27:19:text_code.mf
| impl[T] Template[T]:
|                  ^
|> 27:20:text_code.mf
| impl[T] Template[T]:
|                   ^
|> 27:21:text_code.mf
| impl[T] Template[T]:
|                    ^
|> 28:3:text_code.mf
|   fun new -> Self:
| ^^
|> 28:6:text_code.mf
|   fun new -> Self:
|   ^^^
|> 28:10:text_code.mf
|   fun new -> Self:
|       ^^^
|> 28:13:text_code.mf
|   fun new -> Self:
|           ^^
|> 28:18:text_code.mf
|   fun new -> Self:
|              ^^^^
|> 28:19:text_code.mf
|   fun new -> Self:
|                  ^
|> 29:5:text_code.mf
|     return
| ^^^^
|> 29:11:text_code.mf
|     return
|     ^^^^^^
|> 30:4:text_code.mf
|   
| ^^^
|> 31:3:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
| ^^
|> 31:6:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|   ^^^
|> 31:17:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|       ^^^^^^^^^^
|> 31:18:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                 ^
|> 31:19:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                  ^
|> 31:20:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                   ^
|> 31:25:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                     ^^^^
|> 31:26:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                         ^
|> 31:32:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                           ^^^^^
|> 31:33:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                                ^
|> 31:35:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                                  ^
|> 31:36:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                                   ^
|> 31:39:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                                     ^^
|> 31:41:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                                        ^
|> 31:42:text_code.mf
|   fun do_nothing(s: Self, value: T) -> T:
|                                         ^
|> 32:5:text_code.mf
|     value
| ^^^^
|> 32:10:text_code.mf
|     value
|     ^^^^^
|> 33:2:text_code.mf
| 
| ^
|> 34:1:text_code.mf
| fun use_chain:
| ^
|> 34:4:text_code.mf
| fun use_chain:
| ^^^
|> 34:14:text_code.mf
| fun use_chain:
|     ^^^^^^^^^
|> 34:15:text_code.mf
| fun use_chain:
|              ^
|> 35:3:text_code.mf
|   module::Type::method::[param]()
| ^^
|> 35:9:text_code.mf
|   module::Type::method::[param]()
|   ^^^^^^
|> 35:11:text_code.mf
|   module::Type::method::[param]()
|         ^^
|> 35:15:text_code.mf
|   module::Type::method::[param]()
|           ^^^^
|> 35:17:text_code.mf
|   module::Type::method::[param]()
|               ^^
|> 35:23:text_code.mf
|   module::Type::method::[param]()
|                 ^^^^^^
|> 35:25:text_code.mf
|   module::Type::method::[param]()
|                       ^^
|> 35:26:text_code.mf
|   module::Type::method::[param]()
|                         ^
|> 35:31:text_code.mf
|   module::Type::method::[param]()
|                          ^^^^^
|> 35:32:text_code.mf
|   module::Type::method::[param]()
|                               ^
|> 35:33:text_code.mf
|   module::Type::method::[param]()
|                                ^
|> 35:34:text_code.mf
|   module::Type::method::[param]()
|                                 ^
|> 36:2:text_code.mf
| 
| ^
|> 37:1:text_code.mf
| fun flo: pass
| ^
|> 37:4:text_code.mf
| fun flo: pass
| ^^^
|> 37:8:text_code.mf
| fun flo: pass
|     ^^^
|> 37:9:text_code.mf
| fun flo: pass
|        ^
|> 37:14:text_code.mf
| fun flo: pass
|          ^^^^
|> 38:2:text_code.mf
| 
| ^
|> 39:1:text_code.mf
| fun foo(): pass
| ^
|> 39:4:text_code.mf
| fun foo(): pass
| ^^^
|> 39:8:text_code.mf
| fun foo(): pass
|     ^^^
|> 39:9:text_code.mf
| fun foo(): pass
|        ^
|> 39:10:text_code.mf
| fun foo(): pass
|         ^
|> 39:11:text_code.mf
| fun foo(): pass
|          ^
|> 39:16:text_code.mf
| fun foo(): pass
|            ^^^^
|> 40:2:text_code.mf
| 
| ^
|> 41:1:text_code.mf
| fun goo(a: i8, b: i8): pass
| ^
|> 41:4:text_code.mf
| fun goo(a: i8, b: i8): pass
| ^^^
|> 41:8:text_code.mf
| fun goo(a: i8, b: i8): pass
|     ^^^
|> 41:9:text_code.mf
| fun goo(a: i8, b: i8): pass
|        ^
|> 41:10:text_code.mf
| fun goo(a: i8, b: i8): pass
|         ^
|> 41:11:text_code.mf
| fun goo(a: i8, b: i8): pass
|          ^
|> 41:14:text_code.mf
| fun goo(a: i8, b: i8): pass
|            ^^
|> 41:15:text_code.mf
| fun goo(a: i8, b: i8): pass
|              ^
|> 41:17:text_code.mf
| fun goo(a: i8, b: i8): pass
|                ^
|> 41:18:text_code.mf
| fun goo(a: i8, b: i8): pass
|                 ^
|> 41:21:text_code.mf
| fun goo(a: i8, b: i8): pass
|                   ^^
|> 41:22:text_code.mf
| fun goo(a: i8, b: i8): pass
|                     ^
|> 41:23:text_code.mf
| fun goo(a: i8, b: i8): pass
|                      ^
|> 41:28:text_code.mf
| fun goo(a: i8, b: i8): pass
|                        ^^^^
|> 42:2:text_code.mf
| 
| ^
|> 43:1:text_code.mf
| fun loo:
| ^
|> 43:4:text_code.mf
| fun loo:
| ^^^
|> 43:8:text_code.mf
| fun loo:
|     ^^^
|> 43:9:text_code.mf
| fun loo:
|        ^
|> 44:3:text_code.mf
|   noo::loo::[i8]()
| ^^
|> 44:6:text_code.mf
|   noo::loo::[i8]()
|   ^^^
|> 44:8:text_code.mf
|   noo::loo::[i8]()
|      ^^
|> 44:11:text_code.mf
|   noo::loo::[i8]()
|        ^^^
|> 44:13:text_code.mf
|   noo::loo::[i8]()
|           ^^
|> 44:14:text_code.mf
|   noo::loo::[i8]()
|             ^
|> 44:16:text_code.mf
|   noo::loo::[i8]()
|              ^^
|> 44:17:text_code.mf
|   noo::loo::[i8]()
|                ^
|> 44:18:text_code.mf
|   noo::loo::[i8]()
|                 ^
|> 44:19:text_code.mf
|   noo::loo::[i8]()
|                  ^
|> 45:2:text_code.mf
| 
| ^
|> 46:3:text_code.mf
|   let array = [1, 2, 3]
| ^^
|> 46:6:text_code.mf
|   let array = [1, 2, 3]
|   ^^^
|> 46:12:text_code.mf
|   let array = [1, 2, 3]
|       ^^^^^
|> 46:14:text_code.mf
|   let array = [1, 2, 3]
|             ^
|> 46:16:text_code.mf
|   let array = [1, 2, 3]
|               ^
|> 46:17:text_code.mf
|   let array = [1, 2, 3]
|                ^
|> 46:18:text_code.mf
|   let array = [1, 2, 3]
|                 ^
|> 46:20:text_code.mf
|   let array = [1, 2, 3]
|                   ^
|> 46:21:text_code.mf
|   let array = [1, 2, 3]
|                    ^
|> 46:23:text_code.mf
|   let array = [1, 2, 3]
|                      ^
|> 46:24:text_code.mf
|   let array = [1, 2, 3]
|                       ^
|> 47:3:text_code.mf
|   array[0] = 3
| ^^
|> 47:8:text_code.mf
|   array[0] = 3
|   ^^^^^
|> 47:9:text_code.mf
|   array[0] = 3
|        ^
|> 47:10:text_code.mf
|   array[0] = 3
|         ^
|> 47:11:text_code.mf
|   array[0] = 3
|          ^
|> 47:13:text_code.mf
|   array[0] = 3
|            ^
|> 47:15:text_code.mf
|   array[0] = 3
|              ^
|> 48:3:text_code.mf
|   array[2] = always[1]
| ^^
|> 48:8:text_code.mf
|   array[2] = always[1]
|   ^^^^^
|> 48:9:text_code.mf
|   array[2] = always[1]
|        ^
|> 48:10:text_code.mf
|   array[2] = always[1]
|         ^
|> 48:11:text_code.mf
|   array[2] = always[1]
|          ^
|> 48:13:text_code.mf
|   array[2] = always[1]
|            ^
|> 48:20:text_code.mf
|   array[2] = always[1]
|              ^^^^^^
|> 48:21:text_code.mf
|   array[2] = always[1]
|                    ^
|> 48:22:text_code.mf
|   array[2] = always[1]
|                     ^
|> 48:23:text_code.mf
|   array[2] = always[1]
|                      ^
|> 49:3:text_code.mf
|   array[1] = 1
| ^^
|> 49:8:text_code.mf
|   array[1] = 1
|   ^^^^^
|> 49:9:text_code.mf
|   array[1] = 1
|        ^
|> 49:10:text_code.mf
|   array[1] = 1
|         ^
|> 49:11:text_code.mf
|   array[1] = 1
|          ^
|> 49:13:text_code.mf
|   array[1] = 1
|            ^
|> 49:15:text_code.mf
|   array[1] = 1
|              ^
|> 50:2:text_code.mf
| 
| ^
|> 51:3:text_code.mf
|   pass
| ^^
|> 51:7:text_code.mf
|   pass
|   ^^^^
|> 52:2:text_code.mf
| 
| ^
|> 53:1:text_code.mf
| fun main -> i64:
| ^
|> 53:4:text_code.mf
| fun main -> i64:
| ^^^
|> 53:9:text_code.mf
| fun main -> i64:
|     ^^^^
|> 53:12:text_code.mf
| fun main -> i64:
|          ^^
|> 53:16:text_code.mf
| fun main -> i64:
|             ^^^
|> 53:17:text_code.mf
| fun main -> i64:
|                ^
|> 54:3:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
| ^^
|> 54:9:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|   ^^^^^^
|> 54:12:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|          ^^
|> 54:14:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|             ^
|> 54:16:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|               ^
|> 54:18:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|                 ^
|> 54:20:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|                   ^
|> 54:22:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|                     ^
|> 54:24:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|                       ^
|> 54:26:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|                         ^
|> 54:28:text_code.mf
|   return 10 + 4 - 2 * 1 + 8
|                           ^
|> 55:2:text_code.mf
| 
| ^
|> 56:1:text_code.mf
| fun operator_stress_test -> i64:
| ^
|> 56:4:text_code.mf
| fun operator_stress_test -> i64:
| ^^^
|> 56:25:text_code.mf
| fun operator_stress_test -> i64:
|     ^^^^^^^^^^^^^^^^^^^^
|> 56:28:text_code.mf
| fun operator_stress_test -> i64:
|                          ^^
|> 56:32:text_code.mf
| fun operator_stress_test -> i64:
|                             ^^^
|> 56:33:text_code.mf
| fun operator_stress_test -> i64:
|                                ^
|> 57:3:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
| ^^
|> 57:9:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|   ^^^^^^
|> 57:12:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|          ^^
|> 57:14:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|             ^
|> 57:16:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|               ^
|> 57:18:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                 ^
|> 57:20:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                   ^
|> 57:22:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                     ^
|> 57:24:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                       ^
|> 57:26:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                         ^
|> 57:28:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                           ^
|> 57:30:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                             ^
|> 57:32:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                               ^
|> 57:34:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                 ^
|> 57:36:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                   ^
|> 57:39:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                     ^^
|> 57:41:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                        ^
|> 57:44:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                          ^^
|> 57:46:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                             ^
|> 57:50:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                               ^^^
|> 57:53:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                                   ^^
|> 57:57:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                                      ^^^
|> 57:60:text_code.mf
|   return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10
|                                                          ^^
|> 58:2:text_code.mf
| 
| ^
|> 59:1:text_code.mf
| fun conditional -> i64:
| ^
|> 59:4:text_code.mf
| fun conditional -> i64:
| ^^^
|> 59:16:text_code.mf
| fun conditional -> i64:
|     ^^^^^^^^^^^
|> 59:19:text_code.mf
| fun conditional -> i64:
|                 ^^
|> 59:23:text_code.mf
| fun conditional -> i64:
|                    ^^^
|> 59:24:text_code.mf
| fun conditional -> i64:
|                       ^
|> 60:3:text_code.mf
|   if false:
| ^^
|> 60:5:text_code.mf
|   if false:
|   ^^
|> 60:11:text_code.mf
|   if false:
|      ^^^^^
|> 60:12:text_code.mf
|   if false:
|           ^
|> 61:5:text_code.mf
|     return 10
| ^^^^
|> 61:11:text_code.mf
|     return 10
|     ^^^^^^
|> 61:14:text_code.mf
|     return 10
|            ^^
|> 62:3:text_code.mf
|   elif true:
| ^^
|> 62:7:text_code.mf
|   elif true:
|   ^^^^
|> 62:12:text_code.mf
|   elif true:
|        ^^^^
|> 62:13:text_code.mf
|   elif true:
|            ^
|> 63:5:text_code.mf
|     return if true: 10 else: 20
| ^^^^
|> 63:11:text_code.mf
|     return if true: 10 else: 20
|     ^^^^^^
|> 63:14:text_code.mf
|     return if true: 10 else: 20
|            ^^
|> 63:19:text_code.mf
|     return if true: 10 else: 20
|               ^^^^
|> 63:20:text_code.mf
|     return if true: 10 else: 20
|                   ^
|> 63:23:text_code.mf
|     return if true: 10 else: 20
|                     ^^
|> 63:28:text_code.mf
|     return if true: 10 else: 20
|                        ^^^^
|> 63:29:text_code.mf
|     return if true: 10 else: 20
|                            ^
|> 63:32:text_code.mf
|     return if true: 10 else: 20
|                              ^^
|> 64:3:text_code.mf
|   else:
| ^^
|> 64:7:text_code.mf
|   else:
|   ^^^^
|> 64:8:text_code.mf
|   else:
|       ^
|> 65:5:text_code.mf
|     return 0
| ^^^^
|> 65:11:text_code.mf
|     return 0
|     ^^^^^^
|> 65:13:text_code.mf
|     return 0
|            ^
|> 66:2:text_code.mf
| 
| ^
|> 67:1:text_code.mf
| attr inline = always, call_conv = cold
| ^
|> 67:5:text_code.mf
| attr inline = always, call_conv = cold
| ^^^^
|> 67:12:text_code.mf
| attr inline = always, call_conv = cold
|      ^^^^^^
|> 67:14:text_code.mf
| attr inline = always, call_conv = cold
|             ^
|> 67:21:text_code.mf
| attr inline = always, call_conv = cold
|               ^^^^^^
|> 67:22:text_code.mf
| attr inline = always, call_conv = cold
|                     ^
|> 67:32:text_code.mf
| attr inline = always, call_conv = cold
|                       ^^^^^^^^^
|> 67:34:text_code.mf
| attr inline = always, call_conv = cold
|                                 ^
|> 67:39:text_code.mf
| attr inline = always, call_conv = cold
|                                   ^^^^
|> 68:1:text_code.mf
| fun inline_fn -> u32:
| ^
|> 68:4:text_code.mf
| fun inline_fn -> u32:
| ^^^
|> 68:14:text_code.mf
| fun inline_fn -> u32:
|     ^^^^^^^^^
|> 68:17:text_code.mf
| fun inline_fn -> u32:
|               ^^
|> 68:21:text_code.mf
| fun inline_fn -> u32:
|                  ^^^
|> 68:22:text_code.mf
| fun inline_fn -> u32:
|                     ^
|> 69:3:text_code.mf
|   return 10
| ^^
|> 69:9:text_code.mf
|   return 10
|   ^^^^^^
|> 69:12:text_code.mf
|   return 10
|          ^^
|> 70:2:text_code.mf
| 
| ^
|> 71:1:text_code.mf
| fun fib(v: i64) -> i64:
| ^
|> 71:4:text_code.mf
| fun fib(v: i64) -> i64:
| ^^^
|> 71:8:text_code.mf
| fun fib(v: i64) -> i64:
|     ^^^
|> 71:9:text_code.mf
| fun fib(v: i64) -> i64:
|        ^
|> 71:10:text_code.mf
| fun fib(v: i64) -> i64:
|         ^
|> 71:11:text_code.mf
| fun fib(v: i64) -> i64:
|          ^
|> 71:15:text_code.mf
| fun fib(v: i64) -> i64:
|            ^^^
|> 71:16:text_code.mf
| fun fib(v: i64) -> i64:
|               ^
|> 71:19:text_code.mf
| fun fib(v: i64) -> i64:
|                 ^^
|> 71:23:text_code.mf
| fun fib(v: i64) -> i64:
|                    ^^^
|> 71:24:text_code.mf
| fun fib(v: i64) -> i64:
|                       ^
|> 72:3:text_code.mf
|   return if v == 0 | v == 1:
| ^^
|> 72:9:text_code.mf
|   return if v == 0 | v == 1:
|   ^^^^^^
|> 72:12:text_code.mf
|   return if v == 0 | v == 1:
|          ^^
|> 72:14:text_code.mf
|   return if v == 0 | v == 1:
|             ^
|> 72:17:text_code.mf
|   return if v == 0 | v == 1:
|               ^^
|> 72:19:text_code.mf
|   return if v == 0 | v == 1:
|                  ^
|> 72:21:text_code.mf
|   return if v == 0 | v == 1:
|                    ^
|> 72:23:text_code.mf
|   return if v == 0 | v == 1:
|                      ^
|> 72:26:text_code.mf
|   return if v == 0 | v == 1:
|                        ^^
|> 72:28:text_code.mf
|   return if v == 0 | v == 1:
|                           ^
|> 72:29:text_code.mf
|   return if v == 0 | v == 1:
|                            ^
|> 73:5:text_code.mf
|     1
| ^^^^
|> 73:6:text_code.mf
|     1
|     ^
|> 74:3:text_code.mf
|   else:
| ^^
|> 74:7:text_code.mf
|   else:
|   ^^^^
|> 74:8:text_code.mf
|   else:
|       ^
|> 75:5:text_code.mf
|     fib(v - 1) + fib(v - 2)
| ^^^^
|> 75:8:text_code.mf
|     fib(v - 1) + fib(v - 2)
|     ^^^
|> 75:9:text_code.mf
|     fib(v - 1) + fib(v - 2)
|        ^
|> 75:10:text_code.mf
|     fib(v - 1) + fib(v - 2)
|         ^
|> 75:12:text_code.mf
|     fib(v - 1) + fib(v - 2)
|           ^
|> 75:14:text_code.mf
|     fib(v - 1) + fib(v - 2)
|             ^
|> 75:15:text_code.mf
|     fib(v - 1) + fib(v - 2)
|              ^
|> 75:17:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                ^
|> 75:21:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                  ^^^
|> 75:22:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                     ^
|> 75:23:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                      ^
|> 75:25:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                        ^
|> 75:27:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                          ^
|> 75:28:text_code.mf
|     fib(v - 1) + fib(v - 2)
|                           ^
|> 76:2:text_code.mf
| 
| ^
|> 77:1:text_code.mf
| fun fib_loop(v: i64) -> i64:
| ^
|> 77:4:text_code.mf
| fun fib_loop(v: i64) -> i64:
| ^^^
|> 77:13:text_code.mf
| fun fib_loop(v: i64) -> i64:
|     ^^^^^^^^
|> 77:14:text_code.mf
| fun fib_loop(v: i64) -> i64:
|             ^
|> 77:15:text_code.mf
| fun fib_loop(v: i64) -> i64:
|              ^
|> 77:16:text_code.mf
| fun fib_loop(v: i64) -> i64:
|               ^
|> 77:20:text_code.mf
| fun fib_loop(v: i64) -> i64:
|                 ^^^
|> 77:21:text_code.mf
| fun fib_loop(v: i64) -> i64:
|                    ^
|> 77:24:text_code.mf
| fun fib_loop(v: i64) -> i64:
|                      ^^
|> 77:28:text_code.mf
| fun fib_loop(v: i64) -> i64:
|                         ^^^
|> 77:29:text_code.mf
| fun fib_loop(v: i64) -> i64:
|                            ^
|> 78:3:text_code.mf
|   var a, b, c = 1
| ^^
|> 78:6:text_code.mf
|   var a, b, c = 1
|   ^^^
|> 78:8:text_code.mf
|   var a, b, c = 1
|       ^
|> 78:9:text_code.mf
|   var a, b, c = 1
|        ^
|> 78:11:text_code.mf
|   var a, b, c = 1
|          ^
|> 78:12:text_code.mf
|   var a, b, c = 1
|           ^
|> 78:14:text_code.mf
|   var a, b, c = 1
|             ^
|> 78:16:text_code.mf
|   var a, b, c = 1
|               ^
|> 78:18:text_code.mf
|   var a, b, c = 1
|                 ^
|> 79:3:text_code.mf
|   loop'a:
| ^^
|> 79:7:text_code.mf
|   loop'a:
|   ^^^^
|> 79:9:text_code.mf
|   loop'a:
|       ^^
|> 79:10:text_code.mf
|   loop'a:
|         ^
|> 80:5:text_code.mf
|     c = a + b
| ^^^^
|> 80:6:text_code.mf
|     c = a + b
|     ^
|> 80:8:text_code.mf
|     c = a + b
|       ^
|> 80:10:text_code.mf
|     c = a + b
|         ^
|> 80:12:text_code.mf
|     c = a + b
|           ^
|> 80:14:text_code.mf
|     c = a + b
|             ^
|> 81:5:text_code.mf
|     a = b
| ^^^^
|> 81:6:text_code.mf
|     a = b
|     ^
|> 81:8:text_code.mf
|     a = b
|       ^
|> 81:10:text_code.mf
|     a = b
|         ^
|> 82:5:text_code.mf
|     b = c
| ^^^^
|> 82:6:text_code.mf
|     b = c
|     ^
|> 82:8:text_code.mf
|     b = c
|       ^
|> 82:10:text_code.mf
|     b = c
|         ^
|> 83:5:text_code.mf
|     v = v - 1
| ^^^^
|> 83:6:text_code.mf
|     v = v - 1
|     ^
|> 83:8:text_code.mf
|     v = v - 1
|       ^
|> 83:10:text_code.mf
|     v = v - 1
|         ^
|> 83:12:text_code.mf
|     v = v - 1
|           ^
|> 83:14:text_code.mf
|     v = v - 1
|             ^
|> 84:5:text_code.mf
|     if v == 0:
| ^^^^
|> 84:7:text_code.mf
|     if v == 0:
|     ^^
|> 84:9:text_code.mf
|     if v == 0:
|        ^
|> 84:12:text_code.mf
|     if v == 0:
|          ^^
|> 84:14:text_code.mf
|     if v == 0:
|             ^
|> 84:15:text_code.mf
|     if v == 0:
|              ^
|> 85:7:text_code.mf
|       break'a
| ^^^^^^
|> 85:12:text_code.mf
|       break'a
|       ^^^^^
|> 85:14:text_code.mf
|       break'a
|            ^^
|> 86:3:text_code.mf
|   return c
| ^^
|> 86:9:text_code.mf
|   return c
|   ^^^^^^
|> 86:11:text_code.mf
|   return c
|          ^
|> 87:2:text_code.mf
| 
| ^
|> 88:1:text_code.mf
| fun unary_operators(a: i64) -> i64:
| ^
|> 88:4:text_code.mf
| fun unary_operators(a: i64) -> i64:
| ^^^
|> 88:20:text_code.mf
| fun unary_operators(a: i64) -> i64:
|     ^^^^^^^^^^^^^^^
|> 88:21:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                    ^
|> 88:22:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                     ^
|> 88:23:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                      ^
|> 88:27:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                        ^^^
|> 88:28:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                           ^
|> 88:31:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                             ^^
|> 88:35:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                                ^^^
|> 88:36:text_code.mf
| fun unary_operators(a: i64) -> i64:
|                                   ^
|> 89:3:text_code.mf
|   return -a + ~a + !a + ++a + --a
| ^^
|> 89:9:text_code.mf
|   return -a + ~a + !a + ++a + --a
|   ^^^^^^
|> 89:11:text_code.mf
|   return -a + ~a + !a + ++a + --a
|          ^
|> 89:12:text_code.mf
|   return -a + ~a + !a + ++a + --a
|           ^
|> 89:14:text_code.mf
|   return -a + ~a + !a + ++a + --a
|             ^
|> 89:16:text_code.mf
|   return -a + ~a + !a + ++a + --a
|               ^
|> 89:17:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                ^
|> 89:19:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                  ^
|> 89:21:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                    ^
|> 89:22:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                     ^
|> 89:24:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                       ^
|> 89:27:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                         ^^
|> 89:28:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                           ^
|> 89:30:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                             ^
|> 89:33:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                               ^^
|> 89:34:text_code.mf
|   return -a + ~a + !a + ++a + --a
|                                 ^
|> 90:2:text_code.mf
| 
| ^
|> 91:1:text_code.mf
| struct Foo:
| ^
|> 91:7:text_code.mf
| struct Foo:
| ^^^^^^
|> 91:11:text_code.mf
| struct Foo:
|        ^^^
|> 91:12:text_code.mf
| struct Foo:
|           ^
|> 92:3:text_code.mf
|   a, b, c: int
| ^^
|> 92:4:text_code.mf
|   a, b, c: int
|   ^
|> 92:5:text_code.mf
|   a, b, c: int
|    ^
|> 92:7:text_code.mf
|   a, b, c: int
|      ^
|> 92:8:text_code.mf
|   a, b, c: int
|       ^
|> 92:10:text_code.mf
|   a, b, c: int
|         ^
|> 92:11:text_code.mf
|   a, b, c: int
|          ^
|> 92:15:text_code.mf
|   a, b, c: int
|            ^^^
|> 93:2:text_code.mf
| 
| ^
|> 94:1:text_code.mf
| struct Goo:
| ^
|> 94:7:text_code.mf
| struct Goo:
| ^^^^^^
|> 94:11:text_code.mf
| struct Goo:
|        ^^^
|> 94:12:text_code.mf
| struct Goo:
|           ^
|> 95:3:text_code.mf
|   embed foo: Foo
| ^^
|> 95:8:text_code.mf
|   embed foo: Foo
|   ^^^^^
|> 95:12:text_code.mf
|   embed foo: Foo
|         ^^^
|> 95:13:text_code.mf
|   embed foo: Foo
|            ^
|> 95:17:text_code.mf
|   embed foo: Foo
|              ^^^
|> 96:3:text_code.mf
|   gva: int
| ^^
|> 96:6:text_code.mf
|   gva: int
|   ^^^
|> 96:7:text_code.mf
|   gva: int
|      ^
|> 96:11:text_code.mf
|   gva: int
|        ^^^
|> 97:2:text_code.mf
| 
| ^
|> 98:1:text_code.mf
| fun strings -> i64:
| ^
|> 98:4:text_code.mf
| fun strings -> i64:
| ^^^
|> 98:12:text_code.mf
| fun strings -> i64:
|     ^^^^^^^
|> 98:15:text_code.mf
| fun strings -> i64:
|             ^^
|> 98:19:text_code.mf
| fun strings -> i64:
|                ^^^
|> 98:20:text_code.mf
| fun strings -> i64:
|                   ^
|> 99:3:text_code.mf
|   var hello = "hello"
| ^^
|> 99:6:text_code.mf
|   var hello = "hello"
|   ^^^
|> 99:12:text_code.mf
|   var hello = "hello"
|       ^^^^^
|> 99:14:text_code.mf
|   var hello = "hello"
|             ^
|> 99:22:text_code.mf
|   var hello = "hello"
|               ^^^^^^^
|> 100:3:text_code.mf
|   return 0
| ^^
|> 100:9:text_code.mf
|   return 0
|   ^^^^^^
|> 100:11:text_code.mf
|   return 0
|          ^
|> 101:2:text_code.mf
| 
| ^
|> 102:1:text_code.mf
| fun mutable_ref(a: &Foo):
| ^
|> 102:4:text_code.mf
| fun mutable_ref(a: &Foo):
| ^^^
|> 102:16:text_code.mf
| fun mutable_ref(a: &Foo):
|     ^^^^^^^^^^^
|> 102:17:text_code.mf
| fun mutable_ref(a: &Foo):
|                ^
|> 102:18:text_code.mf
| fun mutable_ref(a: &Foo):
|                 ^
|> 102:19:text_code.mf
| fun mutable_ref(a: &Foo):
|                  ^
|> 102:21:text_code.mf
| fun mutable_ref(a: &Foo):
|                    ^
|> 102:24:text_code.mf
| fun mutable_ref(a: &Foo):
|                     ^^^
|> 102:25:text_code.mf
| fun mutable_ref(a: &Foo):
|                        ^
|> 102:26:text_code.mf
| fun mutable_ref(a: &Foo):
|                         ^
|> 103:3:text_code.mf
|   a.a = 10
| ^^
|> 103:4:text_code.mf
|   a.a = 10
|   ^
|> 103:5:text_code.mf
|   a.a = 10
|    ^
|> 103:6:text_code.mf
|   a.a = 10
|     ^
|> 103:8:text_code.mf
|   a.a = 10
|       ^
|> 103:11:text_code.mf
|   a.a = 10
|         ^^
|> 104:3:text_code.mf
|   a.b = 20
| ^^
|> 104:4:text_code.mf
|   a.b = 20
|   ^
|> 104:5:text_code.mf
|   a.b = 20
|    ^
|> 104:6:text_code.mf
|   a.b = 20
|     ^
|> 104:8:text_code.mf
|   a.b = 20
|       ^
|> 104:11:text_code.mf
|   a.b = 20
|         ^^
|> 105:3:text_code.mf
|   a.c = 30
| ^^
|> 105:4:text_code.mf
|   a.c = 30
|   ^
|> 105:5:text_code.mf
|   a.c = 30
|    ^
|> 105:6:text_code.mf
|   a.c = 30
|     ^
|> 105:8:text_code.mf
|   a.c = 30
|       ^
|> 105:11:text_code.mf
|   a.c = 30
|         ^^
|> 106:2:text_code.mf
| 
| ^
|> 107:1:text_code.mf
| fun some_string -> &u8:
| ^
|> 107:4:text_code.mf
| fun some_string -> &u8:
| ^^^
|> 107:16:text_code.mf
| fun some_string -> &u8:
|     ^^^^^^^^^^^
|> 107:19:text_code.mf
| fun some_string -> &u8:
|                 ^^
|> 107:21:text_code.mf
| fun some_string -> &u8:
|                    ^
|> 107:23:text_code.mf
| fun some_string -> &u8:
|                     ^^
|> 107:24:text_code.mf
| fun some_string -> &u8:
|                       ^
|> 108:3:text_code.mf
|   "
| ^^
|> 110:4:text_code.mf
|   "
| hello there
|   "
| ^^^^^^^^^^^
Group "\n":
 VarStatement(None, true) "var something = [1, 2, 3]":
  VarAssign "something = [1, 2, 3]":
   Group "something":
    Ident "something"
   None ""
   Group "=":
    Array "[":
     Lit "1"
     Lit "2"
     Lit "3"
 VarStatement(None, false) "let hello = \"hello\"":
  VarAssign "hello = \"hello\"":
   Group "hello":
    Ident "hello"
   None ""
   Group "=":
    Lit "\"hello\""
 Fun(None) "fun pointed_function(a: Int, b: Int) -> int:\r\n  return a + b":
  FunHeader(Normal) "fun pointed_function(a: Int, b: Int) -> int":
   Ident "pointed_function"
   FunArgument(false) "a: Int":
    Ident "a"
    Ident "Int"
   FunArgument(false) "b: Int":
    Ident "b"
    Ident "Int"
   Ident "int"
   None ""
  Group ":":
   ReturnStatement "return a + b":
    BinaryOp "a + b":
     Ident "+"
     Ident "a"
     Ident "b"
 Comment "## doc comment\r"
 Fun(None) "fun something -> fun(int, int) -> int:\r\n  # ignored comment\r\n  return #[ even more ignored comment ]# pointed_function":
  FunHeader(Normal) "fun something -> fun(int, int) -> int":
   Ident "something"
   FunHeader(Normal) "fun(int, int) -> int":
    None ""
    Ident "int"
    Ident "int"
    Ident "int"
    None ""
   None ""
  Group ":":
   ReturnStatement "return #[ even more ignored comment ]# pointed_function":
    Ident "pointed_function"
 Comment "##[\r\n  multiline doc comment\r\n]#"
 StructDeclaration(None) "struct":
  Ident "Scope"
  None ""
 Impl(None) "impl":
  None ""
  Ident "Scope"
  Group ":":
   Fun(None) "fun new -> Self:\r\n    return":
    FunHeader(Normal) "fun new -> Self":
     Ident "new"
     Ident "Self"
     None ""
    Group ":":
     ReturnStatement "return":
      None ""
   Fun(None) "fun do_nothing(s: Self):\r\n    pass":
    FunHeader(Normal) "fun do_nothing(s: Self)":
     Ident "do_nothing"
     FunArgument(false) "s: Self":
      Ident "s"
      Ident "Self"
     None ""
     None ""
    Group ":":
     Pass "pass"
 StructDeclaration(None) "struct":
  Instantiation "Template[T]":
   Ident "Template"
   Ident "T"
  None ""
 Impl(None) "impl":
  Group "[":
   Ident "T"
  Instantiation "Template[T]":
   Ident "Template"
   Ident "T"
  Group ":":
   Fun(None) "fun new -> Self:\r\n    return":
    FunHeader(Normal) "fun new -> Self":
     Ident "new"
     Ident "Self"
     None ""
    Group ":":
     ReturnStatement "return":
      None ""
   Fun(None) "fun do_nothing(s: Self, value: T) -> T:\r\n    value":
    FunHeader(Normal) "fun do_nothing(s: Self, value: T) -> T":
     Ident "do_nothing"
     FunArgument(false) "s: Self":
      Ident "s"
      Ident "Self"
     FunArgument(false) "value: T":
      Ident "value"
      Ident "T"
     Ident "T"
     None ""
    Group ":":
     Ident "value"
 Fun(None) "fun use_chain:\r\n  module::Type::method::[param]()":
  FunHeader(Normal) "fun use_chain":
   Ident "use_chain"
   None ""
   None ""
  Group ":":
   Call(false) "module::Type::method::[param]()":
    Instantiation "module::Type::method::[param]":
     Path "module::Type::method":
      Ident "module"
      Ident "Type"
      Ident "method"
     Ident "param"
 Fun(None) "fun flo: pass":
  FunHeader(Normal) "fun flo":
   Ident "flo"
   None ""
   None ""
  Group ":":
   Pass "pass"
 Fun(None) "fun foo(): pass":
  FunHeader(Normal) "fun foo()":
   Ident "foo"
   None ""
   None ""
  Group ":":
   Pass "pass"
 Fun(None) "fun goo(a: i8, b: i8): pass":
  FunHeader(Normal) "fun goo(a: i8, b: i8)":
   Ident "goo"
   FunArgument(false) "a: i8":
    Ident "a"
    Ident "i8"
   FunArgument(false) "b: i8":
    Ident "b"
    Ident "i8"
   None ""
   None ""
  Group ":":
   Pass "pass"
 Fun(None) "fun loo:\r\n  noo::loo::[i8]()\r\n\r\n  let array = [1, 2, 3]\r\n  array[0] = 3\r\n  array[2] = always[1]\r\n  array[1] = 1\r\n\r\n  pass":
  FunHeader(Normal) "fun loo":
   Ident "loo"
   None ""
   None ""
  Group ":":
   Call(false) "noo::loo::[i8]()":
    Instantiation "noo::loo::[i8]":
     Path "noo::loo":
      Ident "noo"
      Ident "loo"
     Ident "i8"
   VarStatement(None, false) "let array = [1, 2, 3]":
    VarAssign "array = [1, 2, 3]":
     Group "array":
      Ident "array"
     None ""
     Group "=":
      Array "[":
       Lit "1"
       Lit "2"
       Lit "3"
   BinaryOp "array[0] = 3":
    Ident "="
    Index "array[0]":
     Ident "array"
     Lit "0"
    Lit "3"
   BinaryOp "array[2] = always[1]":
    Ident "="
    Index "array[2]":
     Ident "array"
     Lit "2"
    Index "always[1]":
     Ident "always"
     Lit "1"
   BinaryOp "array[1] = 1":
    Ident "="
    Index "array[1]":
     Ident "array"
     Lit "1"
    Lit "1"
   Pass "pass"
 Fun(None) "fun main -> i64:\r\n  return 10 + 4 - 2 * 1 + 8":
  FunHeader(Normal) "fun main -> i64":
   Ident "main"
   Ident "i64"
   None ""
  Group ":":
   ReturnStatement "return 10 + 4 - 2 * 1 + 8":
    BinaryOp "10 + 4 - 2 * 1 + 8":
     Ident "-"
     BinaryOp "10 + 4":
      Ident "+"
      Lit "10"
      Lit "4"
     BinaryOp "2 * 1 + 8":
      Ident "+"
      BinaryOp "2 * 1":
       Ident "*"
       Lit "2"
       Lit "1"
      Lit "8"
 Fun(None) "fun operator_stress_test -> i64:\r\n  return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10":
  FunHeader(Normal) "fun operator_stress_test -> i64":
   Ident "operator_stress_test"
   Ident "i64"
   None ""
  Group ":":
   ReturnStatement "return 10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10":
    BinaryOp "10 + 2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10":
     Ident "+"
     Lit "10"
     BinaryOp "2 * 1 - 9 | 4 & 1 ^ 2 >> 1 << 7 min 20 max 10":
      Ident "|"
      BinaryOp "2 * 1 - 9":
       Ident "-"
       BinaryOp "2 * 1":
        Ident "*"
        Lit "2"
        Lit "1"
       Lit "9"
      BinaryOp "4 & 1 ^ 2 >> 1 << 7 min 20 max 10":
       Ident "^"
       BinaryOp "4 & 1":
        Ident "&"
        Lit "4"
        Lit "1"
       BinaryOp "2 >> 1 << 7 min 20 max 10":
        Ident "max"
        BinaryOp "2 >> 1 << 7 min 20":
         Ident "min"
         BinaryOp "2 >> 1 << 7":
          Ident "<<"
          BinaryOp "2 >> 1":
           Ident ">>"
           Lit "2"
           Lit "1"
          Lit "7"
         Lit "20"
        Lit "10"
 Fun(None) "fun conditional -> i64:\r\n  if false:\r\n    return 10\r\n  elif true:\r\n    return if true: 10 else: 20\r\n  else:\r\n    return 0":
  FunHeader(Normal) "fun conditional -> i64":
   Ident "conditional"
   Ident "i64"
   None ""
  Group ":":
   IfExpr "if false:\r\n    return 10\r\n  elif true:\r\n    return if true: 10 else: 20\r\n  else:\r\n    return 0":
    Lit "false"
    Group ":":
     ReturnStatement "return 10":
      Lit "10"
    Group "elif":
     IfExpr "elif true:\r\n    return if true: 10 else: 20\r\n  else:\r\n    return 0":
      Lit "true"
      Group ":":
       ReturnStatement "return if true: 10 else: 20":
        IfExpr "if true: 10 else: 20":
         Lit "true"
         Group ":":
          Lit "10"
         Group ":":
          Lit "20"
      Group ":":
       ReturnStatement "return 0":
        Lit "0"
 Attribute "attr inline = always, call_conv = cold":
  AttributeAssign "inline = always":
   Ident "inline"
   Ident "always"
  AttributeAssign "call_conv = cold":
   Ident "call_conv"
   Ident "cold"
 Fun(None) "fun inline_fn -> u32:\r\n  return 10":
  FunHeader(Normal) "fun inline_fn -> u32":
   Ident "inline_fn"
   Ident "u32"
   None ""
  Group ":":
   ReturnStatement "return 10":
    Lit "10"
 Fun(None) "fun fib(v: i64) -> i64:\r\n  return if v == 0 | v == 1:\r\n    1\r\n  else:\r\n    fib(v - 1) + fib(v - 2)":
  FunHeader(Normal) "fun fib(v: i64) -> i64":
   Ident "fib"
   FunArgument(false) "v: i64":
    Ident "v"
    Ident "i64"
   Ident "i64"
   None ""
  Group ":":
   ReturnStatement "return if v == 0 | v == 1:\r\n    1\r\n  else:\r\n    fib(v - 1) + fib(v - 2)":
    IfExpr "if v == 0 | v == 1:\r\n    1\r\n  else:\r\n    fib(v - 1) + fib(v - 2)":
     BinaryOp "v == 0 | v == 1":
      Ident "|"
      BinaryOp "v == 0":
       Ident "=="
       Ident "v"
       Lit "0"
      BinaryOp "v == 1":
       Ident "=="
       Ident "v"
       Lit "1"
     Group ":":
      Lit "1"
     Group ":":
      BinaryOp "fib(v - 1) + fib(v - 2)":
       Ident "+"
       Call(false) "fib(v - 1)":
        Ident "fib"
        BinaryOp "v - 1":
         Ident "-"
         Ident "v"
         Lit "1"
       Call(false) "fib(v - 2)":
        Ident "fib"
        BinaryOp "v - 2":
         Ident "-"
         Ident "v"
         Lit "2"
 Fun(None) "fun fib_loop(v: i64) -> i64:\r\n  var a, b, c = 1\r\n  loop'a:\r\n    c = a + b\r\n    a = b\r\n    b = c\r\n    v = v - 1\r\n    if v == 0:\r\n      break'a\r\n  return c":
  FunHeader(Normal) "fun fib_loop(v: i64) -> i64":
   Ident "fib_loop"
   FunArgument(false) "v: i64":
    Ident "v"
    Ident "i64"
   Ident "i64"
   None ""
  Group ":":
   VarStatement(None, true) "var a, b, c = 1":
    VarAssign "a, b, c = 1":
     Group "a":
      Ident "a"
      Ident "b"
      Ident "c"
     None ""
     Group "=":
      Lit "1"
      Ident "a"
      Ident "a"
   Loop "loop'a:\r\n    c = a + b\r\n    a = b\r\n    b = c\r\n    v = v - 1\r\n    if v == 0:\r\n      break'a":
    Ident "'a"
    Group ":":
     BinaryOp "c = a + b":
      Ident "="
      Ident "c"
      BinaryOp "a + b":
       Ident "+"
       Ident "a"
       Ident "b"
     BinaryOp "a = b":
      Ident "="
      Ident "a"
      Ident "b"
     BinaryOp "b = c":
      Ident "="
      Ident "b"
      Ident "c"
     BinaryOp "v = v - 1":
      Ident "="
      Ident "v"
      BinaryOp "v - 1":
       Ident "-"
       Ident "v"
       Lit "1"
     IfExpr "if v == 0:\r\n      break'a":
      BinaryOp "v == 0":
       Ident "=="
       Ident "v"
       Lit "0"
      Group ":":
       Break "break'a":
        Ident "'a"
        None ""
      None ""
   ReturnStatement "return c":
    Ident "c"
 Fun(None) "fun unary_operators(a: i64) -> i64:\r\n  return -a + ~a + !a + ++a + --a":
  FunHeader(Normal) "fun unary_operators(a: i64) -> i64":
   Ident "unary_operators"
   FunArgument(false) "a: i64":
    Ident "a"
    Ident "i64"
   Ident "i64"
   None ""
  Group ":":
   ReturnStatement "return -a + ~a + !a + ++a + --a":
    BinaryOp "-a + ~a + !a + ++a + --a":
     Ident "+"
     BinaryOp "-a + ~a + !a + ++a":
      Ident "+"
      BinaryOp "-a + ~a + !a":
       Ident "+"
       BinaryOp "-a + ~a":
        Ident "+"
        UnaryOp "-a":
         Ident "-"
         Ident "a"
        UnaryOp "~a":
         Ident "~"
         Ident "a"
       UnaryOp "!a":
        Ident "!"
        Ident "a"
      UnaryOp "++a":
       Ident "++"
       Ident "a"
     UnaryOp "--a":
      Ident "--"
      Ident "a"
 StructDeclaration(None) "struct":
  Ident "Foo"
  Group ":":
   StructField(None, false) "a, b, c: int":
    Ident "a"
    Ident "b"
    Ident "c"
    Ident "int"
 StructDeclaration(None) "struct":
  Ident "Goo"
  Group ":":
   StructField(None, true) "foo: Foo":
    Ident "foo"
    Ident "Foo"
   StructField(None, false) "gva: int":
    Ident "gva"
    Ident "int"
 Fun(None) "fun strings -> i64:\r\n  var hello = \"hello\"\r\n  return 0":
  FunHeader(Normal) "fun strings -> i64":
   Ident "strings"
   Ident "i64"
   None ""
  Group ":":
   VarStatement(None, true) "var hello = \"hello\"":
    VarAssign "hello = \"hello\"":
     Group "hello":
      Ident "hello"
     None ""
     Group "=":
      Lit "\"hello\""
   ReturnStatement "return 0":
    Lit "0"
 Fun(None) "fun mutable_ref(a: &Foo):\r\n  a.a = 10\r\n  a.b = 20\r\n  a.c = 30":
  FunHeader(Normal) "fun mutable_ref(a: &Foo)":
   Ident "mutable_ref"
   FunArgument(false) "a: &Foo":
    Ident "a"
    Ref "&Foo":
     Ident "Foo"
   None ""
   None ""
  Group ":":
   BinaryOp "a.a = 10":
    Ident "="
    DotExpr "a.a":
     Ident "a"
     Ident "a"
    Lit "10"
   BinaryOp "a.b = 20":
    Ident "="
    DotExpr "a.b":
     Ident "a"
     Ident "b"
    Lit "20"
   BinaryOp "a.c = 30":
    Ident "="
    DotExpr "a.c":
     Ident "a"
     Ident "c"
    Lit "30"
 Fun(None) "fun some_string -> &u8:\r\n  \"\r\nhello there\r\n  \"":
  FunHeader(Normal) "fun some_string -> &u8":
   Ident "some_string"
   Ref "&u8":
    Ident "u8"
   None ""
  Group ":":
   Lit "\"\r\nhello there\r\n  \""

fun print(s: &Self, value: &u8)

  Inst1Range { start: Value(0), end: Value(2) }
    Value(2): int = Lit(Int(0, 0)) |0
    Value(3): int = VarDecl(Value(2)) |i = 0
    Jump(Inst(4), Range { start: Value(0), end: Value(0) }) |loop:
      let value = *((value as int + i) as &u8)
      if value == 0u8:
        break
      i += 1

  Inst4Range { start: Value(0), end: Value(0) }
    Value(4): int = Cast(Value(1)) |value as int
    Value(5): int = Call(Fun(260), Range { start: Value(2), end: Value(4) }) |(value as int + i)
    Value(6): &u8 = Cast(Value(5)) |((value as int + i) as &u8)
    Value(7): u8 = Deref(Value(6), false) |*((value as int + i) as &u8)
    Value(8): u8 = VarDecl(Value(7)) |value = *((value as int + i) as &u8)
    Value(9): u8 = Lit(Uint(0, 8)) |0u8
    Value(10): bool = Call(Fun(306), Range { start: Value(4), end: Value(6) }) |value == 0u8
    JumpIfTrue(Value(10), Inst(15), Range { start: Value(0), end: Value(0) }) |value == 0u8
    Jump(Inst(17), Range { start: Value(0), end: Value(0) }) |

  Inst15Range { start: Value(0), end: Value(0) }
    Jump(Inst(5), Range { start: Value(0), end: Value(0) }) |break

  Inst17Range { start: Value(0), end: Value(0) }
    Value(11): int = Lit(Int(1, 0)) |1
    Value(12): int = Call(Fun(260), Range { start: Value(6), end: Value(8) }) |i += 1
    Value(12): int = Assign(Value(3)) |i += 1
    Jump(Inst(4), Range { start: Value(0), end: Value(0) }) |loop:
      let value = *((value as int + i) as &u8)
      if value == 0u8:
        break
      i += 1

  Inst5Range { start: Value(0), end: Value(0) }
    Call(Fun(480), Range { start: Value(8), end: Value(10) }) |s.reserve(i)
    Value(14): &Seq[u8] = Offset(Value(0)) |s.len
    Value(15): Seq[u8] = Deref(Value(14), false) |s.len
    Value(13): int = Offset(Value(15)) |s.len
    Value(16): &u8 = Call(Fun(481), Range { start: Value(10), end: Value(12) }) |s.get_unchecked(s.len)
    Call(Fun(443), Range { start: Value(12), end: Value(15) }) |memcpy(s.get_unchecked(s.len), value, i)
    Value(18): &Seq[u8] = Offset(Value(0)) |s.len
    Value(19): Seq[u8] = Deref(Value(18), false) |s.len
    Value(17): int = Offset(Value(19)) |s.len
    Value(21): &Seq[u8] = Offset(Value(0)) |s.len
    Value(22): Seq[u8] = Deref(Value(21), false) |s.len
    Value(20): int = Offset(Value(22)) |s.len
    Value(23): int = Call(Fun(260), Range { start: Value(15), end: Value(17) }) |s.len += i
    Value(23): int = Assign(Value(17)) |s.len += i
    Return(None) |s.len += i


function u0:0(i64, i64) fast {
    sig0 = (i64, i64) fast
    sig1 = (i64, i64) -> i64 fast
    sig2 = (i64, i64, i64) windows_fastcall
    fn0 = colocated u0:3 sig0
    fn1 = colocated u0:1 sig1
    fn2 = u0:22 sig2

block0(v0: i64, v1: i64):
    v17 = iconst.i64 0
    v3 -> v17
    v2 = iconst.i64 0
    jump block1(v2)

block1(v4: i64):
    v10 -> v4
    v12 -> v4
    v5 = iadd.i64 v1, v4
    v6 = load.i8 v5
    v7 = iconst.i8 0
    v8 = icmp eq v6, v7
    brnz v8, block2
    jump block3

block2:
    jump block4

block3:
    v9 = iconst.i64 1
    v11 = iadd.i64 v10, v9
    jump block1(v11)

block4:
    call fn0(v0, v12)
    v13 = load.i64 v0+8
    v14 = call fn1(v0, v13)
    call fn2(v14, v1, v12)
    v15 = load.i64 v0+8
    v16 = iadd v15, v12
    store v16, v0+8
    return
}

fun get_unchecked(s: &Self, index: int) -> &T

  Inst1Range { start: Value(0), end: Value(2) }
    Value(3): &Seq[u8] = Offset(Value(0)) |s.data
    Value(4): Seq[u8] = Deref(Value(3), false) |s.data
    Value(2): &u8 = Offset(Value(4)) |s.data
    Value(5): int = Cast(Value(2)) |s.data as int
    Value(6): int = Call(Fun(482), Range { start: Value(2), end: Value(2) }) |sizeof::[T]()
    Value(7): int = Call(Fun(280), Range { start: Value(2), end: Value(4) }) |index * sizeof::[T]()
    Value(8): int = Call(Fun(260), Range { start: Value(4), end: Value(6) }) |(s.data as int + index * sizeof::[T]())
    Value(9): &u8 = Cast(Value(8)) |(s.data as int + index * sizeof::[T]()) as &T
    Return(Some(Value(9))) |(s.data as int + index * sizeof::[T]()) as &T


function u0:0(i64, i64) -> i64 fast {
block0(v0: i64, v1: i64):
    v2 = iconst.i64 1
    v3 = imul v1, v2
    v4 = load.i64 v0
    v5 = iadd v4, v3
    return v5
}

fun pub sizeof[T] -> int


fun reserve(s: &Self, new_cap: int)

  Inst1Range { start: Value(0), end: Value(2) }
    Value(3): &Seq[u8] = Offset(Value(0)) |s.cap
    Value(4): Seq[u8] = Deref(Value(3), false) |s.cap
    Value(2): int = Offset(Value(4)) |s.cap
    Value(5): bool = Call(Fun(350), Range { start: Value(2), end: Value(4) }) |s.cap > new_cap
    JumpIfTrue(Value(5), Inst(6), Range { start: Value(0), end: Value(0) }) |s.cap > new_cap
    Jump(Inst(8), Range { start: Value(0), end: Value(0) }) |

  Inst6Range { start: Value(0), end: Value(0) }
    Return(None) |return

  Inst8Range { start: Value(0), end: Value(0) }
    Value(7): &Seq[u8] = Offset(Value(0)) |s.data
    Value(8): Seq[u8] = Deref(Value(7), false) |s.data
    Value(6): &u8 = Offset(Value(8)) |s.data
    Value(10): &Seq[u8] = Offset(Value(0)) |s.data
    Value(11): Seq[u8] = Deref(Value(10), false) |s.data
    Value(9): &u8 = Offset(Value(11)) |s.data
    Value(12): int = Call(Fun(482), Range { start: Value(4), end: Value(4) }) |sizeof::[T]()
    Value(13): int = Call(Fun(280), Range { start: Value(4), end: Value(6) }) |new_cap * sizeof::[T]()
    Value(14): &u8 = Call(Fun(438), Range { start: Value(6), end: Value(8) }) |realloc(s.data, new_cap * sizeof::[T]())
    Value(14): &u8 = Assign(Value(6)) |s.data = realloc(s.data, new_cap * sizeof::[T]())
    Value(16): &Seq[u8] = Offset(Value(0)) |s.cap
    Value(17): Seq[u8] = Deref(Value(16), false) |s.cap
    Value(15): int = Offset(Value(17)) |s.cap
    Value(1): int = Assign(Value(15)) |s.cap = new_cap
    Return(None) |s.cap = new_cap


function u0:0(i64, i64) fast {
    sig0 = (i64, i64) -> i64 windows_fastcall
    fn0 = u0:27 sig0

block0(v0: i64, v1: i64):
    v2 = load.i64 v0+16
    v3 = icmp sgt v2, v1
    brnz v3, block1
    jump block2

block1:
    return

block2:
    v4 = iconst.i64 1
    v5 = imul.i64 v1, v4
    v6 = load.i64 v0
    v7 = call fn0(v6, v5)
    store v7, v0
    store.i64 v1, v0+16
    return
}

fun print_int(s: &Self, value: int)

  Inst1Range { start: Value(0), end: Value(2) }
    Value(3): &Seq[u8] = Offset(Value(0)) |s.len
    Value(4): Seq[u8] = Deref(Value(3), false) |s.len
    Value(2): int = Offset(Value(4)) |s.len
    Value(5): int = VarDecl(Value(2)) |prev_len = s.len
    Value(6): f64 = Call(Fun(138), Range { start: Value(2), end: Value(3) }) |value.f64()
    Value(7): f64 = Call(Fun(444), Range { start: Value(3), end: Value(4) }) |log10
    Value(8): int = Call(Fun(164), Range { start: Value(4), end: Value(5) }) |log10(value.f64()).int()
    Value(9): int = Lit(Int(1, 0)) |1
    Value(10): int = Call(Fun(260), Range { start: Value(5), end: Value(7) }) |log10(value.f64()).int() + 1
    Value(11): int = VarDecl(Value(10)) |width = log10(value.f64()).int() + 1
    Value(12): int = Call(Fun(260), Range { start: Value(7), end: Value(9) }) |prev_len + width
    Call(Fun(480), Range { start: Value(9), end: Value(11) }) |s.reserve(prev_len + width)
    Value(14): &Seq[u8] = Offset(Value(0)) |s.len
    Value(15): Seq[u8] = Deref(Value(14), false) |s.len
    Value(13): int = Offset(Value(15)) |s.len
    Value(16): int = Call(Fun(260), Range { start: Value(11), end: Value(13) }) |prev_len + width
    Value(16): int = Assign(Value(13)) |s.len = prev_len + width
    Value(17): int = VarDecl(Value(11)) |i = width
    Value(18): int = VarDecl(Value(1)) |value = value
    Jump(Inst(21), Range { start: Value(0), end: Value(0) }) |loop:
      if i == 0:
        break
      var digit = value % 10
      value = value / 10
      *s.get_unchecked(prev_len + i - 1) = (digit.u32() + '0').u8()
      i -= 1

  Inst21Range { start: Value(0), end: Value(0) }
    Value(19): int = Lit(Int(0, 0)) |0
    Value(20): bool = Call(Fun(310), Range { start: Value(13), end: Value(15) }) |i == 0
    JumpIfTrue(Value(20), Inst(27), Range { start: Value(0), end: Value(0) }) |i == 0
    Jump(Inst(29), Range { start: Value(0), end: Value(0) }) |

  Inst27Range { start: Value(0), end: Value(0) }
    Jump(Inst(22), Range { start: Value(0), end: Value(0) }) |break

  Inst29Range { start: Value(0), end: Value(0) }
    Value(21): int = Lit(Int(10, 0)) |10
    Value(22): int = Call(Fun(300), Range { start: Value(15), end: Value(17) }) |value % 10
    Value(23): int = VarDecl(Value(22)) |digit = value % 10
    Value(24): int = Lit(Int(10, 0)) |10
    Value(25): int = Call(Fun(290), Range { start: Value(17), end: Value(19) }) |value / 10
    Value(25): int = Assign(Value(18)) |value = value / 10
    Value(26): int = Call(Fun(260), Range { start: Value(19), end: Value(21) }) |prev_len + i
    Value(27): int = Lit(Int(1, 0)) |1
    Value(28): int = Call(Fun(270), Range { start: Value(21), end: Value(23) }) |prev_len + i - 1
    Value(29): &u8 = Call(Fun(481), Range { start: Value(23), end: Value(25) }) |s.get_unchecked(prev_len + i - 1)
    Value(30): u8 = Deref(Value(29), true) |*s.get_unchecked(prev_len + i - 1)
    Value(31): u32 = Call(Fun(96), Range { start: Value(25), end: Value(26) }) |digit.u32()
    Value(32): u32 = Lit(Char('0')) |'0'
    Value(33): u32 = Call(Fun(258), Range { start: Value(26), end: Value(28) }) |(
    Value(34): u8 = Call(Fun(63), Range { start: Value(28), end: Value(29) }) |(digit.u32() + '0').u8()
    Value(34): u8 = Assign(Value(30)) |*s.get_unchecked(prev_len + i - 1) = (digit.u32() + '0').u8()
    Value(35): int = Lit(Int(1, 0)) |1
    Value(36): int = Call(Fun(270), Range { start: Value(29), end: Value(31) }) |i -= 1
    Value(36): int = Assign(Value(17)) |i -= 1
    Jump(Inst(21), Range { start: Value(0), end: Value(0) }) |loop:
      if i == 0:
        break
      var digit = value % 10
      value = value / 10
      *s.get_unchecked(prev_len + i - 1) = (digit.u32() + '0').u8()
      i -= 1

  Inst22Range { start: Value(0), end: Value(0) }
    Return(None) |loop:
      if i == 0:
        break
      var digit = value % 10
      value = value / 10
      *s.get_unchecked(prev_len + i - 1) = (digit.u32() + '0').u8()
      i -= 1


function u0:0(i64, i64) fast {
    sig0 = (f64) -> f64 windows_fastcall
    sig1 = (i64, i64) fast
    sig2 = (i64, i64) -> i64 fast
    fn0 = u0:21 sig0
    fn1 = colocated u0:3 sig1
    fn2 = colocated u0:1 sig2

block0(v0: i64, v1: i64):
    v37 = iconst.i64 0
    v36 -> v37
    v33 = iconst.i64 0
    v11 -> v33
    v32 = iconst.i64 0
    v10 -> v32
    v2 = load.i64 v0+8
    v3 = fcvt_from_sint.f64 v1
    v4 = call fn0(v3)
    v5 = fcvt_to_sint.i64 v4
    v6 = iconst.i64 1
    v7 = iadd v5, v6
    v8 = iadd v2, v7
    call fn1(v0, v8)
    v9 = iadd v2, v7
    store v9, v0+8
    jump block1(v7, v1, v36)

block1(v13: i64, v34: i64, v35: i64):
    v21 -> v13
    v16 -> v34
    v18 -> v35
    v12 = iconst.i64 0
    v14 = icmp eq v13, v12
    brnz v14, block2
    jump block3

block2:
    jump block4

block3:
    v15 = iconst.i64 10
    v17 = srem.i64 v16, v15
    v19 = iconst.i64 10
    v20 = sdiv.i64 v16, v19
    v22 = iadd.i64 v2, v21
    v23 = iconst.i64 1
    v24 = isub v22, v23
    v25 = call fn2(v0, v24)
    v26 = ireduce.i32 v17
    v27 = iconst.i32 48
    v28 = iadd v26, v27
    v29 = ireduce.i8 v28
    store v29, v25
    v30 = iconst.i64 1
    v31 = isub.i64 v21, v30
    jump block1(v31, v20, v17)

block4:
    return
}

fun pub pop_frame

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(2): &Seq[StackFrame] = Ref(Value(0)) |stacktrace.pop()
    Value(1): Option[StackFrame] = Call(Fun(483), Range { start: Value(0), end: Value(2) }) |stacktrace.pop()
    Return(None) |stacktrace.pop()


function u0:0() fast {
    ss0 = explicit_slot 32
    gv0 = symbol colocated u1:0
    sig0 = (i64, i64 sret) -> i64 sret fast
    fn0 = colocated u0:6 sig0

block0:
    v0 = global_value.i64 gv0
    v1 = stack_addr.i64 ss0
    v2 = call fn0(v0, v1)
    return
}

fun pop(s: &Self) -> Option[T]

  Inst1Range { start: Value(0), end: Value(2) }
    Value(3): &Seq[StackFrame] = Offset(Value(0)) |s.len
    Value(4): Seq[StackFrame] = Deref(Value(3), false) |s.len
    Value(2): int = Offset(Value(4)) |s.len
    Value(5): int = Lit(Int(0, 0)) |0
    Value(6): bool = Call(Fun(310), Range { start: Value(2), end: Value(4) }) |s.len == 0
    JumpIfTrue(Value(6), Inst(7), Range { start: Value(0), end: Value(0) }) |s.len == 0
    Jump(Inst(9), Range { start: Value(0), end: Value(0) }) |

  Inst7Range { start: Value(0), end: Value(0) }
    Value(7): Option[StackFrame] = Zeroed |return
    Value(8): Option[StackFrame] = Deref(Value(1), false) |return
    Value(7): Option[StackFrame] = Assign(Value(8)) |return
    Return(Some(Value(1))) |return

  Inst9Range { start: Value(0), end: Value(0) }
    Value(10): &Seq[StackFrame] = Offset(Value(0)) |s.len
    Value(11): Seq[StackFrame] = Deref(Value(10), false) |s.len
    Value(9): int = Offset(Value(11)) |s.len
    Value(12): int = Lit(Int(1, 0)) |1
    Value(13): int = Call(Fun(270), Range { start: Value(4), end: Value(6) }) |s.len - 1
    Value(14): &StackFrame = Call(Fun(484), Range { start: Value(6), end: Value(8) }) |s.get_unchecked(s.len - 1)
    Value(15): StackFrame = Deref(Value(14), false) |*s.get_unchecked(s.len - 1)
    Value(16): StackFrame = VarDecl(Value(15)) |value = *s.get_unchecked(s.len - 1)
    Value(18): &Seq[StackFrame] = Offset(Value(0)) |s.len
    Value(19): Seq[StackFrame] = Deref(Value(18), false) |s.len
    Value(17): int = Offset(Value(19)) |s.len
    Value(21): &Seq[StackFrame] = Offset(Value(0)) |s.len
    Value(22): Seq[StackFrame] = Deref(Value(21), false) |s.len
    Value(20): int = Offset(Value(22)) |s.len
    Value(23): int = Lit(Int(1, 0)) |1
    Value(24): int = Call(Fun(270), Range { start: Value(8), end: Value(10) }) |s.len -= 1
    Value(24): int = Assign(Value(17)) |s.len -= 1
    Value(25): Option[StackFrame] = Call(Fun(485), Range { start: Value(10), end: Value(12) }) |Option::some(value)
    Value(26): Option[StackFrame] = Deref(Value(1), false) |Option::some(value)
    Value(25): Option[StackFrame] = Assign(Value(26)) |Option::some(value)
    Return(Some(Value(1))) |Option::some(value)


function u0:0(i64, i64 sret) -> i64 sret fast {
    ss0 = explicit_slot 24
    ss1 = explicit_slot 32
    sig0 = (i64, i64) -> i64 fast
    sig1 = (i64, i64 sret) -> i64 sret fast
    fn0 = colocated u0:8 sig0
    fn1 = colocated u0:7 sig1

block0(v0: i64, v1: i64):
    v2 = iconst.i64 0
    v3 = load.i64 v0+8
    v4 = icmp eq v3, v2
    brnz v4, block1
    jump block2

block1:
    v5 = iconst.i64 0
    store v5, v1
    store v5, v1+8
    store v5, v1+16
    store v5, v1+24
    return v1

block2:
    v6 = iconst.i64 1
    v7 = load.i64 v0+8
    v8 = isub v7, v6
    v9 = call fn0(v0, v8)
    v10 = stack_addr.i64 ss0
    v11 = load.i64 v9
    store v11, v10
    v12 = load.i64 v9+8
    store v12, v10+8
    v13 = load.i64 v9+16
    store v13, v10+16
    v14 = iconst.i64 1
    v15 = load.i64 v0+8
    v16 = isub v15, v14
    store v16, v0+8
    v17 = stack_addr.i64 ss0
    v18 = stack_addr.i64 ss1
    v19 = call fn1(v17, v18)
    v20 = stack_addr.i64 ss1
    v21 = load.i64 v20
    store v21, v1
    v22 = load.i64 v20+8
    store v22, v1+8
    v23 = load.i64 v20+16
    store v23, v1+16
    v24 = load.i64 v20+24
    store v24, v1+24
    return v1
}

fun some(value: T) -> Self

  Inst1Range { start: Value(0), end: Value(2) }
    Value(2): Option[StackFrame] = Zeroed |option: Self
    Value(3): Option[StackFrame] = VarDecl(Value(2)) |option: Self
    Value(4): StackFrame = Offset(Value(3)) |option.value
    Value(0): StackFrame = Assign(Value(4)) |option.value = value
    Value(5): bool = Offset(Value(3)) |option.is_some
    Value(6): bool = Lit(Bool(true)) |true
    Value(6): bool = Assign(Value(5)) |option.is_some = true
    Value(7): Option[StackFrame] = Deref(Value(1), false) |option
    Value(3): Option[StackFrame] = Assign(Value(7)) |option
    Return(Some(Value(1))) |option


function u0:0(i64, i64 sret) -> i64 sret fast {
    ss0 = explicit_slot 32

block0(v0: i64, v1: i64):
    v2 = iconst.i64 0
    stack_store v2, ss0
    stack_store v2, ss0+8
    stack_store v2, ss0+16
    stack_store v2, ss0+24
    v3 = stack_addr.i64 ss0
    v4 = load.i64 v0
    store v4, v3
    v5 = load.i64 v0+8
    store v5, v3+8
    v6 = load.i64 v0+16
    store v6, v3+16
    v7 = bconst.b1 true
    v8 = bint.i8 v7
    stack_store v8, ss0+24
    v9 = stack_addr.i64 ss0
    v10 = load.i64 v9
    store v10, v1
    v11 = load.i64 v9+8
    store v11, v1+8
    v12 = load.i64 v9+16
    store v12, v1+16
    v13 = load.i64 v9+24
    store v13, v1+24
    return v1
}

fun get_unchecked(s: &Self, index: int) -> &T

  Inst1Range { start: Value(0), end: Value(2) }
    Value(3): &Seq[StackFrame] = Offset(Value(0)) |s.data
    Value(4): Seq[StackFrame] = Deref(Value(3), false) |s.data
    Value(2): &StackFrame = Offset(Value(4)) |s.data
    Value(5): int = Cast(Value(2)) |s.data as int
    Value(6): int = Call(Fun(486), Range { start: Value(2), end: Value(2) }) |sizeof::[T]()
    Value(7): int = Call(Fun(280), Range { start: Value(2), end: Value(4) }) |index * sizeof::[T]()
    Value(8): int = Call(Fun(260), Range { start: Value(4), end: Value(6) }) |(s.data as int + index * sizeof::[T]())
    Value(9): &StackFrame = Cast(Value(8)) |(s.data as int + index * sizeof::[T]()) as &T
    Return(Some(Value(9))) |(s.data as int + index * sizeof::[T]()) as &T


function u0:0(i64, i64) -> i64 fast {
block0(v0: i64, v1: i64):
    v2 = iconst.i64 24
    v3 = imul v1, v2
    v4 = load.i64 v0
    v5 = iadd v4, v3
    return v5
}

fun pub sizeof[T] -> int


fun pub push_frame(line, column: int, file: &u8)

  Inst1Range { start: Value(0), end: Value(3) }
    Value(3): StackFrame = Zeroed |frame: StackFrame
    Value(4): StackFrame = VarDecl(Value(3)) |frame: StackFrame
    Value(5): int = Offset(Value(4)) |frame.line
    Value(0): int = Assign(Value(5)) |frame.line = line
    Value(6): int = Offset(Value(4)) |frame.column
    Value(1): int = Assign(Value(6)) |frame.column = column
    Value(7): &u8 = Offset(Value(4)) |frame.file
    Value(2): &u8 = Assign(Value(7)) |frame.file = file
    Value(8): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(9): &Seq[StackFrame] = Ref(Value(8)) |stacktrace.push(frame)
    Call(Fun(487), Range { start: Value(3), end: Value(5) }) |stacktrace.push(frame)
    Return(None) |stacktrace.push(frame)


function u0:0(i64, i64, i64) fast {
    ss0 = explicit_slot 24
    gv0 = symbol colocated u1:0
    sig0 = (i64, i64) fast
    fn0 = colocated u0:11 sig0

block0(v0: i64, v1: i64, v2: i64):
    v3 = iconst.i64 0
    stack_store v3, ss0
    stack_store v3, ss0+8
    stack_store v3, ss0+16
    stack_store v0, ss0
    stack_store v1, ss0+8
    stack_store v2, ss0+16
    v4 = global_value.i64 gv0
    v5 = stack_addr.i64 ss0
    call fn0(v4, v5)
    return
}

fun push(s: &Self, value: T)

  Inst1Range { start: Value(0), end: Value(2) }
    Value(3): &Seq[StackFrame] = Offset(Value(0)) |s.len
    Value(4): Seq[StackFrame] = Deref(Value(3), false) |s.len
    Value(2): int = Offset(Value(4)) |s.len
    Value(5): int = Lit(Int(1, 0)) |1
    Value(6): int = Call(Fun(260), Range { start: Value(2), end: Value(4) }) |s.len + 1
    Value(7): int = VarDecl(Value(6)) |new_len = s.len + 1
    Value(9): &Seq[StackFrame] = Offset(Value(0)) |s.cap
    Value(10): Seq[StackFrame] = Deref(Value(9), false) |s.cap
    Value(8): int = Offset(Value(10)) |s.cap
    Value(11): bool = Call(Fun(350), Range { start: Value(4), end: Value(6) }) |new_len > s.cap
    JumpIfTrue(Value(11), Inst(12), Range { start: Value(0), end: Value(0) }) |new_len > s.cap
    Jump(Inst(14), Range { start: Value(0), end: Value(0) }) |

  Inst12Range { start: Value(0), end: Value(0) }
    Value(13): &Seq[StackFrame] = Offset(Value(0)) |s.cap
    Value(14): Seq[StackFrame] = Deref(Value(13), false) |s.cap
    Value(12): int = Offset(Value(14)) |s.cap
    Value(16): &Seq[StackFrame] = Offset(Value(0)) |s.len
    Value(17): Seq[StackFrame] = Deref(Value(16), false) |s.len
    Value(15): int = Offset(Value(17)) |s.len
    Value(18): int = Lit(Int(2, 0)) |2
    Value(19): int = Call(Fun(280), Range { start: Value(6), end: Value(8) }) |s.len * 2
    Value(19): int = Assign(Value(12)) |s.cap = s.len * 2
    Value(21): &Seq[StackFrame] = Offset(Value(0)) |s.data
    Value(22): Seq[StackFrame] = Deref(Value(21), false) |s.data
    Value(20): &StackFrame = Offset(Value(22)) |s.data
    Value(24): &Seq[StackFrame] = Offset(Value(0)) |s.data
    Value(25): Seq[StackFrame] = Deref(Value(24), false) |s.data
    Value(23): &StackFrame = Offset(Value(25)) |s.data
    Value(26): &u8 = Cast(Value(23)) |s.data as &u8
    Value(28): &Seq[StackFrame] = Offset(Value(0)) |s.cap
    Value(29): Seq[StackFrame] = Deref(Value(28), false) |s.cap
    Value(27): int = Offset(Value(29)) |s.cap
    Value(30): int = Call(Fun(486), Range { start: Value(8), end: Value(8) }) |sizeof::[T]()
    Value(31): int = Call(Fun(280), Range { start: Value(8), end: Value(10) }) |s.cap * sizeof::[T]()
    Value(32): &u8 = Call(Fun(438), Range { start: Value(10), end: Value(12) }) |realloc(s.data as &u8, s.cap * sizeof::[T]())
    Value(33): &StackFrame = Cast(Value(32)) |realloc(s.data as &u8, s.cap * sizeof::[T]()) as &T
    Value(33): &StackFrame = Assign(Value(20)) |s.data = realloc(s.data as &u8, s.cap * sizeof::[T]()) as &T
    Jump(Inst(14), Range { start: Value(0), end: Value(0) }) |if new_len > s.cap:
      s.cap = s.len * 2
      s.data = realloc(s.data as &u8, s.cap * sizeof::[T]()) as &T
      pass

  Inst14Range { start: Value(0), end: Value(0) }
    Value(35): &Seq[StackFrame] = Offset(Value(0)) |s.len
    Value(36): Seq[StackFrame] = Deref(Value(35), false) |s.len
    Value(34): int = Offset(Value(36)) |s.len
    Value(37): &StackFrame = Call(Fun(484), Range { start: Value(12), end: Value(14) }) |s.get_unchecked(s.len)
    Value(38): StackFrame = Deref(Value(37), true) |*s.get_unchecked(s.len)
    Value(1): StackFrame = Assign(Value(38)) |*s.get_unchecked(s.len) = value
    Value(40): &Seq[StackFrame] = Offset(Value(0)) |s.len
    Value(41): Seq[StackFrame] = Deref(Value(40), false) |s.len
    Value(39): int = Offset(Value(41)) |s.len
    Value(7): int = Assign(Value(39)) |s.len = new_len
    Return(None) |s.len = new_len


function u0:0(i64, i64) fast {
    sig0 = (i64, i64) -> i64 windows_fastcall
    sig1 = (i64, i64) -> i64 fast
    fn0 = u0:27 sig0
    fn1 = colocated u0:8 sig1

block0(v0: i64, v1: i64):
    v2 = iconst.i64 1
    v3 = load.i64 v0+8
    v4 = iadd v3, v2
    v5 = load.i64 v0+16
    v6 = icmp sgt v4, v5
    brnz v6, block1
    jump block2

block1:
    v7 = iconst.i64 2
    v8 = load.i64 v0+8
    v9 = imul v8, v7
    store v9, v0+16
    v10 = iconst.i64 24
    v11 = load.i64 v0+16
    v12 = imul v11, v10
    v13 = load.i64 v0
    v14 = call fn0(v13, v12)
    store v14, v0
    jump block2

block2:
    v15 = load.i64 v0+8
    v16 = call fn1(v0, v15)
    v17 = load.i64 v1
    store v17, v16
    v18 = load.i64 v1+8
    store v18, v16+8
    v19 = load.i64 v1+16
    store v19, v16+16
    store.i64 v4, v0+8
    return
}

fun pub panic(msg: &u8)

  Inst1Range { start: Value(0), end: Value(1) }
    Value(1): &u8 = Lit(String(Span { source: Source(0), hash: ID(13432806085582464995), start: 117, end: 125, line: 0, column: 0 })) |"panic: "
    Call(Fun(446), Range { start: Value(1), end: Value(2) }) |print("panic: ")
    Call(Fun(446), Range { start: Value(2), end: Value(3) }) |print(msg)
    Value(2): &u8 = Lit(String(Span { source: Source(0), hash: ID(655990), start: 125, end: 127, line: 0, column: 0 })) |"\n"
    Call(Fun(446), Range { start: Value(3), end: Value(4) }) |print("\n")
    Value(3): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(4): int = Offset(Value(3)) |stacktrace.len
    Value(5): int = Lit(Int(0, 0)) |0
    Value(6): bool = Call(Fun(310), Range { start: Value(4), end: Value(6) }) |stacktrace.len == 0
    JumpIfTrue(Value(6), Inst(11), Range { start: Value(0), end: Value(0) }) |stacktrace.len == 0
    Jump(Inst(13), Range { start: Value(0), end: Value(0) }) |

  Inst11Range { start: Value(0), end: Value(0) }
    Value(7): &u8 = Lit(String(Span { source: Source(0), hash: ID(5614517716665998117), start: 127, end: 203, line: 0, column: 0 })) |"no stacktrace available, use '-trace' when building to generate stacktrace\n"
    Call(Fun(446), Range { start: Value(6), end: Value(7) }) |print("no stacktrace available, use '-trace' when building to generate stacktrace\n")
    Value(8): int = Lit(Int(1, 0)) |1
    Call(Fun(447), Range { start: Value(7), end: Value(8) }) |exit(1)
    Return(None) |return

  Inst13Range { start: Value(0), end: Value(0) }
    Value(9): Seq[u8] = Zeroed |buffer: Seq[u8]
    Value(10): Seq[u8] = VarDecl(Value(9)) |buffer: Seq[u8]
    Value(11): int = Zeroed |i: int
    Value(12): int = VarDecl(Value(11)) |i: int
    Jump(Inst(26), Range { start: Value(0), end: Value(0) }) |loop:
    if i >= stacktrace.len:
      break
    
    var frame = stacktrace[i]
    
    buffer.print_int(frame.line)
    buffer.push(':'.u8())
    buffer.print_int(frame.column)
    buffer.push(' '.u8())
    buffer.print(frame.file)
    buffer.push('\n'.u8())

    i += 1

  Inst26Range { start: Value(0), end: Value(0) }
    Value(13): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(14): int = Offset(Value(13)) |stacktrace.len
    Value(15): bool = Call(Fun(330), Range { start: Value(8), end: Value(10) }) |i >= stacktrace.len
    JumpIfTrue(Value(15), Inst(33), Range { start: Value(0), end: Value(0) }) |i >= stacktrace.len
    Jump(Inst(35), Range { start: Value(0), end: Value(0) }) |

  Inst33Range { start: Value(0), end: Value(0) }
    Jump(Inst(27), Range { start: Value(0), end: Value(0) }) |break

  Inst35Range { start: Value(0), end: Value(0) }
    Value(16): Seq[StackFrame] = GlobalLoad(Global(0)) |stacktrace
    Value(18): &Seq[StackFrame] = Ref(Value(16)) |stacktrace[i]
    Value(17): &StackFrame = Call(Fun(488), Range { start: Value(10), end: Value(12) }) |stacktrace[i]
    Value(19): StackFrame = Deref(Value(17), false) |stacktrace[i]
    Value(20): StackFrame = VarDecl(Value(19)) |frame = stacktrace[i]
    Value(21): int = Offset(Value(20)) |frame.line
    Value(22): &Seq[u8] = Ref(Value(10)) |buffer.print_int(frame.line)
    Call(Fun(459), Range { start: Value(12), end: Value(14) }) |buffer.print_int(frame.line)
    Value(23): u32 = Lit(Char(':')) |':'
    Value(24): u8 = Call(Fun(63), Range { start: Value(14), end: Value(15) }) |':'.u8()
    Value(25): &Seq[u8] = Ref(Value(10)) |buffer.push(':'.u8())
    Call(Fun(489), Range { start: Value(15), end: Value(17) }) |buffer.push(':'.u8())
    Value(26): int = Offset(Value(20)) |frame.column
    Value(27): &Seq[u8] = Ref(Value(10)) |buffer.print_int(frame.column)
    Call(Fun(459), Range { start: Value(17), end: Value(19) }) |buffer.print_int(frame.column)
    Value(28): u32 = Lit(Char(' ')) |' '
    Value(29): u8 = Call(Fun(63), Range { start: Value(19), end: Value(20) }) |' '.u8()
    Value(30): &Seq[u8] = Ref(Value(10)) |buffer.push(' '.u8())
    Call(Fun(489), Range { start: Value(20), end: Value(22) }) |buffer.push(' '.u8())
    Value(31): &u8 = Offset(Value(20)) |frame.file
    Value(32): &Seq[u8] = Ref(Value(10)) |buffer.print(frame.file)
    Call(Fun(460), Range { start: Value(22), end: Value(24) }) |buffer.print(frame.file)
    Value(33): u32 = Lit(Char('\n')) |'\n'
    Value(34): u8 = Call(Fun(63), Range { start: Value(24), end: Value(25) }) |'\n'.u8()
    Value(35): &Seq[u8] = Ref(Value(10)) |buffer.push('\n'.u8())
    Call(Fun(489), Range { start: Value(25), end: Value(27) }) |buffer.push('\n'.u8())
    Value(36): int = Lit(Int(1, 0)) |1
    Value(37): int = Call(Fun(260), Range { start: Value(27), end: Value(29) }) |i += 1
    Value(37): int = Assign(Value(12)) |i += 1
    Jump(Inst(26), Range { start: Value(0), end: Value(0) }) |loop:
    if i >= stacktrace.len:
      break
    
    var frame = stacktrace[i]
    
    buffer.print_int(frame.line)
    buffer.push(':'.u8())
    buffer.print_int(frame.column)
    buffer.push(' '.u8())
    buffer.print(frame.file)
    buffer.push('\n'.u8())

    i += 1

  Inst27Range { start: Value(0), end: Value(0) }
    Value(38): u32 = Lit(Char('\u{0}')) |'\0'
    Value(39): u8 = Call(Fun(63), Range { start: Value(29), end: Value(30) }) |'\0'.u8()
    Value(40): &Seq[u8] = Ref(Value(10)) |buffer.push('\0'.u8())
    Call(Fun(489), Range { start: Value(30), end: Value(32) }) |buffer.push('\0'.u8())
    Value(41): &u8 = Offset(Value(10)) |buffer.data
    Call(Fun(446), Range { start: Value(32), end: Value(33) }) |print(buffer.data)
    Value(42): int = Lit(Int(1, 0)) |1
    Call(Fun(447), Range { start: Value(33), end: Value(34) }) |exit(1)
    Return(None) |exit(1)


function u0:0(i64) fast {
    ss0 = explicit_slot 24
    ss1 = explicit_slot 24
    gv0 = symbol colocated u1:1
    gv1 = symbol colocated u1:2
    gv2 = symbol colocated u1:0
    gv3 = symbol colocated u1:3
    sig0 = (i64) windows_fastcall
    sig1 = (i64) windows_fastcall
    sig2 = (i64, i64) -> i64 fast
    sig3 = (i64, i64) fast
    sig4 = (i64, i8) fast
    sig5 = (i64, i64) fast
    fn0 = u0:19 sig0
    fn1 = u0:18 sig1
    fn2 = colocated u0:14 sig2
    fn3 = colocated u0:4 sig3
    fn4 = colocated u0:13 sig4
    fn5 = colocated u0:0 sig5

block0(v0: i64):
    v46 = iconst.i64 0
    v11 -> v46
    v45 -> v46
    v1 = global_value.i64 gv0
    call fn0(v1)
    call fn0(v0)
    v2 = global_value.i64 gv1
    call fn0(v2)
    v3 = global_value.i64 gv2
    v4 = iconst.i64 0
    v5 = load.i64 v3+8
    v6 = icmp eq v5, v4
    brnz v6, block1
    jump block2

block1:
    v7 = global_value.i64 gv3
    call fn0(v7)
    v8 = iconst.i64 1
    call fn1(v8)
    return

block2:
    v9 = iconst.i64 0
    stack_store v9, ss0
    stack_store v9, ss0+8
    stack_store v9, ss0+16
    v10 = iconst.i64 0
    jump block3(v10)

block3(v13: i64):
    v17 -> v13
    v12 = global_value.i64 gv2
    v14 = load.i64 v12+8
    v15 = icmp sge v13, v14
    brnz v15, block4
    jump block5

block4:
    jump block6

block5:
    v16 = global_value.i64 gv2
    v18 = call fn2(v16, v17)
    v19 = stack_addr.i64 ss1
    v20 = load.i64 v18
    store v20, v19
    v21 = load.i64 v18+8
    store v21, v19+8
    v22 = load.i64 v18+16
    store v22, v19+16
    v23 = stack_addr.i64 ss0
    v24 = stack_load.i64 ss1
    call fn3(v23, v24)
    v25 = iconst.i32 58
    v26 = ireduce.i8 v25
    v27 = stack_addr.i64 ss0
    call fn4(v27, v26)
    v28 = stack_addr.i64 ss0
    v29 = stack_load.i64 ss1+8
    call fn3(v28, v29)
    v30 = iconst.i32 32
    v31 = ireduce.i8 v30
    v32 = stack_addr.i64 ss0
    call fn4(v32, v31)
    v33 = stack_addr.i64 ss0
    v34 = stack_load.i64 ss1+16
    call fn5(v33, v34)
    v35 = iconst.i32 10
    v36 = ireduce.i8 v35
    v37 = stack_addr.i64 ss0
    call fn4(v37, v36)
    v38 = iconst.i64 1
    v39 = iadd.i64 v17, v38
    jump block3(v39)

block6:
    v40 = iconst.i32 0
    v41 = ireduce.i8 v40
    v42 = stack_addr.i64 ss0
    call fn4(v42, v41)
    v43 = stack_load.i64 ss0
    call fn0(v43)
    v44 = iconst.i64 1
    call fn1(v44)
    return
}

fun push(s: &Self, value: T)

  Inst1Range { start: Value(0), end: Value(2) }
    Value(3): &Seq[u8] = Offset(Value(0)) |s.len
    Value(4): Seq[u8] = Deref(Value(3), false) |s.len
    Value(2): int = Offset(Value(4)) |s.len
    Value(5): int = Lit(Int(1, 0)) |1
    Value(6): int = Call(Fun(260), Range { start: Value(2), end: Value(4) }) |s.len + 1
    Value(7): int = VarDecl(Value(6)) |new_len = s.len + 1
    Value(9): &Seq[u8] = Offset(Value(0)) |s.cap
    Value(10): Seq[u8] = Deref(Value(9), false) |s.cap
    Value(8): int = Offset(Value(10)) |s.cap
    Value(11): bool = Call(Fun(350), Range { start: Value(4), end: Value(6) }) |new_len > s.cap
    JumpIfTrue(Value(11), Inst(12), Range { start: Value(0), end: Value(0) }) |new_len > s.cap
    Jump(Inst(14), Range { start: Value(0), end: Value(0) }) |

  Inst12Range { start: Value(0), end: Value(0) }
    Value(13): &Seq[u8] = Offset(Value(0)) |s.cap
    Value(14): Seq[u8] = Deref(Value(13), false) |s.cap
    Value(12): int = Offset(Value(14)) |s.cap
    Value(16): &Seq[u8] = Offset(Value(0)) |s.len
    Value(17): Seq[u8] = Deref(Value(16), false) |s.len
    Value(15): int = Offset(Value(17)) |s.len
    Value(18): int = Lit(Int(2, 0)) |2
    Value(19): int = Call(Fun(280), Range { start: Value(6), end: Value(8) }) |s.len * 2
    Value(19): int = Assign(Value(12)) |s.cap = s.len * 2
    Value(21): &Seq[u8] = Offset(Value(0)) |s.data
    Value(22): Seq[u8] = Deref(Value(21), false) |s.data
    Value(20): &u8 = Offset(Value(22)) |s.data
    Value(24): &Seq[u8] = Offset(Value(0)) |s.data
    Value(25): Seq[u8] = Deref(Value(24), false) |s.data
    Value(23): &u8 = Offset(Value(25)) |s.data
    Value(26): &u8 = Cast(Value(23)) |s.data as &u8
    Value(28): &Seq[u8] = Offset(Value(0)) |s.cap
    Value(29): Seq[u8] = Deref(Value(28), false) |s.cap
    Value(27): int = Offset(Value(29)) |s.cap
    Value(30): int = Call(Fun(482), Range { start: Value(8), end: Value(8) }) |sizeof::[T]()
    Value(31): int = Call(Fun(280), Range { start: Value(8), end: Value(10) }) |s.cap * sizeof::[T]()
    Value(32): &u8 = Call(Fun(438), Range { start: Value(10), end: Value(12) }) |realloc(s.data as &u8, s.cap * sizeof::[T]())
    Value(33): &u8 = Cast(Value(32)) |realloc(s.data as &u8, s.cap * sizeof::[T]()) as &T
    Value(33): &u8 = Assign(Value(20)) |s.data = realloc(s.data as &u8, s.cap * sizeof::[T]()) as &T
    Jump(Inst(14), Range { start: Value(0), end: Value(0) }) |if new_len > s.cap:
      s.cap = s.len * 2
      s.data = realloc(s.data as &u8, s.cap * sizeof::[T]()) as &T
      pass

  Inst14Range { start: Value(0), end: Value(0) }
    Value(35): &Seq[u8] = Offset(Value(0)) |s.len
    Value(36): Seq[u8] = Deref(Value(35), false) |s.len
    Value(34): int = Offset(Value(36)) |s.len
    Value(37): &u8 = Call(Fun(481), Range { start: Value(12), end: Value(14) }) |s.get_unchecked(s.len)
    Value(38): u8 = Deref(Value(37), true) |*s.get_unchecked(s.len)
    Value(1): u8 = Assign(Value(38)) |*s.get_unchecked(s.len) = value
    Value(40): &Seq[u8] = Offset(Value(0)) |s.len
    Value(41): Seq[u8] = Deref(Value(40), false) |s.len
    Value(39): int = Offset(Value(41)) |s.len
    Value(7): int = Assign(Value(39)) |s.len = new_len
    Return(None) |s.len = new_len


function u0:0(i64, i8) fast {
    sig0 = (i64, i64) -> i64 windows_fastcall
    sig1 = (i64, i64) -> i64 fast
    fn0 = u0:27 sig0
    fn1 = colocated u0:1 sig1

block0(v0: i64, v1: i8):
    v2 = iconst.i64 1
    v3 = load.i64 v0+8
    v4 = iadd v3, v2
    v5 = load.i64 v0+16
    v6 = icmp sgt v4, v5
    brnz v6, block1
    jump block2

block1:
    v7 = iconst.i64 2
    v8 = load.i64 v0+8
    v9 = imul v8, v7
    store v9, v0+16
    v10 = iconst.i64 1
    v11 = load.i64 v0+16
    v12 = imul v11, v10
    v13 = load.i64 v0
    v14 = call fn0(v13, v12)
    store v14, v0
    jump block2

block2:
    v15 = load.i64 v0+8
    v16 = call fn1(v0, v15)
    store.i8 v1, v16
    store.i64 v4, v0+8
    return
}

fun __index__(s: &Self, index: int) -> &T

  Inst1Range { start: Value(0), end: Value(2) }
    Call(Fun(490), Range { start: Value(2), end: Value(4) }) |s.assert_in_bounds(index)
    Value(2): &StackFrame = Call(Fun(484), Range { start: Value(4), end: Value(6) }) |s.get_unchecked(index)
    Return(Some(Value(2))) |s.get_unchecked(index)


function u0:0(i64, i64) -> i64 fast {
    sig0 = (i64, i64) fast
    sig1 = (i64, i64) -> i64 fast
    fn0 = colocated u0:15 sig0
    fn1 = colocated u0:8 sig1

block0(v0: i64, v1: i64):
    call fn0(v0, v1)
    v2 = call fn1(v0, v1)
    return v2
}

fun assert_in_bounds(s: &Self, index: int)

  Inst1Range { start: Value(0), end: Value(2) }
    Value(2): bool = Call(Fun(491), Range { start: Value(2), end: Value(4) }) |s.in_bounds(index)
    Value(3): bool = Call(Fun(251), Range { start: Value(4), end: Value(5) }) |!s.in_bounds(index)
    JumpIfTrue(Value(3), Inst(4), Range { start: Value(0), end: Value(0) }) |!s.in_bounds(index)
    Jump(Inst(6), Range { start: Value(0), end: Value(0) }) |

  Inst4Range { start: Value(0), end: Value(0) }
    Value(4): &u8 = Lit(String(Span { source: Source(0), hash: ID(6484216913505728610), start: 203, end: 223, line: 0, column: 0 })) |"index out of bounds"
    Call(Fun(449), Range { start: Value(5), end: Value(6) }) |panic("index out of bounds")
    Jump(Inst(6), Range { start: Value(0), end: Value(0) }) |if !s.in_bounds(index):
      panic("index out of bounds")

  Inst6Range { start: Value(0), end: Value(0) }
    Return(None) |if !s.in_bounds(index):
      panic("index out of bounds")


function u0:0(i64, i64) fast {
    gv0 = symbol colocated u1:4
    sig0 = (i64, i64) -> b1 fast
    sig1 = (i64) fast
    fn0 = colocated u0:16 sig0
    fn1 = colocated u0:12 sig1

block0(v0: i64, v1: i64):
    v2 = call fn0(v0, v1)
    v3 = bint.i8 v2
    v4 = icmp_imm eq v3, 0
    brnz v4, block1
    jump block2

block1:
    v5 = global_value.i64 gv0
    call fn1(v5)
    jump block2

block2:
    return
}

fun in_bounds(s: &Self, index: int) -> bool

  Inst1Range { start: Value(0), end: Value(2) }
    Value(2): int = Lit(Int(0, 0)) |0
    Value(3): bool = Call(Fun(330), Range { start: Value(2), end: Value(4) }) |index >= 0
    Value(5): &Seq[StackFrame] = Offset(Value(0)) |s.len
    Value(6): Seq[StackFrame] = Deref(Value(5), false) |s.len
    Value(4): int = Offset(Value(6)) |s.len
    Value(7): bool = Call(Fun(360), Range { start: Value(4), end: Value(6) }) |index < s.len
    Value(8): bool = Call(Fun(436), Range { start: Value(6), end: Value(8) }) |index >= 0 & index < s.len
    Return(Some(Value(8))) |index >= 0 & index < s.len


function u0:0(i64, i64) -> b1 fast {
block0(v0: i64, v1: i64):
    v2 = iconst.i64 0
    v3 = icmp sge v1, v2
    v4 = load.i64 v0+8
    v5 = icmp slt v1, v4
    v6 = band v3, v5
    return v6
}

fun pub assert(cond: bool)

  Inst1Range { start: Value(0), end: Value(1) }
    Value(1): bool = Call(Fun(251), Range { start: Value(1), end: Value(2) }) |!cond
    JumpIfTrue(Value(1), Inst(3), Range { start: Value(0), end: Value(0) }) |!cond
    Jump(Inst(5), Range { start: Value(0), end: Value(0) }) |

  Inst3Range { start: Value(0), end: Value(0) }
    Value(2): &u8 = Lit(String(Span { source: Source(0), hash: ID(18405710474171729989), start: 100, end: 117, line: 0, column: 0 })) |"assertion failed"
    Call(Fun(449), Range { start: Value(2), end: Value(3) }) |panic("assertion failed")
    Jump(Inst(5), Range { start: Value(0), end: Value(0) }) |if !cond: panic("assertion failed")

  Inst5Range { start: Value(0), end: Value(0) }
    Return(None) |if !cond: panic("assertion failed")


function u0:0(b1) fast {
    gv0 = symbol colocated u1:5
    sig0 = (i64) fast
    fn0 = colocated u0:12 sig0

block0(v0: b1):
    v1 = bint.i8 v0
    v2 = icmp_imm eq v1, 0
    brnz v2, block1
    jump block2

block1:
    v3 = global_value.i64 gv0
    call fn0(v3)
    jump block2

block2:
    return
}

fun calls_a

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): int = Lit(Int(231, 0)) |calls_b()
    Value(1): int = Lit(Int(10, 0)) |calls_b()
    Value(2): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |calls_b()
    Call(Fun(450), Range { start: Value(0), end: Value(3) }) |calls_b()
    Call(Fun(516), Range { start: Value(3), end: Value(3) }) |calls_b()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |calls_b()
    Return(None) |calls_b()


function u0:0() fast {
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = () fast
    sig2 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:29 sig1
    fn2 = colocated u0:5 sig2

block0:
    v0 = iconst.i64 231
    v1 = iconst.i64 10
    v2 = global_value.i64 gv0
    call fn0(v0, v1, v2)
    jump block1

block1:
    v3 = iconst.i64 227
    v4 = iconst.i64 10
    v5 = global_value.i64 gv0
    call fn0(v3, v4, v5)
    v6 = iconst.i64 227
    v7 = iconst.i64 10
    v8 = global_value.i64 gv0
    call fn0(v6, v7, v8)
    call fn1()
    call fn2()
    return

block2:
    call fn2()
    return
}

fun calls_b

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): int = Lit(Int(227, 0)) |calls_a()
    Value(1): int = Lit(Int(10, 0)) |calls_a()
    Value(2): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |calls_a()
    Call(Fun(450), Range { start: Value(0), end: Value(3) }) |calls_a()
    Call(Fun(517), Range { start: Value(3), end: Value(3) }) |calls_a()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |calls_a()
    Return(None) |calls_a()


function u0:0() fast {
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = () fast
    sig2 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:30 sig1
    fn2 = colocated u0:5 sig2

block0:
    v0 = iconst.i64 227
    v1 = iconst.i64 10
    v2 = global_value.i64 gv0
    call fn0(v0, v1, v2)
    jump block1

block1:
    v3 = iconst.i64 231
    v4 = iconst.i64 10
    v5 = global_value.i64 gv0
    call fn0(v3, v4, v5)
    v6 = iconst.i64 231
    v7 = iconst.i64 10
    v8 = global_value.i64 gv0
    call fn0(v6, v7, v8)
    call fn1()
    call fn2()
    return

block2:
    call fn2()
    return
}

fun assert(cond: bool)

  Inst1Range { start: Value(0), end: Value(1) }
    Value(1): int = Lit(Int(222, 0)) |builtin::assert(cond)
    Value(2): int = Lit(Int(10, 0)) |builtin::assert(cond)
    Value(3): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |builtin::assert(cond)
    Call(Fun(450), Range { start: Value(1), end: Value(4) }) |builtin::assert(cond)
    Call(Fun(448), Range { start: Value(4), end: Value(5) }) |builtin::assert(cond)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |builtin::assert(cond)
    Value(4): &u8 = Lit(String(Span { source: Source(0), hash: ID(31334373625102386), start: 338, end: 342, line: 0, column: 0 })) |"ok\n"
    Value(5): int = Lit(Int(223, 0)) |print("ok\n")
    Value(6): int = Lit(Int(8, 0)) |print("ok\n")
    Value(7): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |print("ok\n")
    Call(Fun(450), Range { start: Value(5), end: Value(8) }) |print("ok\n")
    Call(Fun(446), Range { start: Value(8), end: Value(9) }) |print("ok\n")
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |print("ok\n")
    Return(None) |print("ok\n")


function u0:0(b1) fast {
    gv0 = symbol colocated u1:8
    gv1 = symbol colocated u1:9
    sig0 = (i64, i64, i64) fast
    sig1 = (b1) fast
    sig2 = () fast
    sig3 = (i64) windows_fastcall
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:17 sig1
    fn2 = colocated u0:5 sig2
    fn3 = u0:19 sig3

block0(v0: b1):
    v1 = iconst.i64 222
    v2 = iconst.i64 10
    v3 = global_value.i64 gv0
    call fn0(v1, v2, v3)
    call fn1(v0)
    call fn2()
    v4 = global_value.i64 gv1
    v5 = iconst.i64 223
    v6 = iconst.i64 8
    v7 = global_value.i64 gv0
    call fn0(v5, v6, v7)
    call fn3(v4)
    call fn2()
    return
}

fun test_case_14

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): fn() -> int = FunPointer(Fun(513)) |test_fun
    Value(1): fn() -> int = VarDecl(Value(0)) |fun_pointer = test_fun
    Value(2): int = Lit(Int(219, 0)) |(*fun_pointer)()
    Value(3): int = Lit(Int(11, 0)) |(*fun_pointer)()
    Value(4): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |(*fun_pointer)()
    Call(Fun(450), Range { start: Value(0), end: Value(3) }) |(*fun_pointer)()
    Value(5): int = FunPointerCall(Value(1), Range { start: Value(3), end: Value(3) }) |(*fun_pointer)()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |(*fun_pointer)()
    Value(6): int = Lit(Int(1, 0)) |1
    Value(7): bool = Call(Fun(310), Range { start: Value(3), end: Value(5) }) |(*fun_pointer)() == 1
    Value(8): int = Lit(Int(219, 0)) |assert((*fun_pointer)() == 1)
    Value(9): int = Lit(Int(9, 0)) |assert((*fun_pointer)() == 1)
    Value(10): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert((*fun_pointer)() == 1)
    Call(Fun(450), Range { start: Value(5), end: Value(8) }) |assert((*fun_pointer)() == 1)
    Call(Fun(515), Range { start: Value(8), end: Value(9) }) |assert((*fun_pointer)() == 1)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert((*fun_pointer)() == 1)
    Return(None) |assert((*fun_pointer)() == 1)


function u0:0() fast {
    gv0 = symbol colocated u1:8
    sig0 = () -> i64 fast
    sig1 = (i64, i64, i64) fast
    sig2 = () -> i64 fast
    sig3 = () fast
    sig4 = (b1) fast
    fn0 = colocated u0:33 sig0
    fn1 = colocated u0:10 sig1
    fn2 = colocated u0:5 sig3
    fn3 = colocated u0:31 sig4

block0:
    v0 = func_addr.i64 fn0
    v1 = iconst.i64 219
    v2 = iconst.i64 11
    v3 = global_value.i64 gv0
    call fn1(v1, v2, v3)
    v4 = call_indirect sig2, v0()
    call fn2()
    v5 = iconst.i64 1
    v6 = icmp eq v4, v5
    v7 = iconst.i64 219
    v8 = iconst.i64 9
    v9 = global_value.i64 gv0
    call fn1(v7, v8, v9)
    call fn3(v6)
    call fn2()
    return
}

fun test_fun -> int

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): int = Lit(Int(1, 0)) |1
    Return(Some(Value(0))) |1


function u0:0() -> i64 fast {
block0:
    v0 = iconst.i64 1
    return v0
}

fun test_case_13

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): int = Lit(Int(1, 0)) |1
    Value(1): int = Lit(Int(1, 0)) |1
    Value(3): int = Lit(Int(213, 0)) |even_worse(1, 1)
    Value(4): int = Lit(Int(20, 0)) |even_worse(1, 1)
    Value(5): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |even_worse(1, 1)
    Call(Fun(450), Range { start: Value(0), end: Value(3) }) |even_worse(1, 1)
    Value(2): int = Call(Fun(511), Range { start: Value(3), end: Value(5) }) |even_worse(1, 1)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |even_worse(1, 1)
    Value(6): int = Lit(Int(0, 0)) |0
    Value(7): bool = Call(Fun(310), Range { start: Value(5), end: Value(7) }) |even_worse(1, 1) == 0
    Value(8): int = Lit(Int(213, 0)) |assert(even_worse(1, 1) == 0)
    Value(9): int = Lit(Int(9, 0)) |assert(even_worse(1, 1) == 0)
    Value(10): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(even_worse(1, 1) == 0)
    Call(Fun(450), Range { start: Value(7), end: Value(10) }) |assert(even_worse(1, 1) == 0)
    Call(Fun(515), Range { start: Value(10), end: Value(11) }) |assert(even_worse(1, 1) == 0)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(even_worse(1, 1) == 0)
    Return(None) |assert(even_worse(1, 1) == 0)


function u0:0() fast {
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = () fast
    sig2 = (b1) fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:5 sig1
    fn2 = colocated u0:31 sig2

block0:
    v0 = iconst.i64 1
    v1 = iconst.i64 1
    v2 = iconst.i64 213
    v3 = iconst.i64 20
    v4 = global_value.i64 gv0
    call fn0(v2, v3, v4)
    jump block1(v0, v1)

block1(v5: i64, v6: i64):
    v8 = icmp sgt v5, v6
    brnz v8, block2
    jump block3

block2:
    v9 = iconst.i64 207
    v10 = iconst.i64 21
    v11 = global_value.i64 gv0
    call fn0(v9, v10, v11)
    jump block6(v5, v6)

block6(v12: i64, v13: i64):
    v15 = iadd v12, v13
    v16 = iconst.i64 2
    v17 = imul v16, v12
    v18 = isub v15, v17
    jump block7(v18)

block7(v14: i64):
    call fn1()
    jump block5(v14)

block3:
    v19 = iconst.i64 209
    v20 = iconst.i64 21
    v21 = global_value.i64 gv0
    call fn0(v19, v20, v21)
    jump block8(v6, v5)

block8(v22: i64, v23: i64):
    v25 = iadd v22, v23
    v26 = iconst.i64 2
    v27 = imul v26, v22
    v28 = isub v25, v27
    jump block9(v28)

block9(v24: i64):
    call fn1()
    jump block5(v24)

block4:
    v29 = iconst.i64 0
    jump block5(v29)

block5(v7: i64):
    call fn1()
    v30 = iconst.i64 0
    v31 = icmp eq v7, v30
    v32 = iconst.i64 213
    v33 = iconst.i64 9
    v34 = global_value.i64 gv0
    call fn0(v32, v33, v34)
    call fn2(v31)
    call fn1()
    return
}

fun even_worse(a, b: int) -> int

  Inst1Range { start: Value(0), end: Value(2) }
    Value(2): bool = Call(Fun(350), Range { start: Value(2), end: Value(4) }) |a > b
    JumpIfTrue(Value(2), Inst(3), Range { start: Value(0), end: Value(0) }) |a > b
    Jump(Inst(6), Range { start: Value(0), end: Value(0) }) |:

  Inst3Range { start: Value(0), end: Value(0) }
    Value(4): int = Lit(Int(207, 0)) |something(a, b)
    Value(5): int = Lit(Int(21, 0)) |something(a, b)
    Value(6): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |something(a, b)
    Call(Fun(450), Range { start: Value(4), end: Value(7) }) |something(a, b)
    Value(3): int = Call(Fun(510), Range { start: Value(7), end: Value(9) }) |something(a, b)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |something(a, b)
    Return(Some(Value(3))) |return something(a, b)

  Inst6Range { start: Value(0), end: Value(0) }
    Value(8): int = Lit(Int(209, 0)) |something(b, a)
    Value(9): int = Lit(Int(21, 0)) |something(b, a)
    Value(10): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |something(b, a)
    Call(Fun(450), Range { start: Value(9), end: Value(12) }) |something(b, a)
    Value(7): int = Call(Fun(510), Range { start: Value(12), end: Value(14) }) |something(b, a)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |something(b, a)
    Return(Some(Value(7))) |return something(b, a)

  Inst5Range { start: Value(0), end: Value(0) }
    Value(11): int = Zeroed |if a > b:
    return something(a, b)
  else:
    return something(b, a)
    Return(Some(Value(11))) |if a > b:
    return something(a, b)
  else:
    return something(b, a)


function u0:0(i64, i64) -> i64 fast {
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:5 sig1

block0(v0: i64, v1: i64):
    v2 = icmp sgt v0, v1
    brnz v2, block1
    jump block2

block1:
    v3 = iconst.i64 207
    v4 = iconst.i64 21
    v5 = global_value.i64 gv0
    call fn0(v3, v4, v5)
    jump block4(v0, v1)

block4(v6: i64, v7: i64):
    v9 = iadd v6, v7
    v10 = iconst.i64 2
    v11 = imul v10, v6
    v12 = isub v9, v11
    jump block5(v12)

block5(v8: i64):
    call fn1()
    return v8

block2:
    v13 = iconst.i64 209
    v14 = iconst.i64 21
    v15 = global_value.i64 gv0
    call fn0(v13, v14, v15)
    jump block6(v1, v0)

block6(v16: i64, v17: i64):
    v19 = iadd v16, v17
    v20 = iconst.i64 2
    v21 = imul v20, v16
    v22 = isub v19, v21
    jump block7(v22)

block7(v18: i64):
    call fn1()
    return v18

block3:
    v23 = iconst.i64 0
    return v23
}

fun something(a, b: int) -> int

  Inst1Range { start: Value(0), end: Value(2) }
    Value(2): int = Call(Fun(260), Range { start: Value(2), end: Value(4) }) |(a + b)
    Value(3): int = Lit(Int(2, 0)) |2
    Value(4): int = Call(Fun(280), Range { start: Value(4), end: Value(6) }) |2 * a
    Value(5): int = Call(Fun(270), Range { start: Value(6), end: Value(8) }) |(a + b) - 2 * a
    Return(Some(Value(5))) |return (a + b) - 2 * a


function u0:0(i64, i64) -> i64 fast {
block0(v0: i64, v1: i64):
    v2 = iadd v0, v1
    v3 = iconst.i64 2
    v4 = imul v3, v0
    v5 = isub v2, v4
    return v5
}

fun test_case_12

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): int = GlobalLoad(Global(2)) |a
    Value(1): int = Lit(Int(1, 0)) |1
    Value(2): bool = Call(Fun(310), Range { start: Value(0), end: Value(2) }) |a == 1
    Value(3): int = Lit(Int(197, 0)) |assert(a == 1)
    Value(4): int = Lit(Int(9, 0)) |assert(a == 1)
    Value(5): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(a == 1)
    Call(Fun(450), Range { start: Value(2), end: Value(5) }) |assert(a == 1)
    Call(Fun(515), Range { start: Value(5), end: Value(6) }) |assert(a == 1)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(a == 1)
    Return(None) |assert(a == 1)


function u0:0() fast {
    gv0 = symbol colocated u1:7
    gv1 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (b1) fast
    sig2 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:31 sig1
    fn2 = colocated u0:5 sig2

block0:
    v0 = global_value.i64 gv0
    v1 = iconst.i64 1
    v2 = load.i64 v0
    v3 = icmp eq v2, v1
    v4 = iconst.i64 197
    v5 = iconst.i64 9
    v6 = global_value.i64 gv1
    call fn0(v4, v5, v6)
    call fn1(v3)
    call fn2()
    return
}

fun test_case_11

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): int = Lit(Int(1, 0)) |1
    Value(1): int = VarDecl(Value(0)) |a = 1
    Value(2): &int = Ref(Value(1)) |&a
    Value(3): &int = VarDecl(Value(2)) |b = &a
    Value(4): int = Deref(Value(3), true) |*b
    Value(5): int = Lit(Int(0, 0)) |0
    Value(5): int = Assign(Value(4)) |*b = 0
    Value(6): int = Lit(Int(0, 0)) |0
    Value(7): bool = Call(Fun(310), Range { start: Value(0), end: Value(2) }) |a == 0
    Value(8): int = Lit(Int(192, 0)) |assert(a == 0)
    Value(9): int = Lit(Int(9, 0)) |assert(a == 0)
    Value(10): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(a == 0)
    Call(Fun(450), Range { start: Value(2), end: Value(5) }) |assert(a == 0)
    Call(Fun(515), Range { start: Value(5), end: Value(6) }) |assert(a == 0)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(a == 0)
    Return(None) |assert(a == 0)


function u0:0() fast {
    ss0 = explicit_slot 8
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (b1) fast
    sig2 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:31 sig1
    fn2 = colocated u0:5 sig2

block0:
    v10 = iconst.i64 0
    v2 -> v10
    v0 = iconst.i64 1
    stack_store v0, ss0
    v1 = stack_addr.i64 ss0
    v3 = iconst.i64 0
    store v3, v1
    v4 = iconst.i64 0
    v5 = stack_load.i64 ss0
    v6 = icmp eq v5, v4
    v7 = iconst.i64 192
    v8 = iconst.i64 9
    v9 = global_value.i64 gv0
    call fn0(v7, v8, v9)
    call fn1(v6)
    call fn2()
    return
}

fun test_case_10

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): int = Lit(Int(1, 0)) |1
    Value(1): int = Lit(Int(2, 0)) |2
    Value(2): int = Lit(Int(3, 0)) |3
    Value(3): int = Lit(Int(4, 0)) |4
    Value(4): int = Lit(Int(5, 0)) |5
    Value(5): int = Lit(Int(6, 0)) |6
    Value(6): int = Lit(Int(7, 0)) |7
    Value(7): int = Lit(Int(8, 0)) |8
    Value(8): int = Lit(Int(9, 0)) |9
    Value(9): int = Lit(Int(10, 0)) |10
    Value(10): [int, 10] = Uninitialized |[
    Value(11): int = Offset(Value(10)) |[
    Value(0): int = Assign(Value(11)) |[
    Value(12): int = Offset(Value(10)) |[
    Value(1): int = Assign(Value(12)) |[
    Value(13): int = Offset(Value(10)) |[
    Value(2): int = Assign(Value(13)) |[
    Value(14): int = Offset(Value(10)) |[
    Value(3): int = Assign(Value(14)) |[
    Value(15): int = Offset(Value(10)) |[
    Value(4): int = Assign(Value(15)) |[
    Value(16): int = Offset(Value(10)) |[
    Value(5): int = Assign(Value(16)) |[
    Value(17): int = Offset(Value(10)) |[
    Value(6): int = Assign(Value(17)) |[
    Value(18): int = Offset(Value(10)) |[
    Value(7): int = Assign(Value(18)) |[
    Value(19): int = Offset(Value(10)) |[
    Value(8): int = Assign(Value(19)) |[
    Value(20): int = Offset(Value(10)) |[
    Value(9): int = Assign(Value(20)) |[
    Value(21): [int, 10] = VarDecl(Value(10)) |array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    Value(22): int = Lit(Int(0, 0)) |0
    Value(23): int = VarDecl(Value(22)) |i = 0
    Value(24): int = Lit(Int(0, 0)) |0
    Value(25): int = VarDecl(Value(24)) |sum = 0
    Jump(Inst(38), Range { start: Value(0), end: Value(0) }) |loop:
    if i >= array.len():
      break
    sum += array[i]
    storage[i] = array[i]
    i += 1

  Inst38Range { start: Value(0), end: Value(0) }
    Value(27): &[int, 10] = Ref(Value(21)) |array.len()
    Value(28): int = Lit(Int(180, 0)) |array.len()
    Value(29): int = Lit(Int(18, 0)) |array.len()
    Value(30): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |array.len()
    Call(Fun(450), Range { start: Value(0), end: Value(3) }) |array.len()
    Value(26): int = Call(Fun(518), Range { start: Value(3), end: Value(4) }) |array.len()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |array.len()
    Value(31): bool = Call(Fun(330), Range { start: Value(4), end: Value(6) }) |i >= array.len()
    JumpIfTrue(Value(31), Inst(50), Range { start: Value(0), end: Value(0) }) |i >= array.len()
    Jump(Inst(52), Range { start: Value(0), end: Value(0) }) |

  Inst50Range { start: Value(0), end: Value(0) }
    Jump(Inst(39), Range { start: Value(0), end: Value(0) }) |break

  Inst52Range { start: Value(0), end: Value(0) }
    Value(33): &[int, 10] = Ref(Value(21)) |array[i]
    Value(34): int = Lit(Int(182, 0)) |array[i]
    Value(35): int = Lit(Int(17, 0)) |array[i]
    Value(36): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |array[i]
    Call(Fun(450), Range { start: Value(6), end: Value(9) }) |array[i]
    Value(32): &int = Call(Fun(519), Range { start: Value(9), end: Value(11) }) |array[i]
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |array[i]
    Value(37): int = Deref(Value(32), false) |array[i]
    Value(38): int = Call(Fun(260), Range { start: Value(11), end: Value(13) }) |sum += array[i]
    Value(38): int = Assign(Value(25)) |sum += array[i]
    Value(39): [int, 10] = GlobalLoad(Global(1)) |storage
    Value(41): &[int, 10] = Ref(Value(39)) |storage[i]
    Value(42): int = Lit(Int(183, 0)) |storage[i]
    Value(43): int = Lit(Int(12, 0)) |storage[i]
    Value(44): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |storage[i]
    Call(Fun(450), Range { start: Value(13), end: Value(16) }) |storage[i]
    Value(40): &int = Call(Fun(519), Range { start: Value(16), end: Value(18) }) |storage[i]
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |storage[i]
    Value(45): int = Deref(Value(40), true) |storage[i]
    Value(47): &[int, 10] = Ref(Value(21)) |array[i]
    Value(48): int = Lit(Int(183, 0)) |array[i]
    Value(49): int = Lit(Int(23, 0)) |array[i]
    Value(50): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |array[i]
    Call(Fun(450), Range { start: Value(18), end: Value(21) }) |array[i]
    Value(46): &int = Call(Fun(519), Range { start: Value(21), end: Value(23) }) |array[i]
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |array[i]
    Value(51): int = Deref(Value(46), false) |array[i]
    Value(51): int = Assign(Value(45)) |storage[i] = array[i]
    Value(52): int = Lit(Int(1, 0)) |1
    Value(53): int = Call(Fun(260), Range { start: Value(23), end: Value(25) }) |i += 1
    Value(53): int = Assign(Value(23)) |i += 1
    Jump(Inst(38), Range { start: Value(0), end: Value(0) }) |loop:
    if i >= array.len():
      break
    sum += array[i]
    storage[i] = array[i]
    i += 1

  Inst39Range { start: Value(0), end: Value(0) }
    Value(54): int = Lit(Int(11, 0)) |11
    Value(55): int = Lit(Int(5, 0)) |5
    Value(56): int = Call(Fun(280), Range { start: Value(25), end: Value(27) }) |11 * 5
    Value(57): bool = Call(Fun(310), Range { start: Value(27), end: Value(29) }) |sum == 11 * 5
    Value(58): int = Lit(Int(186, 0)) |assert(sum == 11 * 5)
    Value(59): int = Lit(Int(9, 0)) |assert(sum == 11 * 5)
    Value(60): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(sum == 11 * 5)
    Call(Fun(450), Range { start: Value(29), end: Value(32) }) |assert(sum == 11 * 5)
    Call(Fun(515), Range { start: Value(32), end: Value(33) }) |assert(sum == 11 * 5)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(sum == 11 * 5)
    Return(None) |assert(sum == 11 * 5)


function u0:0() fast {
    ss0 = explicit_slot 80
    ss1 = explicit_slot 80
    gv0 = symbol colocated u1:8
    gv1 = symbol colocated u1:6
    sig0 = (i64, i64, i64) fast
    sig1 = (i64) -> i64 fast
    sig2 = () fast
    sig3 = (i64, i64) -> i64 fast
    sig4 = (b1) fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:43 sig1
    fn2 = colocated u0:5 sig2
    fn3 = colocated u0:40 sig3
    fn4 = colocated u0:31 sig4

block0:
    v62 = iconst.i64 0
    v23 -> v62
    v61 = iconst.i64 0
    v21 -> v61
    v0 = iconst.i64 1
    v1 = iconst.i64 2
    v2 = iconst.i64 3
    v3 = iconst.i64 4
    v4 = iconst.i64 5
    v5 = iconst.i64 6
    v6 = iconst.i64 7
    v7 = iconst.i64 8
    v8 = iconst.i64 9
    v9 = iconst.i64 10
    stack_store v0, ss0
    stack_store v1, ss0+8
    stack_store v2, ss0+16
    stack_store v3, ss0+24
    stack_store v4, ss0+32
    stack_store v5, ss0+40
    stack_store v6, ss0+48
    stack_store v7, ss0+56
    stack_store v8, ss0+64
    stack_store v9, ss0+72
    v10 = stack_load.i64 ss0
    stack_store v10, ss1
    v11 = stack_load.i64 ss0+8
    stack_store v11, ss1+8
    v12 = stack_load.i64 ss0+16
    stack_store v12, ss1+16
    v13 = stack_load.i64 ss0+24
    stack_store v13, ss1+24
    v14 = stack_load.i64 ss0+32
    stack_store v14, ss1+32
    v15 = stack_load.i64 ss0+40
    stack_store v15, ss1+40
    v16 = stack_load.i64 ss0+48
    stack_store v16, ss1+48
    v17 = stack_load.i64 ss0+56
    stack_store v17, ss1+56
    v18 = stack_load.i64 ss0+64
    stack_store v18, ss1+64
    v19 = stack_load.i64 ss0+72
    stack_store v19, ss1+72
    v20 = iconst.i64 0
    v22 = iconst.i64 0
    jump block1(v20, v22)

block1(v29: i64, v63: i64):
    v35 -> v29
    v37 -> v63
    v56 -> v63
    v24 = stack_addr.i64 ss1
    v25 = iconst.i64 180
    v26 = iconst.i64 18
    v27 = global_value.i64 gv0
    call fn0(v25, v26, v27)
    v28 = call fn1(v24)
    call fn2()
    v30 = icmp sge v29, v28
    brnz v30, block2
    jump block3

block2:
    jump block4

block3:
    v31 = stack_addr.i64 ss1
    v32 = iconst.i64 182
    v33 = iconst.i64 17
    v34 = global_value.i64 gv0
    call fn0(v32, v33, v34)
    v36 = call fn3(v31, v35)
    call fn2()
    v38 = load.i64 v36
    v39 = iadd.i64 v37, v38
    v40 = global_value.i64 gv1
    v41 = iconst.i64 183
    v42 = iconst.i64 12
    v43 = global_value.i64 gv0
    call fn0(v41, v42, v43)
    v44 = call fn3(v40, v35)
    call fn2()
    v45 = stack_addr.i64 ss1
    v46 = iconst.i64 183
    v47 = iconst.i64 23
    v48 = global_value.i64 gv0
    call fn0(v46, v47, v48)
    v49 = call fn3(v45, v35)
    call fn2()
    v50 = load.i64 v49
    store v50, v44
    v51 = iconst.i64 1
    v52 = iadd.i64 v35, v51
    jump block1(v52, v39)

block4:
    v53 = iconst.i64 11
    v54 = iconst.i64 5
    v55 = imul v53, v54
    v57 = icmp.i64 eq v56, v55
    v58 = iconst.i64 186
    v59 = iconst.i64 9
    v60 = global_value.i64 gv0
    call fn0(v58, v59, v60)
    call fn4(v57)
    call fn2()
    return
}

fun __index__(a: &Self, index: int) -> &T

  Inst1Range { start: Value(0), end: Value(2) }
    Value(2): int = Lit(Int(0, 0)) |0
    Value(3): bool = Call(Fun(360), Range { start: Value(2), end: Value(4) }) |index < 0
    Value(4): int = Lit(Int(10, 0)) |L
    Value(5): bool = Call(Fun(330), Range { start: Value(4), end: Value(6) }) |index >= L
    Value(6): bool = Call(Fun(435), Range { start: Value(6), end: Value(8) }) |index < 0 | index >= L
    JumpIfTrue(Value(6), Inst(7), Range { start: Value(0), end: Value(0) }) |index < 0 | index >= L
    Jump(Inst(9), Range { start: Value(0), end: Value(0) }) |

  Inst7Range { start: Value(0), end: Value(0) }
    Value(7): &u8 = Lit(String(Span { source: Source(0), hash: ID(6484216913505728610), start: 203, end: 223, line: 0, column: 0 })) |"index out of bounds"
    Call(Fun(449), Range { start: Value(8), end: Value(9) }) |panic("index out of bounds")
    Jump(Inst(9), Range { start: Value(0), end: Value(0) }) |if index < 0 | index >= L:
      panic("index out of bounds")

  Inst9Range { start: Value(0), end: Value(0) }
    Value(8): &int = Call(Fun(520), Range { start: Value(9), end: Value(11) }) |a.get_unchecked(index)
    Return(Some(Value(8))) |a.get_unchecked(index)


function u0:0(i64, i64) -> i64 fast {
    gv0 = symbol colocated u1:4
    sig0 = (i64) fast
    sig1 = (i64, i64) -> i64 fast
    fn0 = colocated u0:12 sig0
    fn1 = colocated u0:41 sig1

block0(v0: i64, v1: i64):
    v2 = iconst.i64 0
    v3 = icmp slt v1, v2
    v4 = iconst.i64 10
    v5 = icmp sge v1, v4
    v6 = bor v3, v5
    brnz v6, block1
    jump block2

block1:
    v7 = global_value.i64 gv0
    call fn0(v7)
    jump block2

block2:
    v8 = call fn1(v0, v1)
    return v8
}

fun get_unchecked(a: &Self, index: int) -> &T

  Inst1Range { start: Value(0), end: Value(2) }
    Value(2): int = Cast(Value(0)) |a as int
    Value(3): int = Call(Fun(521), Range { start: Value(2), end: Value(2) }) |sizeof::[T]()
    Value(4): int = Call(Fun(280), Range { start: Value(2), end: Value(4) }) |index * sizeof::[T]()
    Value(5): int = Call(Fun(260), Range { start: Value(4), end: Value(6) }) |(a as int + index * sizeof::[T]())
    Value(6): &int = Cast(Value(5)) |(a as int + index * sizeof::[T]()) as &T
    Return(Some(Value(6))) |(a as int + index * sizeof::[T]()) as &T


function u0:0(i64, i64) -> i64 fast {
block0(v0: i64, v1: i64):
    v2 = iconst.i64 8
    v3 = imul v1, v2
    v4 = iadd v0, v3
    return v4
}

fun pub sizeof[T] -> int


fun len(array: &Self) -> int

  Inst1Range { start: Value(0), end: Value(1) }
    Value(1): int = Lit(Int(10, 0)) |L
    Return(Some(Value(1))) |L


function u0:0(i64) -> i64 fast {
block0(v0: i64):
    v1 = iconst.i64 10
    return v1
}

fun test_case_9

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): int = Lit(Int(1, 0)) |1
    Value(1): int = Lit(Int(2, 0)) |2
    Value(2): int = Lit(Int(3, 0)) |3
    Value(3): int = Lit(Int(4, 0)) |4
    Value(4): int = Lit(Int(5, 0)) |5
    Value(5): int = Lit(Int(6, 0)) |6
    Value(6): int = Lit(Int(7, 0)) |7
    Value(7): int = Lit(Int(8, 0)) |8
    Value(8): int = Lit(Int(9, 0)) |9
    Value(9): int = Lit(Int(10, 0)) |10
    Value(10): [int, 10] = Uninitialized |[
    Value(11): int = Offset(Value(10)) |[
    Value(0): int = Assign(Value(11)) |[
    Value(12): int = Offset(Value(10)) |[
    Value(1): int = Assign(Value(12)) |[
    Value(13): int = Offset(Value(10)) |[
    Value(2): int = Assign(Value(13)) |[
    Value(14): int = Offset(Value(10)) |[
    Value(3): int = Assign(Value(14)) |[
    Value(15): int = Offset(Value(10)) |[
    Value(4): int = Assign(Value(15)) |[
    Value(16): int = Offset(Value(10)) |[
    Value(5): int = Assign(Value(16)) |[
    Value(17): int = Offset(Value(10)) |[
    Value(6): int = Assign(Value(17)) |[
    Value(18): int = Offset(Value(10)) |[
    Value(7): int = Assign(Value(18)) |[
    Value(19): int = Offset(Value(10)) |[
    Value(8): int = Assign(Value(19)) |[
    Value(20): int = Offset(Value(10)) |[
    Value(9): int = Assign(Value(20)) |[
    Value(21): [int, 10] = VarDecl(Value(10)) |array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    Value(22): int = Lit(Int(0, 0)) |0
    Value(23): int = VarDecl(Value(22)) |i = 0
    Value(24): int = Lit(Int(0, 0)) |0
    Value(25): int = VarDecl(Value(24)) |sum = 0
    Jump(Inst(38), Range { start: Value(0), end: Value(0) }) |loop:
    if i >= array.len():
      break
    sum += array[i]
    i += 1

  Inst38Range { start: Value(0), end: Value(0) }
    Value(27): &[int, 10] = Ref(Value(21)) |array.len()
    Value(28): int = Lit(Int(162, 0)) |array.len()
    Value(29): int = Lit(Int(18, 0)) |array.len()
    Value(30): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |array.len()
    Call(Fun(450), Range { start: Value(0), end: Value(3) }) |array.len()
    Value(26): int = Call(Fun(518), Range { start: Value(3), end: Value(4) }) |array.len()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |array.len()
    Value(31): bool = Call(Fun(330), Range { start: Value(4), end: Value(6) }) |i >= array.len()
    JumpIfTrue(Value(31), Inst(50), Range { start: Value(0), end: Value(0) }) |i >= array.len()
    Jump(Inst(52), Range { start: Value(0), end: Value(0) }) |

  Inst50Range { start: Value(0), end: Value(0) }
    Jump(Inst(39), Range { start: Value(0), end: Value(0) }) |break

  Inst52Range { start: Value(0), end: Value(0) }
    Value(33): &[int, 10] = Ref(Value(21)) |array[i]
    Value(34): int = Lit(Int(164, 0)) |array[i]
    Value(35): int = Lit(Int(17, 0)) |array[i]
    Value(36): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |array[i]
    Call(Fun(450), Range { start: Value(6), end: Value(9) }) |array[i]
    Value(32): &int = Call(Fun(519), Range { start: Value(9), end: Value(11) }) |array[i]
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |array[i]
    Value(37): int = Deref(Value(32), false) |array[i]
    Value(38): int = Call(Fun(260), Range { start: Value(11), end: Value(13) }) |sum += array[i]
    Value(38): int = Assign(Value(25)) |sum += array[i]
    Value(39): int = Lit(Int(1, 0)) |1
    Value(40): int = Call(Fun(260), Range { start: Value(13), end: Value(15) }) |i += 1
    Value(40): int = Assign(Value(23)) |i += 1
    Jump(Inst(38), Range { start: Value(0), end: Value(0) }) |loop:
    if i >= array.len():
      break
    sum += array[i]
    i += 1

  Inst39Range { start: Value(0), end: Value(0) }
    Value(41): int = Lit(Int(11, 0)) |11
    Value(42): int = Lit(Int(5, 0)) |5
    Value(43): int = Call(Fun(280), Range { start: Value(15), end: Value(17) }) |11 * 5
    Value(44): bool = Call(Fun(310), Range { start: Value(17), end: Value(19) }) |sum == 11 * 5
    Value(45): int = Lit(Int(167, 0)) |assert(sum == 11 * 5)
    Value(46): int = Lit(Int(9, 0)) |assert(sum == 11 * 5)
    Value(47): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(sum == 11 * 5)
    Call(Fun(450), Range { start: Value(19), end: Value(22) }) |assert(sum == 11 * 5)
    Call(Fun(515), Range { start: Value(22), end: Value(23) }) |assert(sum == 11 * 5)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(sum == 11 * 5)
    Return(None) |assert(sum == 11 * 5)


function u0:0() fast {
    ss0 = explicit_slot 80
    ss1 = explicit_slot 80
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (i64) -> i64 fast
    sig2 = () fast
    sig3 = (i64, i64) -> i64 fast
    sig4 = (b1) fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:43 sig1
    fn2 = colocated u0:5 sig2
    fn3 = colocated u0:40 sig3
    fn4 = colocated u0:31 sig4

block0:
    v51 = iconst.i64 0
    v23 -> v51
    v50 = iconst.i64 0
    v21 -> v50
    v0 = iconst.i64 1
    v1 = iconst.i64 2
    v2 = iconst.i64 3
    v3 = iconst.i64 4
    v4 = iconst.i64 5
    v5 = iconst.i64 6
    v6 = iconst.i64 7
    v7 = iconst.i64 8
    v8 = iconst.i64 9
    v9 = iconst.i64 10
    stack_store v0, ss0
    stack_store v1, ss0+8
    stack_store v2, ss0+16
    stack_store v3, ss0+24
    stack_store v4, ss0+32
    stack_store v5, ss0+40
    stack_store v6, ss0+48
    stack_store v7, ss0+56
    stack_store v8, ss0+64
    stack_store v9, ss0+72
    v10 = stack_load.i64 ss0
    stack_store v10, ss1
    v11 = stack_load.i64 ss0+8
    stack_store v11, ss1+8
    v12 = stack_load.i64 ss0+16
    stack_store v12, ss1+16
    v13 = stack_load.i64 ss0+24
    stack_store v13, ss1+24
    v14 = stack_load.i64 ss0+32
    stack_store v14, ss1+32
    v15 = stack_load.i64 ss0+40
    stack_store v15, ss1+40
    v16 = stack_load.i64 ss0+48
    stack_store v16, ss1+48
    v17 = stack_load.i64 ss0+56
    stack_store v17, ss1+56
    v18 = stack_load.i64 ss0+64
    stack_store v18, ss1+64
    v19 = stack_load.i64 ss0+72
    stack_store v19, ss1+72
    v20 = iconst.i64 0
    v22 = iconst.i64 0
    jump block1(v20, v22)

block1(v29: i64, v52: i64):
    v35 -> v29
    v37 -> v52
    v45 -> v52
    v24 = stack_addr.i64 ss1
    v25 = iconst.i64 162
    v26 = iconst.i64 18
    v27 = global_value.i64 gv0
    call fn0(v25, v26, v27)
    v28 = call fn1(v24)
    call fn2()
    v30 = icmp sge v29, v28
    brnz v30, block2
    jump block3

block2:
    jump block4

block3:
    v31 = stack_addr.i64 ss1
    v32 = iconst.i64 164
    v33 = iconst.i64 17
    v34 = global_value.i64 gv0
    call fn0(v32, v33, v34)
    v36 = call fn3(v31, v35)
    call fn2()
    v38 = load.i64 v36
    v39 = iadd.i64 v37, v38
    v40 = iconst.i64 1
    v41 = iadd.i64 v35, v40
    jump block1(v41, v39)

block4:
    v42 = iconst.i64 11
    v43 = iconst.i64 5
    v44 = imul v42, v43
    v46 = icmp.i64 eq v45, v44
    v47 = iconst.i64 167
    v48 = iconst.i64 9
    v49 = global_value.i64 gv0
    call fn0(v47, v48, v49)
    call fn4(v46)
    call fn2()
    return
}

fun test_case_8

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): EightBytes = Zeroed |eb: EightBytes
    Value(1): EightBytes = VarDecl(Value(0)) |eb: EightBytes
    Value(2): i8 = Offset(Value(1)) |eb.a
    Value(3): i8 = Lit(Int(1, 8)) |1i8
    Value(3): i8 = Assign(Value(2)) |eb.a = 1i8
    Value(4): i8 = Offset(Value(1)) |eb.b
    Value(5): i8 = Lit(Int(2, 8)) |2i8
    Value(5): i8 = Assign(Value(4)) |eb.b = 2i8
    Value(6): i8 = Offset(Value(1)) |eb.c
    Value(7): i8 = Lit(Int(3, 8)) |3i8
    Value(7): i8 = Assign(Value(6)) |eb.c = 3i8
    Value(8): i8 = Offset(Value(1)) |eb.d
    Value(9): i8 = Lit(Int(4, 8)) |4i8
    Value(9): i8 = Assign(Value(8)) |eb.d = 4i8
    Value(10): i8 = Offset(Value(1)) |eb.e
    Value(11): i8 = Lit(Int(5, 8)) |5i8
    Value(11): i8 = Assign(Value(10)) |eb.e = 5i8
    Value(12): i8 = Offset(Value(1)) |eb.f
    Value(13): i8 = Lit(Int(6, 8)) |6i8
    Value(13): i8 = Assign(Value(12)) |eb.f = 6i8
    Value(14): i8 = Offset(Value(1)) |eb.g
    Value(15): i8 = Lit(Int(7, 8)) |7i8
    Value(15): i8 = Assign(Value(14)) |eb.g = 7i8
    Value(16): i8 = Offset(Value(1)) |eb.h
    Value(17): i8 = Lit(Int(8, 8)) |8i8
    Value(17): i8 = Assign(Value(16)) |eb.h = 8i8
    Value(18): i8 = Offset(Value(1)) |eb.a
    Value(19): i8 = Offset(Value(1)) |eb.h
    Value(20): i8 = Call(Fun(252), Range { start: Value(0), end: Value(2) }) |eb.a + eb.h
    Value(21): i8 = Offset(Value(1)) |eb.g
    Value(22): i8 = Call(Fun(252), Range { start: Value(2), end: Value(4) }) |eb.a + eb.h + eb.g
    Value(23): i8 = Offset(Value(1)) |eb.f
    Value(24): i8 = Call(Fun(252), Range { start: Value(4), end: Value(6) }) |eb.a + eb.h + eb.g + eb.f
    Value(25): i8 = Offset(Value(1)) |eb.e
    Value(26): i8 = Call(Fun(252), Range { start: Value(6), end: Value(8) }) |eb.a + eb.h + eb.g + eb.f + eb.e
    Value(27): i8 = Offset(Value(1)) |eb.d
    Value(28): i8 = Call(Fun(252), Range { start: Value(8), end: Value(10) }) |eb.a + eb.h + eb.g + eb.f + eb.e + eb.d
    Value(29): i8 = Offset(Value(1)) |eb.c
    Value(30): i8 = Call(Fun(252), Range { start: Value(10), end: Value(12) }) |eb.a + eb.h + eb.g + eb.f + eb.e + eb.d + eb.c
    Value(31): i8 = Offset(Value(1)) |eb.b
    Value(32): i8 = Call(Fun(252), Range { start: Value(12), end: Value(14) }) |eb.a + eb.h + eb.g + eb.f + eb.e + eb.d + eb.c + eb.b
    Value(33): i8 = Lit(Int(4, 8)) |4i8
    Value(34): i8 = Lit(Int(9, 8)) |9i8
    Value(35): i8 = Call(Fun(272), Range { start: Value(14), end: Value(16) }) |4i8 * 9i8
    Value(36): bool = Call(Fun(302), Range { start: Value(16), end: Value(18) }) |eb.a + eb.h + eb.g + eb.f + eb.e + eb.d + eb.c + eb.b == 4i8 * 9i8
    Value(37): int = Lit(Int(152, 0)) |assert(eb.a + eb.h + eb.g + eb.f + eb.e + eb.d + eb.c + eb.b == 4i8 * 9i8)
    Value(38): int = Lit(Int(9, 0)) |assert(eb.a + eb.h + eb.g + eb.f + eb.e + eb.d + eb.c + eb.b == 4i8 * 9i8)
    Value(39): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(eb.a + eb.h + eb.g + eb.f + eb.e + eb.d + eb.c + eb.b == 4i8 * 9i8)
    Call(Fun(450), Range { start: Value(18), end: Value(21) }) |assert(eb.a + eb.h + eb.g + eb.f + eb.e + eb.d + eb.c + eb.b == 4i8 * 9i8)
    Call(Fun(515), Range { start: Value(21), end: Value(22) }) |assert(eb.a + eb.h + eb.g + eb.f + eb.e + eb.d + eb.c + eb.b == 4i8 * 9i8)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(eb.a + eb.h + eb.g + eb.f + eb.e + eb.d + eb.c + eb.b == 4i8 * 9i8)
    Return(None) |assert(eb.a + eb.h + eb.g + eb.f + eb.e + eb.d + eb.c + eb.b == 4i8 * 9i8)


function u0:0() fast {
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (b1) fast
    sig2 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:31 sig1
    fn2 = colocated u0:5 sig2

block0:
    v80 = iconst.i64 0
    v1 -> v80
    v0 = iconst.i64 0
    v2 = iconst.i8 1
    v3 = iconst.i64 -256
    v4 = band v0, v3
    v5 = uextend.i64 v2
    v6 = ishl_imm v5, 0
    v7 = bor v4, v6
    v8 = iconst.i8 2
    v9 = iconst.i64 0xffff_ffff_ffff_00ff
    v10 = band v7, v9
    v11 = uextend.i64 v8
    v12 = ishl_imm v11, 8
    v13 = bor v10, v12
    v14 = iconst.i8 3
    v15 = iconst.i64 0xffff_ffff_ff00_ffff
    v16 = band v13, v15
    v17 = uextend.i64 v14
    v18 = ishl_imm v17, 16
    v19 = bor v16, v18
    v20 = iconst.i8 4
    v21 = iconst.i64 0xffff_ffff_00ff_ffff
    v22 = band v19, v21
    v23 = uextend.i64 v20
    v24 = ishl_imm v23, 24
    v25 = bor v22, v24
    v26 = iconst.i8 5
    v27 = iconst.i64 0xffff_ff00_ffff_ffff
    v28 = band v25, v27
    v29 = uextend.i64 v26
    v30 = ishl_imm v29, 32
    v31 = bor v28, v30
    v32 = iconst.i8 6
    v33 = iconst.i64 0xffff_00ff_ffff_ffff
    v34 = band v31, v33
    v35 = uextend.i64 v32
    v36 = ishl_imm v35, 40
    v37 = bor v34, v36
    v38 = iconst.i8 7
    v39 = iconst.i64 0xff00_ffff_ffff_ffff
    v40 = band v37, v39
    v41 = uextend.i64 v38
    v42 = ishl_imm v41, 48
    v43 = bor v40, v42
    v44 = iconst.i8 8
    v45 = iconst.i64 0x00ff_ffff_ffff_ffff
    v46 = band v43, v45
    v47 = uextend.i64 v44
    v48 = ishl_imm v47, 56
    v49 = bor v46, v48
    v50 = ushr_imm v49, 0
    v51 = ireduce.i8 v50
    v52 = ushr_imm v49, 56
    v53 = ireduce.i8 v52
    v54 = iadd v51, v53
    v55 = ushr_imm v49, 48
    v56 = ireduce.i8 v55
    v57 = iadd v54, v56
    v58 = ushr_imm v49, 40
    v59 = ireduce.i8 v58
    v60 = iadd v57, v59
    v61 = ushr_imm v49, 32
    v62 = ireduce.i8 v61
    v63 = iadd v60, v62
    v64 = ushr_imm v49, 24
    v65 = ireduce.i8 v64
    v66 = iadd v63, v65
    v67 = ushr_imm v49, 16
    v68 = ireduce.i8 v67
    v69 = iadd v66, v68
    v70 = ushr_imm v49, 8
    v71 = ireduce.i8 v70
    v72 = iadd v69, v71
    v73 = iconst.i8 4
    v74 = iconst.i8 9
    v75 = imul v73, v74
    v76 = icmp eq v72, v75
    v77 = iconst.i64 152
    v78 = iconst.i64 9
    v79 = global_value.i64 gv0
    call fn0(v77, v78, v79)
    call fn1(v76)
    call fn2()
    return
}

fun test_case_7

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): Point = Zeroed |p: Point
    Value(1): Point = VarDecl(Value(0)) |p: Point
    Value(2): Cell[Point] = Zeroed |c: Cell[Point]
    Value(3): Cell[Point] = VarDecl(Value(2)) |c: Cell[Point]
    Value(4): &Point = Offset(Value(3)) |c.p
    Value(5): &Point = Ref(Value(1)) |&p
    Value(5): &Point = Assign(Value(4)) |c.p = &p
    Value(7): &Point = Offset(Value(3)) |c.x
    Value(8): Point = Deref(Value(7), false) |c.x
    Value(6): int = Offset(Value(8)) |c.x
    Value(9): int = Lit(Int(1, 0)) |1
    Value(9): int = Assign(Value(6)) |c.x = 1
    Value(11): &Point = Offset(Value(3)) |c.y
    Value(12): Point = Deref(Value(11), false) |c.y
    Value(10): int = Offset(Value(12)) |c.y
    Value(13): int = Lit(Int(2, 0)) |2
    Value(13): int = Assign(Value(10)) |c.y = 2
    Value(15): &Point = Offset(Value(3)) |c.x
    Value(16): Point = Deref(Value(15), false) |c.x
    Value(14): int = Offset(Value(16)) |c.x
    Value(18): &Point = Offset(Value(3)) |c.y
    Value(19): Point = Deref(Value(18), false) |c.y
    Value(17): int = Offset(Value(19)) |c.y
    Value(20): int = Call(Fun(260), Range { start: Value(0), end: Value(2) }) |c.x + c.y
    Value(21): int = Lit(Int(3, 0)) |3
    Value(22): bool = Call(Fun(310), Range { start: Value(2), end: Value(4) }) |c.x + c.y == 3
    Value(23): int = Lit(Int(136, 0)) |assert(c.x + c.y == 3)
    Value(24): int = Lit(Int(9, 0)) |assert(c.x + c.y == 3)
    Value(25): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(c.x + c.y == 3)
    Call(Fun(450), Range { start: Value(4), end: Value(7) }) |assert(c.x + c.y == 3)
    Call(Fun(515), Range { start: Value(7), end: Value(8) }) |assert(c.x + c.y == 3)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(c.x + c.y == 3)
    Return(None) |assert(c.x + c.y == 3)


function u0:0() fast {
    ss0 = explicit_slot 16
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (b1) fast
    sig2 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:31 sig1
    fn2 = colocated u0:5 sig2

block0:
    v14 = iconst.i64 0
    v2 -> v14
    v0 = iconst.i64 0
    stack_store v0, ss0
    stack_store v0, ss0+8
    v1 = iconst.i64 0
    v3 = stack_addr.i64 ss0
    v4 = iconst.i64 1
    store v4, v3
    v5 = iconst.i64 2
    store v5, v3+8
    v6 = load.i64 v3
    v7 = load.i64 v3+8
    v8 = iadd v6, v7
    v9 = iconst.i64 3
    v10 = icmp eq v8, v9
    v11 = iconst.i64 136
    v12 = iconst.i64 9
    v13 = global_value.i64 gv0
    call fn0(v11, v12, v13)
    call fn1(v10)
    call fn2()
    return
}

fun test_case_6

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): Point = Zeroed |p: Point
    Value(1): Point = VarDecl(Value(0)) |p: Point
    Value(2): int = Lit(Int(2, 0)) |2
    Value(3): int = Lit(Int(2, 0)) |2
    Value(5): &Point = Ref(Value(1)) |p.init(2, 2)
    Value(6): int = Lit(Int(120, 0)) |p.init(2, 2)
    Value(7): int = Lit(Int(4, 0)) |p.init(2, 2)
    Value(8): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |p.init(2, 2)
    Call(Fun(450), Range { start: Value(0), end: Value(3) }) |p.init(2, 2)
    Value(4): Point = Call(Fun(502), Range { start: Value(3), end: Value(7) }) |p.init(2, 2)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |p.init(2, 2)
    Value(9): int = Offset(Value(1)) |p.x
    Value(10): int = Offset(Value(1)) |p.y
    Value(11): int = Call(Fun(260), Range { start: Value(7), end: Value(9) }) |p.x + p.y
    Value(12): int = Lit(Int(4, 0)) |4
    Value(13): bool = Call(Fun(310), Range { start: Value(9), end: Value(11) }) |p.x + p.y == 4
    Value(14): int = Lit(Int(121, 0)) |assert(p.x + p.y == 4)
    Value(15): int = Lit(Int(9, 0)) |assert(p.x + p.y == 4)
    Value(16): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(p.x + p.y == 4)
    Call(Fun(450), Range { start: Value(11), end: Value(14) }) |assert(p.x + p.y == 4)
    Call(Fun(515), Range { start: Value(14), end: Value(15) }) |assert(p.x + p.y == 4)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(p.x + p.y == 4)
    Return(None) |assert(p.x + p.y == 4)


function u0:0() fast {
    ss0 = explicit_slot 16
    ss1 = explicit_slot 16
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (i64, i64, i64, i64 sret) -> i64 sret fast
    sig2 = () fast
    sig3 = (b1) fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:48 sig1
    fn2 = colocated u0:5 sig2
    fn3 = colocated u0:31 sig3

block0:
    v0 = iconst.i64 0
    stack_store v0, ss0
    stack_store v0, ss0+8
    v1 = iconst.i64 2
    v2 = iconst.i64 2
    v3 = stack_addr.i64 ss0
    v4 = iconst.i64 120
    v5 = iconst.i64 4
    v6 = global_value.i64 gv0
    call fn0(v4, v5, v6)
    v7 = stack_addr.i64 ss1
    v8 = call fn1(v3, v1, v2, v7)
    call fn2()
    v9 = stack_load.i64 ss0
    v10 = stack_load.i64 ss0+8
    v11 = iadd v9, v10
    v12 = iconst.i64 4
    v13 = icmp eq v11, v12
    v14 = iconst.i64 121
    v15 = iconst.i64 9
    v16 = global_value.i64 gv0
    call fn0(v14, v15, v16)
    call fn3(v13)
    call fn2()
    return
}

fun init(v: &Point, x: int, y: int) -> Point

  Inst1Range { start: Value(0), end: Value(4) }
    Value(4): Point = Deref(Value(0), false) |(
    Value(5): int = Offset(Value(4)) |(*v).x
    Value(1): int = Assign(Value(5)) |(*v).x = x
    Value(6): Point = Deref(Value(0), false) |(
    Value(7): int = Offset(Value(6)) |(*v).y
    Value(2): int = Assign(Value(7)) |(*v).y = y
    Value(8): Point = Zeroed |pass
    Value(9): Point = Deref(Value(3), false) |pass
    Value(8): Point = Assign(Value(9)) |pass
    Return(Some(Value(3))) |pass


function u0:0(i64, i64, i64, i64 sret) -> i64 sret fast {
block0(v0: i64, v1: i64, v2: i64, v3: i64):
    store v1, v0
    store v2, v0+8
    v4 = iconst.i64 0
    store v4, v3
    store v4, v3+8
    return v3
}

fun test_case_5

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): &u8 = Lit(String(Span { source: Source(0), hash: ID(14798484927345966379), start: 324, end: 338, line: 0, column: 0 })) |"Hello, World!"
    Value(1): &u8 = VarDecl(Value(0)) |a = "Hello, World!"
    Value(2): uint = Cast(Value(1)) |a as uint
    Value(3): uint = VarDecl(Value(2)) |b = a as uint
    Jump(Inst(6), Range { start: Value(0), end: Value(0) }) |loop:
    let char = *(b as &u8)
    if char == 0u8:
      break
    putchar(char.i32())
    b += 1 as uint

  Inst6Range { start: Value(0), end: Value(0) }
    Value(4): &u8 = Cast(Value(3)) |(b as &u8)
    Value(5): u8 = Deref(Value(4), false) |*(b as &u8)
    Value(6): u8 = VarDecl(Value(5)) |char = *(b as &u8)
    Value(7): u8 = Lit(Uint(0, 8)) |0u8
    Value(8): bool = Call(Fun(306), Range { start: Value(0), end: Value(2) }) |char == 0u8
    JumpIfTrue(Value(8), Inst(15), Range { start: Value(0), end: Value(0) }) |char == 0u8
    Jump(Inst(17), Range { start: Value(0), end: Value(0) }) |

  Inst15Range { start: Value(0), end: Value(0) }
    Jump(Inst(7), Range { start: Value(0), end: Value(0) }) |break

  Inst17Range { start: Value(0), end: Value(0) }
    Value(9): i32 = Call(Fun(33), Range { start: Value(2), end: Value(3) }) |char.i32()
    Value(10): int = Lit(Int(109, 0)) |putchar(char.i32())
    Value(11): int = Lit(Int(12, 0)) |putchar(char.i32())
    Value(12): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |putchar(char.i32())
    Call(Fun(450), Range { start: Value(3), end: Value(6) }) |putchar(char.i32())
    Call(Fun(500), Range { start: Value(6), end: Value(7) }) |putchar(char.i32())
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |putchar(char.i32())
    Value(13): int = Lit(Int(1, 0)) |1
    Value(14): uint = Cast(Value(13)) |1 as uint
    Value(15): uint = Call(Fun(261), Range { start: Value(7), end: Value(9) }) |b += 1 as uint
    Value(15): uint = Assign(Value(3)) |b += 1 as uint
    Jump(Inst(6), Range { start: Value(0), end: Value(0) }) |loop:
    let char = *(b as &u8)
    if char == 0u8:
      break
    putchar(char.i32())
    b += 1 as uint

  Inst7Range { start: Value(0), end: Value(0) }
    Return(None) |loop:
    let char = *(b as &u8)
    if char == 0u8:
      break
    putchar(char.i32())
    b += 1 as uint


function u0:0() fast {
    gv0 = symbol colocated u1:10
    gv1 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (i32) windows_fastcall
    sig2 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = u0:25 sig1
    fn2 = colocated u0:5 sig2

block0:
    v15 = iconst.i64 0
    v2 -> v15
    v14 = iconst.i64 0
    v1 -> v14
    v0 = global_value.i64 gv0
    jump block1(v0)

block1(v3: i64):
    v12 -> v3
    v4 = load.i8 v3
    v5 = iconst.i8 0
    v6 = icmp eq v4, v5
    brnz v6, block2
    jump block3

block2:
    jump block4

block3:
    v7 = sextend.i32 v4
    v8 = iconst.i64 109
    v9 = iconst.i64 12
    v10 = global_value.i64 gv1
    call fn0(v8, v9, v10)
    call fn1(v7)
    call fn2()
    v11 = iconst.i64 1
    v13 = iadd.i64 v12, v11
    jump block1(v13)

block4:
    return
}

fun test_case_4

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): f64 = Lit(Float(1.0, 64)) |1.0
    Value(1): f64 = VarDecl(Value(0)) |a = 1.0
    Jump(Inst(4), Range { start: Value(0), end: Value(0) }) |loop:
    a = a + 1.0
    if a > 100.0:
      break

  Inst4Range { start: Value(0), end: Value(0) }
    Value(2): f64 = Lit(Float(1.0, 64)) |1.0
    Value(3): f64 = Call(Fun(413), Range { start: Value(0), end: Value(2) }) |a + 1.0
    Value(3): f64 = Assign(Value(1)) |a = a + 1.0
    Value(4): f64 = Lit(Float(100.0, 64)) |100.0
    Value(5): bool = Call(Fun(429), Range { start: Value(2), end: Value(4) }) |a > 100.0
    JumpIfTrue(Value(5), Inst(13), Range { start: Value(0), end: Value(0) }) |a > 100.0
    Jump(Inst(15), Range { start: Value(0), end: Value(0) }) |

  Inst13Range { start: Value(0), end: Value(0) }
    Jump(Inst(5), Range { start: Value(0), end: Value(0) }) |break

  Inst15Range { start: Value(0), end: Value(0) }
    Jump(Inst(4), Range { start: Value(0), end: Value(0) }) |loop:
    a = a + 1.0
    if a > 100.0:
      break

  Inst5Range { start: Value(0), end: Value(0) }
    Value(6): int = Call(Fun(164), Range { start: Value(4), end: Value(5) }) |f64::int(a)
    Value(7): int = Lit(Int(101, 0)) |101
    Value(8): bool = Call(Fun(310), Range { start: Value(5), end: Value(7) }) |f64::int(a) == 101
    Value(9): int = Lit(Int(95, 0)) |assert(f64::int(a) == 101)
    Value(10): int = Lit(Int(9, 0)) |assert(f64::int(a) == 101)
    Value(11): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(f64::int(a) == 101)
    Call(Fun(450), Range { start: Value(7), end: Value(10) }) |assert(f64::int(a) == 101)
    Call(Fun(515), Range { start: Value(10), end: Value(11) }) |assert(f64::int(a) == 101)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(f64::int(a) == 101)
    Return(None) |assert(f64::int(a) == 101)


function u0:0() fast {
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (b1) fast
    sig2 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:31 sig1
    fn2 = colocated u0:5 sig2

block0:
    v14 = f64const 0.0
    v1 -> v14
    v0 = f64const 0x1.0000000000000p0
    jump block1(v0)

block1(v3: f64):
    v2 = f64const 0x1.0000000000000p0
    v4 = fadd v3, v2
    v7 -> v4
    v15 -> v4
    v5 = f64const 0x1.9000000000000p6
    v6 = fcmp gt v4, v5
    brnz v6, block2
    jump block3

block2:
    jump block4

block3:
    jump block1(v15)

block4:
    v8 = fcvt_to_sint.i64 v7
    v9 = iconst.i64 101
    v10 = icmp eq v8, v9
    v11 = iconst.i64 95
    v12 = iconst.i64 9
    v13 = global_value.i64 gv0
    call fn0(v11, v12, v13)
    call fn1(v10)
    call fn2()
    return
}

fun test_case_3

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): int = Zeroed |a: int
    Value(1): int = VarDecl(Value(0)) |a: int
    Value(2): int = Call(Fun(225), Range { start: Value(0), end: Value(1) }) |++a
    Value(3): int = Call(Fun(235), Range { start: Value(1), end: Value(2) }) |--a
    Value(4): bool = Lit(Bool(true)) |true
    Value(5): bool = Call(Fun(251), Range { start: Value(2), end: Value(3) }) |!true
    Value(6): int = Call(Fun(165), Range { start: Value(3), end: Value(4) }) |bool::int(!true)
    Value(7): int = Lit(Int(1, 0)) |1
    Value(8): int = Call(Fun(205), Range { start: Value(4), end: Value(5) }) |~1
    Value(9): int = Call(Fun(260), Range { start: Value(5), end: Value(7) }) |bool::int(!true) + ~1
    Value(10): int = Lit(Int(2, 0)) |2
    Value(11): int = Call(Fun(260), Range { start: Value(7), end: Value(9) }) |bool::int(!true) + ~1 + 2
    Value(12): int = Lit(Int(1, 0)) |1
    Value(13): int = Call(Fun(243), Range { start: Value(9), end: Value(10) }) |-1
    Value(14): int = Call(Fun(250), Range { start: Value(10), end: Value(11) }) |abs -1
    Value(15): int = Call(Fun(260), Range { start: Value(11), end: Value(13) }) |bool::int(!true) + ~1 + 2 + abs -1
    Value(16): int = Lit(Int(1, 0)) |1
    Value(17): int = Call(Fun(270), Range { start: Value(13), end: Value(15) }) |bool::int(!true) + ~1 + 2 + abs -1 - 1
    Value(18): int = Call(Fun(260), Range { start: Value(15), end: Value(17) }) |bool::int(!true) + ~1 + 2 + abs -1 - 1 + a
    Value(19): int = Lit(Int(0, 0)) |0
    Value(20): bool = Call(Fun(310), Range { start: Value(17), end: Value(19) }) |bool::int(!true) + ~1 + 2 + abs -1 - 1 + a == 0
    Value(21): int = Lit(Int(85, 0)) |assert(bool::int(!true) + ~1 + 2 + abs -1 - 1 + a == 0)
    Value(22): int = Lit(Int(9, 0)) |assert(bool::int(!true) + ~1 + 2 + abs -1 - 1 + a == 0)
    Value(23): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(bool::int(!true) + ~1 + 2 + abs -1 - 1 + a == 0)
    Call(Fun(450), Range { start: Value(19), end: Value(22) }) |assert(bool::int(!true) + ~1 + 2 + abs -1 - 1 + a == 0)
    Call(Fun(515), Range { start: Value(22), end: Value(23) }) |assert(bool::int(!true) + ~1 + 2 + abs -1 - 1 + a == 0)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(bool::int(!true) + ~1 + 2 + abs -1 - 1 + a == 0)
    Return(None) |assert(bool::int(!true) + ~1 + 2 + abs -1 - 1 + a == 0)


function u0:0() fast {
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (b1) fast
    sig2 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:31 sig1
    fn2 = colocated u0:5 sig2

block0:
    v27 = iconst.i64 0
    v1 -> v27
    v0 = iconst.i64 0
    v2 = iadd_imm v0, 1
    v3 = iadd_imm v2, -1
    v4 = bconst.b1 true
    v5 = bint.i8 v4
    v6 = icmp_imm eq v5, 0
    v7 = bint.i64 v6
    v8 = iconst.i64 1
    v9 = bnot v8
    v10 = iadd v7, v9
    v11 = iconst.i64 2
    v12 = iadd v10, v11
    v13 = iconst.i64 1
    v14 = ineg v13
    v15 = icmp_imm sgt v14, 0
    v16 = ineg v14
    v17 = select v15, v14, v16
    v18 = iadd v12, v17
    v19 = iconst.i64 1
    v20 = isub v18, v19
    v21 = iadd v20, v3
    v22 = iconst.i64 0
    v23 = icmp eq v21, v22
    v24 = iconst.i64 85
    v25 = iconst.i64 9
    v26 = global_value.i64 gv0
    call fn0(v24, v25, v26)
    call fn1(v23)
    call fn2()
    return
}

fun test_case_2

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): Point = Zeroed |p, q: Point
    Value(1): Point = VarDecl(Value(0)) |p, q: Point
    Value(2): Point = Zeroed |p, q: Point
    Value(3): Point = VarDecl(Value(2)) |p, q: Point
    Value(4): int = Lit(Int(1, 0)) |1
    Value(5): int = Lit(Int(2, 0)) |2
    Value(7): int = Lit(Int(78, 0)) |p.set(1, 2)
    Value(8): int = Lit(Int(8, 0)) |p.set(1, 2)
    Value(9): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |p.set(1, 2)
    Call(Fun(450), Range { start: Value(0), end: Value(3) }) |p.set(1, 2)
    Value(6): Point = Call(Fun(496), Range { start: Value(3), end: Value(7) }) |p.set(1, 2)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |p.set(1, 2)
    Value(6): Point = Assign(Value(1)) |p = p.set(1, 2)
    Value(10): int = Offset(Value(1)) |p.x
    Value(11): int = Offset(Value(1)) |p.y
    Value(12): int = Call(Fun(260), Range { start: Value(7), end: Value(9) }) |p.x + p.y
    Value(13): int = Lit(Int(3, 0)) |3
    Value(14): bool = Call(Fun(310), Range { start: Value(9), end: Value(11) }) |p.x + p.y == 3
    Value(15): int = Lit(Int(79, 0)) |assert(p.x + p.y == 3)
    Value(16): int = Lit(Int(9, 0)) |assert(p.x + p.y == 3)
    Value(17): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(p.x + p.y == 3)
    Call(Fun(450), Range { start: Value(11), end: Value(14) }) |assert(p.x + p.y == 3)
    Call(Fun(515), Range { start: Value(14), end: Value(15) }) |assert(p.x + p.y == 3)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(p.x + p.y == 3)
    Return(None) |assert(p.x + p.y == 3)


function u0:0() fast {
    ss0 = explicit_slot 16
    ss1 = explicit_slot 16
    ss2 = explicit_slot 16
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (i64, i64, i64, i64 sret) -> i64 sret fast
    sig2 = () fast
    sig3 = (b1) fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:53 sig1
    fn2 = colocated u0:5 sig2
    fn3 = colocated u0:31 sig3

block0:
    v0 = iconst.i64 0
    stack_store v0, ss0
    stack_store v0, ss0+8
    v1 = iconst.i64 0
    stack_store v1, ss1
    stack_store v1, ss1+8
    v2 = iconst.i64 1
    v3 = iconst.i64 2
    v4 = iconst.i64 78
    v5 = iconst.i64 8
    v6 = global_value.i64 gv0
    call fn0(v4, v5, v6)
    v7 = stack_addr.i64 ss0
    v8 = stack_addr.i64 ss2
    v9 = call fn1(v7, v2, v3, v8)
    call fn2()
    v10 = stack_load.i64 ss2
    stack_store v10, ss0
    v11 = stack_load.i64 ss2+8
    stack_store v11, ss0+8
    v12 = stack_load.i64 ss0
    v13 = stack_load.i64 ss0+8
    v14 = iadd v12, v13
    v15 = iconst.i64 3
    v16 = icmp eq v14, v15
    v17 = iconst.i64 79
    v18 = iconst.i64 9
    v19 = global_value.i64 gv0
    call fn0(v17, v18, v19)
    call fn3(v16)
    call fn2()
    return
}

fun set(p: Self, x: int, y: int) -> Self

  Inst1Range { start: Value(0), end: Value(4) }
    Value(4): Point = VarDecl(Value(0)) |p = p
    Value(5): int = Offset(Value(4)) |p.x
    Value(1): int = Assign(Value(5)) |p.x = x
    Value(6): int = Offset(Value(4)) |p.y
    Value(2): int = Assign(Value(6)) |p.y = y
    Value(7): Point = Deref(Value(3), false) |return p
    Value(4): Point = Assign(Value(7)) |return p
    Return(Some(Value(3))) |return p


function u0:0(i64, i64, i64, i64 sret) -> i64 sret fast {
    ss0 = explicit_slot 16

block0(v0: i64, v1: i64, v2: i64, v3: i64):
    v4 = stack_addr.i64 ss0
    v5 = load.i64 v0
    store v5, v4
    v6 = load.i64 v0+8
    store v6, v4+8
    stack_store v1, ss0
    stack_store v2, ss0+8
    v7 = stack_addr.i64 ss0
    v8 = load.i64 v7
    store v8, v3
    v9 = load.i64 v7+8
    store v9, v3+8
    return v3
}

fun test_case_1

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): Point = Zeroed |p: Point
    Value(1): Point = VarDecl(Value(0)) |p: Point
    Value(2): Point3 = Zeroed |p3: Point3
    Value(3): Point3 = VarDecl(Value(2)) |p3: Point3
    Value(4): Rect = Zeroed |r: Rect
    Value(5): Rect = VarDecl(Value(4)) |r: Rect
    Value(6): int = Offset(Value(1)) |p.x
    Value(7): int = Lit(Int(1, 0)) |1
    Value(7): int = Assign(Value(6)) |p.x = 1
    Value(8): Point = Offset(Value(3)) |p3.point
    Value(1): Point = Assign(Value(8)) |p3.point = p
    Value(9): int = Offset(Value(3)) |p3.y
    Value(10): int = Lit(Int(2, 0)) |2
    Value(10): int = Assign(Value(9)) |p3.y = 2
    Value(11): Point = Offset(Value(5)) |r.mi
    Value(12): Point = Offset(Value(3)) |p3.point
    Value(12): Point = Assign(Value(11)) |r.mi = p3.point
    Value(13): Point = Offset(Value(5)) |r
    Value(14): int = Offset(Value(13)) |r.mi.x
    Value(15): Point = Offset(Value(5)) |r
    Value(16): int = Offset(Value(15)) |r.mi.y
    Value(17): int = Call(Fun(270), Range { start: Value(0), end: Value(2) }) |r.mi.x - r.mi.y
    Value(18): int = Lit(Int(1, 0)) |1
    Value(19): int = Call(Fun(260), Range { start: Value(2), end: Value(4) }) |r.mi.x - r.mi.y + 1
    Value(20): int = Lit(Int(0, 0)) |0
    Value(21): bool = Call(Fun(310), Range { start: Value(4), end: Value(6) }) |r.mi.x - r.mi.y + 1 == 0
    Value(22): int = Lit(Int(66, 0)) |assert(r.mi.x - r.mi.y + 1 == 0)
    Value(23): int = Lit(Int(9, 0)) |assert(r.mi.x - r.mi.y + 1 == 0)
    Value(24): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(r.mi.x - r.mi.y + 1 == 0)
    Call(Fun(450), Range { start: Value(6), end: Value(9) }) |assert(r.mi.x - r.mi.y + 1 == 0)
    Call(Fun(515), Range { start: Value(9), end: Value(10) }) |assert(r.mi.x - r.mi.y + 1 == 0)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(r.mi.x - r.mi.y + 1 == 0)
    Return(None) |assert(r.mi.x - r.mi.y + 1 == 0)


function u0:0() fast {
    ss0 = explicit_slot 16
    ss1 = explicit_slot 24
    ss2 = explicit_slot 32
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (b1) fast
    sig2 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:31 sig1
    fn2 = colocated u0:5 sig2

block0:
    v0 = iconst.i64 0
    stack_store v0, ss0
    stack_store v0, ss0+8
    v1 = iconst.i64 0
    stack_store v1, ss1
    stack_store v1, ss1+8
    stack_store v1, ss1+16
    v2 = iconst.i64 0
    stack_store v2, ss2
    stack_store v2, ss2+8
    stack_store v2, ss2+16
    stack_store v2, ss2+24
    v3 = iconst.i64 1
    stack_store v3, ss0
    v4 = stack_load.i64 ss0
    stack_store v4, ss1
    v5 = stack_load.i64 ss0+8
    stack_store v5, ss1+8
    v6 = iconst.i64 2
    stack_store v6, ss1+8
    v7 = stack_load.i64 ss1
    stack_store v7, ss2
    v8 = stack_load.i64 ss1+8
    stack_store v8, ss2+8
    v9 = stack_load.i64 ss2
    v10 = stack_load.i64 ss2+8
    v11 = isub v9, v10
    v12 = iconst.i64 1
    v13 = iadd v11, v12
    v14 = iconst.i64 0
    v15 = icmp eq v13, v14
    v16 = iconst.i64 66
    v17 = iconst.i64 9
    v18 = global_value.i64 gv0
    call fn0(v16, v17, v18)
    call fn1(v15)
    call fn2()
    return
}

fun fib_loop(v: int) -> int

  Inst1Range { start: Value(0), end: Value(1) }
    Value(1): int = Lit(Int(1, 0)) |1
    Value(2): int = VarDecl(Value(1)) |a, b, c = 1
    Value(3): int = VarDecl(Value(2)) |a, b, c = 1
    Value(4): int = VarDecl(Value(2)) |a, b, c = 1
    Value(5): int = VarDecl(Value(0)) |v = v
    Jump(Inst(7), Range { start: Value(0), end: Value(0) }) |loop'a:
    c = a + b
    a = b
    b = c
    v = v - 1
    if v == 1:
      break'a

  Inst7Range { start: Value(0), end: Value(0) }
    Value(6): int = Call(Fun(260), Range { start: Value(1), end: Value(3) }) |a + b
    Value(6): int = Assign(Value(4)) |c = a + b
    Value(3): int = Assign(Value(2)) |a = b
    Value(4): int = Assign(Value(3)) |b = c
    Value(7): int = Lit(Int(1, 0)) |1
    Value(8): int = Call(Fun(270), Range { start: Value(3), end: Value(5) }) |v - 1
    Value(8): int = Assign(Value(5)) |v = v - 1
    Value(9): int = Lit(Int(1, 0)) |1
    Value(10): bool = Call(Fun(310), Range { start: Value(5), end: Value(7) }) |v == 1
    JumpIfTrue(Value(10), Inst(20), Range { start: Value(0), end: Value(0) }) |v == 1
    Jump(Inst(22), Range { start: Value(0), end: Value(0) }) |

  Inst20Range { start: Value(0), end: Value(0) }
    Jump(Inst(8), Range { start: Value(0), end: Value(0) }) |break'a

  Inst22Range { start: Value(0), end: Value(0) }
    Jump(Inst(7), Range { start: Value(0), end: Value(0) }) |loop'a:
    c = a + b
    a = b
    b = c
    v = v - 1
    if v == 1:
      break'a

  Inst8Range { start: Value(0), end: Value(0) }
    Return(Some(Value(4))) |return c


function u0:0(i64) -> i64 fast {
block0(v0: i64):
    v19 = iconst.i64 0
    v5 -> v19
    v18 = iconst.i64 0
    v4 -> v18
    v17 = iconst.i64 0
    v3 -> v17
    v16 = iconst.i64 0
    v2 -> v16
    v1 = iconst.i64 1
    jump block1(v1, v1, v1, v0)

block1(v6: i64, v7: i64, v9: i64, v11: i64):
    v20 -> v7
    v8 = iadd v6, v7
    v15 -> v8
    v21 -> v8
    v22 -> v8
    v10 = iconst.i64 1
    v12 = isub v11, v10
    v23 -> v12
    v13 = iconst.i64 1
    v14 = icmp eq v12, v13
    brnz v14, block2
    jump block3

block2:
    jump block4

block3:
    jump block1(v20, v21, v22, v23)

block4:
    return v15
}

fun fib(v: int) -> int

  Inst1Range { start: Value(0), end: Value(1) }
    Value(1): int = Lit(Int(2, 0)) |2
    Value(2): bool = Call(Fun(360), Range { start: Value(1), end: Value(3) }) |v < 2
    JumpIfTrue(Value(2), Inst(4), Range { start: Value(0), end: Value(0) }) |v < 2
    Jump(Inst(7), Range { start: Value(0), end: Value(0) }) |:

  Inst4Range { start: Value(0), end: Value(0) }
    Value(3): int = Lit(Int(1, 0)) |1
    Jump(Inst(6), Range { start: Value(3), end: Value(4) }) |if v < 2:
    1
  else:
    fib(v - 1) + fib(v - 2)

  Inst7Range { start: Value(0), end: Value(0) }
    Value(5): int = Lit(Int(1, 0)) |1
    Value(6): int = Call(Fun(270), Range { start: Value(5), end: Value(7) }) |v - 1
    Value(8): int = Lit(Int(28, 0)) |fib(v - 1)
    Value(9): int = Lit(Int(8, 0)) |fib(v - 1)
    Value(10): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |fib(v - 1)
    Call(Fun(450), Range { start: Value(7), end: Value(10) }) |fib(v - 1)
    Value(7): int = Call(Fun(493), Range { start: Value(10), end: Value(11) }) |fib(v - 1)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |fib(v - 1)
    Value(11): int = Lit(Int(2, 0)) |2
    Value(12): int = Call(Fun(270), Range { start: Value(11), end: Value(13) }) |v - 2
    Value(14): int = Lit(Int(28, 0)) |fib(v - 2)
    Value(15): int = Lit(Int(21, 0)) |fib(v - 2)
    Value(16): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |fib(v - 2)
    Call(Fun(450), Range { start: Value(13), end: Value(16) }) |fib(v - 2)
    Value(13): int = Call(Fun(493), Range { start: Value(16), end: Value(17) }) |fib(v - 2)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |fib(v - 2)
    Value(17): int = Call(Fun(260), Range { start: Value(17), end: Value(19) }) |fib(v - 1) + fib(v - 2)
    Jump(Inst(6), Range { start: Value(19), end: Value(20) }) |fib(v - 1) + fib(v - 2)

  Inst6Range { start: Value(4), end: Value(5) }
    Return(Some(Value(4))) |return if v < 2:
    1
  else:
    fib(v - 1) + fib(v - 2)


function u0:0(i64) -> i64 fast {
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (i64) -> i64 fast
    sig2 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:56 sig1
    fn2 = colocated u0:5 sig2

block0(v0: i64):
    v2 = iconst.i64 2
    v3 = icmp slt v0, v2
    brnz v3, block1
    jump block2

block1:
    v4 = iconst.i64 1
    jump block3(v4)

block2:
    v5 = iconst.i64 1
    v6 = isub.i64 v0, v5
    v7 = iconst.i64 28
    v8 = iconst.i64 8
    v9 = global_value.i64 gv0
    call fn0(v7, v8, v9)
    v10 = call fn1(v6)
    call fn2()
    v11 = iconst.i64 2
    v12 = isub.i64 v0, v11
    v13 = iconst.i64 28
    v14 = iconst.i64 21
    v15 = global_value.i64 gv0
    call fn0(v13, v14, v15)
    v16 = call fn1(v12)
    call fn2()
    v17 = iadd v10, v16
    jump block3(v17)

block3(v1: i64):
    return v1
}

fun fine -> int

  Inst1Range { start: Value(0), end: Value(0) }
    Value(0): int = Lit(Int(1, 0)) |1
    Value(1): int = Lit(Int(1, 0)) |1
    Value(2): int = Call(Fun(270), Range { start: Value(0), end: Value(2) }) |1 - 1
    Value(3): int = Lit(Int(0, 0)) |0
    Value(4): bool = Call(Fun(310), Range { start: Value(2), end: Value(4) }) |1 - 1 == 0
    Value(5): int = Lit(Int(3, 0)) |assert(1 - 1 == 0)
    Value(6): int = Lit(Int(9, 0)) |assert(1 - 1 == 0)
    Value(7): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(1 - 1 == 0)
    Call(Fun(450), Range { start: Value(4), end: Value(7) }) |assert(1 - 1 == 0)
    Call(Fun(515), Range { start: Value(7), end: Value(8) }) |assert(1 - 1 == 0)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(1 - 1 == 0)
    Value(8): int = Lit(Int(1, 0)) |1
    Value(9): int = Lit(Int(1, 0)) |1
    Value(10): int = Call(Fun(260), Range { start: Value(8), end: Value(10) }) |1 + 1
    Value(11): int = Lit(Int(2, 0)) |2
    Value(12): bool = Call(Fun(310), Range { start: Value(10), end: Value(12) }) |1 + 1 == 2
    Value(13): int = Lit(Int(4, 0)) |assert(1 + 1 == 2)
    Value(14): int = Lit(Int(9, 0)) |assert(1 + 1 == 2)
    Value(15): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(1 + 1 == 2)
    Call(Fun(450), Range { start: Value(12), end: Value(15) }) |assert(1 + 1 == 2)
    Call(Fun(515), Range { start: Value(15), end: Value(16) }) |assert(1 + 1 == 2)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(1 + 1 == 2)
    Value(16): int = Lit(Int(1, 0)) |1
    Value(17): int = Lit(Int(1, 0)) |1
    Value(18): bool = Call(Fun(310), Range { start: Value(16), end: Value(18) }) |1 == 1
    JumpIfTrue(Value(18), Inst(27), Range { start: Value(0), end: Value(0) }) |1 == 1
    Jump(Inst(30), Range { start: Value(0), end: Value(0) }) |:

  Inst27Range { start: Value(0), end: Value(0) }
    Value(19): int = Lit(Int(1, 0)) |1
    Jump(Inst(29), Range { start: Value(18), end: Value(19) }) |(if 1 == 1: 1 else: 0)

  Inst30Range { start: Value(0), end: Value(0) }
    Value(21): int = Lit(Int(0, 0)) |0
    Jump(Inst(29), Range { start: Value(20), end: Value(21) }) |0

  Inst29Range { start: Value(19), end: Value(20) }
    Value(22): int = Lit(Int(1, 0)) |1
    Value(23): bool = Call(Fun(310), Range { start: Value(21), end: Value(23) }) |(if 1 == 1: 1 else: 0) == 1
    Value(24): int = Lit(Int(5, 0)) |assert((if 1 == 1: 1 else: 0) == 1)
    Value(25): int = Lit(Int(9, 0)) |assert((if 1 == 1: 1 else: 0) == 1)
    Value(26): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert((if 1 == 1: 1 else: 0) == 1)
    Call(Fun(450), Range { start: Value(23), end: Value(26) }) |assert((if 1 == 1: 1 else: 0) == 1)
    Call(Fun(515), Range { start: Value(26), end: Value(27) }) |assert((if 1 == 1: 1 else: 0) == 1)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert((if 1 == 1: 1 else: 0) == 1)
    Value(27): int = Lit(Int(10, 0)) |10
    Value(29): int = Lit(Int(6, 0)) |fib(10)
    Value(30): int = Lit(Int(13, 0)) |fib(10)
    Value(31): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |fib(10)
    Call(Fun(450), Range { start: Value(27), end: Value(30) }) |fib(10)
    Value(28): int = Call(Fun(493), Range { start: Value(30), end: Value(31) }) |fib(10)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |fib(10)
    Value(32): int = Lit(Int(10, 0)) |10
    Value(34): int = Lit(Int(6, 0)) |fib_loop(10)
    Value(35): int = Lit(Int(29, 0)) |fib_loop(10)
    Value(36): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |fib_loop(10)
    Call(Fun(450), Range { start: Value(31), end: Value(34) }) |fib_loop(10)
    Value(33): int = Call(Fun(494), Range { start: Value(34), end: Value(35) }) |fib_loop(10)
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |fib_loop(10)
    Value(37): bool = Call(Fun(310), Range { start: Value(35), end: Value(37) }) |fib(10) == fib_loop(10)
    Value(38): int = Lit(Int(6, 0)) |assert(fib(10) == fib_loop(10))
    Value(39): int = Lit(Int(9, 0)) |assert(fib(10) == fib_loop(10))
    Value(40): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |assert(fib(10) == fib_loop(10))
    Call(Fun(450), Range { start: Value(37), end: Value(40) }) |assert(fib(10) == fib_loop(10))
    Call(Fun(515), Range { start: Value(40), end: Value(41) }) |assert(fib(10) == fib_loop(10))
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |assert(fib(10) == fib_loop(10))
    Value(41): int = Lit(Int(8, 0)) |test_case_1()
    Value(42): int = Lit(Int(14, 0)) |test_case_1()
    Value(43): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_1()
    Call(Fun(450), Range { start: Value(41), end: Value(44) }) |test_case_1()
    Call(Fun(495), Range { start: Value(44), end: Value(44) }) |test_case_1()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_1()
    Value(44): int = Lit(Int(9, 0)) |test_case_2()
    Value(45): int = Lit(Int(14, 0)) |test_case_2()
    Value(46): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_2()
    Call(Fun(450), Range { start: Value(44), end: Value(47) }) |test_case_2()
    Call(Fun(497), Range { start: Value(47), end: Value(47) }) |test_case_2()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_2()
    Value(47): int = Lit(Int(10, 0)) |test_case_3()
    Value(48): int = Lit(Int(14, 0)) |test_case_3()
    Value(49): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_3()
    Call(Fun(450), Range { start: Value(47), end: Value(50) }) |test_case_3()
    Call(Fun(498), Range { start: Value(50), end: Value(50) }) |test_case_3()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_3()
    Value(50): int = Lit(Int(11, 0)) |test_case_4()
    Value(51): int = Lit(Int(14, 0)) |test_case_4()
    Value(52): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_4()
    Call(Fun(450), Range { start: Value(50), end: Value(53) }) |test_case_4()
    Call(Fun(499), Range { start: Value(53), end: Value(53) }) |test_case_4()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_4()
    Value(53): int = Lit(Int(12, 0)) |test_case_5()
    Value(54): int = Lit(Int(14, 0)) |test_case_5()
    Value(55): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_5()
    Call(Fun(450), Range { start: Value(53), end: Value(56) }) |test_case_5()
    Call(Fun(501), Range { start: Value(56), end: Value(56) }) |test_case_5()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_5()
    Value(56): int = Lit(Int(13, 0)) |test_case_6()
    Value(57): int = Lit(Int(14, 0)) |test_case_6()
    Value(58): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_6()
    Call(Fun(450), Range { start: Value(56), end: Value(59) }) |test_case_6()
    Call(Fun(503), Range { start: Value(59), end: Value(59) }) |test_case_6()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_6()
    Value(59): int = Lit(Int(14, 0)) |test_case_7()
    Value(60): int = Lit(Int(14, 0)) |test_case_7()
    Value(61): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_7()
    Call(Fun(450), Range { start: Value(59), end: Value(62) }) |test_case_7()
    Call(Fun(504), Range { start: Value(62), end: Value(62) }) |test_case_7()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_7()
    Value(62): int = Lit(Int(15, 0)) |test_case_8()
    Value(63): int = Lit(Int(14, 0)) |test_case_8()
    Value(64): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_8()
    Call(Fun(450), Range { start: Value(62), end: Value(65) }) |test_case_8()
    Call(Fun(505), Range { start: Value(65), end: Value(65) }) |test_case_8()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_8()
    Value(65): int = Lit(Int(16, 0)) |test_case_9()
    Value(66): int = Lit(Int(14, 0)) |test_case_9()
    Value(67): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_9()
    Call(Fun(450), Range { start: Value(65), end: Value(68) }) |test_case_9()
    Call(Fun(506), Range { start: Value(68), end: Value(68) }) |test_case_9()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_9()
    Value(68): int = Lit(Int(17, 0)) |test_case_10()
    Value(69): int = Lit(Int(15, 0)) |test_case_10()
    Value(70): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_10()
    Call(Fun(450), Range { start: Value(68), end: Value(71) }) |test_case_10()
    Call(Fun(507), Range { start: Value(71), end: Value(71) }) |test_case_10()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_10()
    Value(71): int = Lit(Int(18, 0)) |test_case_11()
    Value(72): int = Lit(Int(15, 0)) |test_case_11()
    Value(73): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_11()
    Call(Fun(450), Range { start: Value(71), end: Value(74) }) |test_case_11()
    Call(Fun(508), Range { start: Value(74), end: Value(74) }) |test_case_11()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_11()
    Value(74): int = Lit(Int(19, 0)) |test_case_12()
    Value(75): int = Lit(Int(15, 0)) |test_case_12()
    Value(76): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_12()
    Call(Fun(450), Range { start: Value(74), end: Value(77) }) |test_case_12()
    Call(Fun(509), Range { start: Value(77), end: Value(77) }) |test_case_12()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_12()
    Value(77): int = Lit(Int(20, 0)) |test_case_13()
    Value(78): int = Lit(Int(15, 0)) |test_case_13()
    Value(79): &u8 = Lit(String(Span { source: Source(0), hash: ID(14979365136090743649), start: 342, end: 371, line: 0, column: 0 })) |test_case_13()
    Call(Fun(450), Range { start: Value(77), end: Value(80) }) |test_case_13()
    Call(Fun(512), Range { start: Value(80), end: Value(80) }) |test_case_13()
    Call(Fun(451), Range { start: Value(0), end: Value(0) }) |test_case_13()
    Value(80): int = Lit(Int(0, 0)) |0
    Return(Some(Value(80))) |return 0


function u0:0() -> i64 fast {
    gv0 = symbol colocated u1:8
    sig0 = (i64, i64, i64) fast
    sig1 = (b1) fast
    sig2 = () fast
    sig3 = (i64) -> i64 fast
    sig4 = (i64) -> i64 fast
    sig5 = () fast
    sig6 = () fast
    sig7 = () fast
    sig8 = () fast
    sig9 = () fast
    sig10 = () fast
    sig11 = () fast
    sig12 = () fast
    sig13 = () fast
    sig14 = () fast
    sig15 = () fast
    sig16 = () fast
    sig17 = () fast
    fn0 = colocated u0:10 sig0
    fn1 = colocated u0:31 sig1
    fn2 = colocated u0:5 sig2
    fn3 = colocated u0:56 sig3
    fn4 = colocated u0:55 sig4
    fn5 = colocated u0:54 sig5
    fn6 = colocated u0:52 sig6
    fn7 = colocated u0:51 sig7
    fn8 = colocated u0:50 sig8
    fn9 = colocated u0:49 sig9
    fn10 = colocated u0:47 sig10
    fn11 = colocated u0:46 sig11
    fn12 = colocated u0:45 sig12
    fn13 = colocated u0:44 sig13
    fn14 = colocated u0:39 sig14
    fn15 = colocated u0:38 sig15
    fn16 = colocated u0:37 sig16
    fn17 = colocated u0:34 sig17

block0:
    v1 = iconst.i64 1
    v2 = iconst.i64 1
    v3 = isub v1, v2
    v4 = iconst.i64 0
    v5 = icmp eq v3, v4
    v6 = iconst.i64 3
    v7 = iconst.i64 9
    v8 = global_value.i64 gv0
    call fn0(v6, v7, v8)
    call fn1(v5)
    call fn2()
    v9 = iconst.i64 1
    v10 = iconst.i64 1
    v11 = iadd v9, v10
    v12 = iconst.i64 2
    v13 = icmp eq v11, v12
    v14 = iconst.i64 4
    v15 = iconst.i64 9
    v16 = global_value.i64 gv0
    call fn0(v14, v15, v16)
    call fn1(v13)
    call fn2()
    v17 = iconst.i64 1
    v18 = iconst.i64 1
    v19 = icmp eq v17, v18
    brnz v19, block1
    jump block2

block1:
    v20 = iconst.i64 1
    jump block3(v20)

block2:
    v21 = iconst.i64 0
    jump block3(v21)

block3(v0: i64):
    v22 = iconst.i64 1
    v23 = icmp eq v0, v22
    v24 = iconst.i64 5
    v25 = iconst.i64 9
    v26 = global_value.i64 gv0
    call fn0(v24, v25, v26)
    call fn1(v23)
    call fn2()
    v27 = iconst.i64 10
    v28 = iconst.i64 6
    v29 = iconst.i64 13
    v30 = global_value.i64 gv0
    call fn0(v28, v29, v30)
    v31 = call fn3(v27)
    call fn2()
    v32 = iconst.i64 10
    v33 = iconst.i64 6
    v34 = iconst.i64 29
    v35 = global_value.i64 gv0
    call fn0(v33, v34, v35)
    v36 = call fn4(v32)
    call fn2()
    v37 = icmp eq v31, v36
    v38 = iconst.i64 6
    v39 = iconst.i64 9
    v40 = global_value.i64 gv0
    call fn0(v38, v39, v40)
    call fn1(v37)
    call fn2()
    v41 = iconst.i64 8
    v42 = iconst.i64 14
    v43 = global_value.i64 gv0
    call fn0(v41, v42, v43)
    call fn5()
    call fn2()
    v44 = iconst.i64 9
    v45 = iconst.i64 14
    v46 = global_value.i64 gv0
    call fn0(v44, v45, v46)
    call fn6()
    call fn2()
    v47 = iconst.i64 10
    v48 = iconst.i64 14
    v49 = global_value.i64 gv0
    call fn0(v47, v48, v49)
    call fn7()
    call fn2()
    v50 = iconst.i64 11
    v51 = iconst.i64 14
    v52 = global_value.i64 gv0
    call fn0(v50, v51, v52)
    call fn8()
    call fn2()
    v53 = iconst.i64 12
    v54 = iconst.i64 14
    v55 = global_value.i64 gv0
    call fn0(v53, v54, v55)
    call fn9()
    call fn2()
    v56 = iconst.i64 13
    v57 = iconst.i64 14
    v58 = global_value.i64 gv0
    call fn0(v56, v57, v58)
    call fn10()
    call fn2()
    v59 = iconst.i64 14
    v60 = iconst.i64 14
    v61 = global_value.i64 gv0
    call fn0(v59, v60, v61)
    call fn11()
    call fn2()
    v62 = iconst.i64 15
    v63 = iconst.i64 14
    v64 = global_value.i64 gv0
    call fn0(v62, v63, v64)
    call fn12()
    call fn2()
    v65 = iconst.i64 16
    v66 = iconst.i64 14
    v67 = global_value.i64 gv0
    call fn0(v65, v66, v67)
    call fn13()
    call fn2()
    v68 = iconst.i64 17
    v69 = iconst.i64 15
    v70 = global_value.i64 gv0
    call fn0(v68, v69, v70)
    call fn14()
    call fn2()
    v71 = iconst.i64 18
    v72 = iconst.i64 15
    v73 = global_value.i64 gv0
    call fn0(v71, v72, v73)
    call fn15()
    call fn2()
    v74 = iconst.i64 19
    v75 = iconst.i64 15
    v76 = global_value.i64 gv0
    call fn0(v74, v75, v76)
    call fn16()
    call fn2()
    v77 = iconst.i64 20
    v78 = iconst.i64 15
    v79 = global_value.i64 gv0
    call fn0(v77, v78, v79)
    call fn17()
    call fn2()
    v80 = iconst.i64 0
    return v80
}



  Inst1Range { start: Value(0), end: Value(2) }
    Value(2): int = Zeroed |
    Value(3): int = VarDecl(Value(2)) |
    Value(4): int = Lit(Int(1, 0)) |1
    Value(5): int = GlobalLoad(Global(2)) |1
    Value(4): int = Assign(Value(5)) |1
    Value(6): int = Call(Fun(492), Range { start: Value(0), end: Value(0) }) |fun fine -> int
    Value(6): int = Assign(Value(3)) |fun fine -> int
    Return(Some(Value(3))) |


function u0:0(i64, i64) -> i64 windows_fastcall {
    gv0 = symbol colocated u1:7
    sig0 = () -> i64 fast
    fn0 = colocated u0:57 sig0

block0(v0: i64, v1: i64):
    v7 = iconst.i64 0
    v3 -> v7
    v2 = iconst.i64 0
    v4 = iconst.i64 1
    v5 = global_value.i64 gv0
    store v4, v5
    v6 = call fn0()
    return v6
}

output:
ok
ok
ok
ok
ok
ok
ok
ok
Hello, World!ok
ok
ok
ok
ok
ok
ok
ok

:end
